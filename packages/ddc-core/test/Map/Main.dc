
-- NOTE
-- Parser should take client parser for varibles and primops.
-- Forget about prefixing variable and constructor names with namespace qualifiers.
-- Use 'Parse' for the Haskell 'Read' type class.
-- Stolen constructor names aren't that many:
--      Read Write Const Mutable DeepConst DeepMutable etc.
--
-- Wrap type applications in {}
--      eg {Int} {Const r1 + Const r2}
--
-- Allow a list of applications in {| |}
--      eg {|a1 (Int r1) r1 r2 r3 e1 e2|}
--
-- Add purifying coersions 
--      purify {w1 & w2} (f x)
--
module Test where

{-# PRIM TYPE Int #-}
foreign type Int       :: % -> *;

{-# PRIM TYPE Char #-}
foreign type Char      :: % -> *;


-- NOTE: the :- form should just be sugar.
--       the PRIM OP pragma says that bound occurrences are turned into XPrim instead of XVar.
--       We're not expecting there to be a symbol involving this during linking.
--       The interpreter only works with primops.
--       Parser should take a (String -> SourcePos -> Prim) function.
{-# PRIM OP add #-}
foreign value add
        :: [r1 r2 r3: %]
        .  Int r1 -> Int r2 -(e c)> Int r3
        :- e = Read r1 + Read r2
        ,  c = Free r1;


-- Type bindings
data List (r: %) (a: *) {
        Nil     :: [r: %] [a: *]. List r a
        Cons    :: [r: %] [a: *]. a -> List r a -> List r a
};


-- Value bindings
id      = [x: *]. x;
five    = id {Int} 5;

map  :: [a1 a2: *] [r1 r2: %] [e: !] [c: $]
     .  (a1 -(e c)> a2) -> List r1 a1 -> List r2 a2;

map     [a1 a2: *] [r1 r2: %] [e: !] [c: $].
        (f:  a1 -(e c)> a2) (xs: List r1 a1) : List r2 a2
        = case xs of {
                Nil             -> Nil;
                Cons x xs       -> Cons {a2} (f x) (map {|a1 a2 r1 r2 e c|} f) xs;
        };


map_lazy 
        [a1, a2: *] [r1 r2: %] [c: $] --- TODO: remove comma syntax between vars
        (w: Const r1) (w5: Shared r2)
        (f: a1 -(!0 c)> a2) (xs: List r1 a1)
        = purify <w1 & read w2 & read w3>     -- TODO: allow witness to be elided and reconstructed, 
          forget <w1 & free w w5>             --       can just leave it out because we'll never otherwise see a <
          case xs of {
                Nil             -> Nil;
                Cons x xs       
                 -> Cons {a2}
                        (f x) 
                        (suspend {List r1 a1} {List r2 a2} (map_lazy {|a1 a2 r1 r2|} f) xs);
          };


-- NOTE: Interpreter expects a function with a single region parameter,
--       and will pass a constructor for the region that the return value
--       can be allocated into.
result  =  \(rr: %).
        in local r1 with {w1 = const   r1}
        in local r2 with {w2 = mutable r2}
        in map_lazy
                {Int r1} {Int r2} {r1} {rr} 
                (purify {w1 & w2} (add {|r1 r2 r3|} (5 {r1})))
                (Cons {r1} (10 {r1}) (Cons {r1} (10 {r2}) (Nil {r2})))

