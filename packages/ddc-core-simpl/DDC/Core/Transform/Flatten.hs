module DDC.Core.Transform.Flatten
        ( flatten
        , flatten1)
where
import DDC.Core.Transform.TransformX
import DDC.Core.Transform.AnonymizeX
import DDC.Core.Transform.LiftX
import DDC.Core.Exp
import DDC.Core.Compounds
import Data.Functor.Identity


-- | Flatten binding structure in a thing.
--
--   Flattens nested let-expressions, 
--   and single alternative let-case expressions
--
--   * Does not change the order of evaluation.
--   * Weakly improving, will not make code worse.
--
flatten :: Ord n 
        => (TransformUpMX Identity c)
        => c a n -> c a n
flatten = transformUpX' flatten1


-- | Flatten a single nested let-expression.
---
-- TODO: make this work on lazy lets as well.
flatten1
        :: Ord n
        => Exp a n
        -> Exp a n


-- Let ----------------------------------------------------
-- Flatten Nested Lets.
-- @
--      let b1 = (let b2 = def2 in x2) in
--      x1
--
--  ==> let b2 = def2 in 
--      let b1 = x2   in
--      x1
-- @
-- 
--  Handle case where b2 is anonymous (ones generated by makeLets are).
--  If we tried to wrap x1 in b2 when b2's name is already used, we'd be in trouble.

-- TODO: refactor to liftThrogh function
--       that takes the binders we're packing ontop
flatten1 (XLet a1 (LLet LetStrict b1
                  (XLet a2 (LLet LetStrict b2@(BAnon _) def2) x2))
                  x1)
 = let  -- If b1 is anon, we don't want to lift references to it
        liftDepth = case b1 of { BAnon _ -> 1; _ -> 0 }                         
        x1'       = liftAtDepthX 1 liftDepth x1                                 
   in   XLet a2 (LLet LetStrict b2 def2) 
     $  flatten1
     $  XLet a1 (LLet LetStrict b1 x2) x1'

flatten1 (XLet a1 (LLet LetStrict b1
                  (XLet a2 (LLet LetStrict b2@(BNone _) def2) x2))
                  x1)
 =      XLet a2 (LLet LetStrict b2 def2)
 $      flatten1
 $      XLet a1 (LLet LetStrict b1 x2) x1

-- Same as above but b2 isn't anonymous.
-- anonymize inner let & re-flatten.
flatten1 (XLet a1 (LLet LetStrict b1 
            inner@(XLet _ (LLet LetStrict BName{} _) _)) 
                   x1)
 = flatten1
 $ XLet a1
        (LLet LetStrict b1 (anonymizeX inner))
        x1



-- Drag 'letregion' out of the top-level of a binding.
-- @
--    let b1 = letregion b2 in x2 in
--    x1
--
-- => letregion r2 in 
--    let b1 = x2 in
--    x1
-- @
--
flatten1 (XLet a1 (LLet LetStrict b1
                  (XLet a2 (LLetRegion b2 bs2) x2))                     -- TODO: do lifting and handle anon binders.
                  x1)
 = XLet a2 (LLetRegion b2 bs2) 
 $ flatten1
 $ XLet a1 (LLet LetStrict b1 x2)
 $ x1


-- Flatten single-alt case expressions.
-- @
--     let b1 = case x1 of 
--                P -> x2 
--     in x3
--
--  => case x1 of 
--       P -> let b1 = x2 
--            in x3
-- @
--
-- * binding must be strict because we force evaluation of x1.
--
flatten1 (XLet  a1 (LLet LetStrict b1 
                         (XCase a2 x1 [AAlt p x2]))
                x3)
 = let  levels  = length $ [b | b@(BAnon _) <- bindsOfPat p]            -- todo: refactor to 'pushX' fun
        x3'     = liftAtDepthX 1 levels x3
   in   XCase a2 x1 
           [AAlt p (XLet a1 (LLet LetStrict b1 x2)
                        (anonymizeX x3'))]


-- Any let, its bound expression doesn't contain a strict non-recursive
-- let so just flatten the body
flatten1 (XLet a1 llet1 x1)
 = XLet a1 llet1 (flatten1 x1)


-- Case ---------------------------------------------------
flatten1 (XCase a x1 alts)
 = XCase a (flatten1 x1) 
           [AAlt p (flatten1 x) | AAlt p x <- alts ]


-- Anything else we can ignore. 
-- We don't need to recurse, because this is always called immediately after
-- makeLets.
flatten1 x = x


