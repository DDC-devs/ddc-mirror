
module SMR.Prim.Name
export 
{       pretty_Prim;    show_Prim;
        readPrim
}
import SMR.Prim.Name.Bool
import SMR.Prim.Name.List
import SMR.Prim.Name.Match
import SMR.Prim.Name.Nat
import Class.Show
import Class.Pretty
where


-- TODO: kill the intermediate prim wrappers.
-- needing to do lexing and showing doesn't add any value.
-- just represent prims as names.
-- There should be a map of primitve name to some generic description
-- of what the args are and how to evaluate it.
-- For safe code just make whitelist for allowable prims,
-- should just be a list of names. Could also then do profiling to see
-- how many of each one were executed. Interpretation enables nice profiling.

data Prim where        
        PrimBool        : PrimBool      -> Prim
        PrimList        : PrimList      -> Prim
        PrimMatch       : PrimMatch     -> Prim
        PrimNat         : PrimNat       -> Prim


-- | Pretty dictionary for primitives.
pretty_Prim: Pretty Prim
 = Pretty showPrim

show_Prim: Show Prim
 = Show   showPrim

showPrim    (pp: Prim): Text
 = case pp of
        PrimBool pb                     -> showPrimBool   pb
        PrimList pp                     -> showPrimList   pp
        PrimMatch pp                    -> showPrimMatch  pp
        PrimNat  pn                     -> showPrimNat    pn


readPrim    (tt: Text): Maybe Prim
 | Just pb      <- readPrimBool tt      = Just (PrimBool  pb)
 | Just pp      <- readPrimList tt      = Just (PrimList  pp)
 | Just pp      <- readPrimMatch tt     = Just (PrimMatch pp)
 | Just pn      <- readPrimNat  tt      = Just (PrimNat   pn)
 | otherwise                            = Nothing


