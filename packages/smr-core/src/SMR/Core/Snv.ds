
module SMR.Core.Snv
export
{       snvOfNamesArgs;
        snvGive; snvApply; snvBump
}
import SMR.Core.Exp
import SMR.Core.Ups
where


-- | Give an exp in a snv, but if it is directly a
--   a var or ref then also push it.
snvGive (snv1: Snv s p) (xx1: Exp s p): Exp s p
 = case xx1 of
        XRef (RMac n)   -> xx1
        XRef (RSym n)   -> xx1
        XVar name depth -> snvApply snv1 name depth
        XAbs ns21 x22   -> XAbs ns21 (snvGive (snvBump ns21 snv1) x22)
        _               -> XSnv snv1 xx1


-- | Apply a substitution to a variable with a given name and depth.
snvApply ((SSnv bs): Snv s p)
         (name: Name) (depth: Nat): Exp s p
 = case bs of
        Nil     
         -> XVar name depth

        Cons b'@(T2 (T2 name' depth') x') bs'
         |  name  == name'
         ,  depth == depth'
         -> x'

         |  name   == name'
         ,  depth  >  depth'
         -> XVar name (depth - 1)

         |  otherwise
         -> snvApply (SSnv bs') name depth


-- | Bump Snv due to pushing it under an abstraction with
--   the given named binders.
snvBump (ns:        List Name)
        ((SSnv ts): Snv s p): Snv s p
 = SSnv $ map (snvBump1 ns) ts
 where
        snvBump1
                (names: List Name)
                (b:     Tup2 (Tup2 Name Nat) (Exp s p))
                  :     Tup2 (Tup2 Name Nat) (Exp s p)
         | T2 (T2 name depth) x <- b
         = T2  (T2 name (depth + (if elem name names then 1 else 0)))
               (upsGive (UUps (map (\name' -> T2 (T2 name' 0) 1) names)) x)


-- | Build a substitution from lists of names and arguments.
snvOfNamesArgs (ns: List Name) (xs: List (Exp s p)): Snv s p
 = SSnv (zip (zip ns (replicate (length ns) 0)) xs)

