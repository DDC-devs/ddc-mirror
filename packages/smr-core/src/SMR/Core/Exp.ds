
module SMR.Core.Exp
export
{       show_Decl;      lookupDecl;
        show_Exp;       
        makeXApps;      takeXApps;
}
import Class.Show
import Data.Text
import Data.Tuple
where


-- Name -----------------------------------------------------------------------
-- | Represent names as text.
type Name = Text


-- Ref ------------------------------------------------------------------------
-- | Reference to an external thing.
data Ref (s p: Data) where
        -- Uninterpreted symbol.
        RSym    : s     -> Ref s p

        -- Primitive value.
        RPrm    : p     -> Ref s p

        -- Macro name.
        RMac    : Name  -> Ref s p

        -- Set name.
        RSet    : Name  -> Ref s p


show_Ref {Show s} {Show p}: Show (Ref s p)
 = Show $ λxx
 -> case xx of
        RMac    n       -> parens $ "RMac"      %% show n
        RSet    n       -> parens $ "RSet"      %% show n
        RSym    s       -> parens $ "RSym"      %% show s
        RPrm    p       -> parens $ "RPrm"      %% show p


-- Decl -----------------------------------------------------------------------
-- | Top-level declaration.
data Decl (s p: Data) where
        DTerm   : Name -> Exp s p -> Decl s p


-- | Lookup the body of a declaration with the given name from a list.
lookupDecl
        (n: Name)
        (decls: List (Decl s p))
        : Maybe (Exp s p)
 = case decls of
        Nil             -> Nothing

        Cons (DTerm n' x) ds
         | n == n'      -> Just x
         | otherwise    -> lookupDecl n ds


show_Decl {Show s} {Show p}: Show (Decl s p)
 =  Show $ λdd
 -> case dd of
        DTerm n x
         -> parens $ "DTerm"    %% show n %% show x


-- Exp ------------------------------------------------------------------------
-- | Generic expression language.

-- TODO: change to use recursive substitution instead of fixpoint.
-- [[x = e1; y = e2]] x =>  [[x = e1; y = y2]] e1
-- XRec.. can also be pushed down always.

data Exp (s p: Data) where
        -- Reference to an external thing.
        XRef    : Ref s p   -> Exp s p

        -- Functional core.
        XVar    : Name      -> Nat            -> Exp s p
        XApp    : Exp s p   -> List (Exp s p) -> Exp s p
        XAbs    : List Name -> Exp s p        -> Exp s p
        XFix    : List Name -> Exp s p        -> Exp s p

        -- Explicit lifting and substitution.
        XUps    : Ups       -> Exp s p        -> Exp s p
        XSnv    : Snv s p   -> Exp s p        -> Exp s p



show_Exp {Show s} {Show p}: Show (Exp s p)
 =  Show $ λxx
 -> case xx of
        XRef r          -> parens $ "XRef" %% show r
        XVar n  b       -> parens $ "XVar" %% show n  %% show b
        XApp xf xs      -> parens $ "XApp" %% show xf %% show xs
        XAbs ns x       -> parens $ "XAbs" %% show ns %% show x
        XFix ns x       -> parens $ "XFix" %% show ns %% show x
        XUps us x       -> parens $ "XUps" %% show us %% show x
        XSnv sb x       -> parens $ "XSnv" %% show sb %% show x


-- Ups ------------------------------------------------------------------------
-- | Lifting indicator maps name of variable and depth to level to lift.
data Ups where
        -- In the list the first element has priority.
        UUps    : List (Tup2 (Tup2 Name Nat) Nat) -> Ups


show_Ups: Show Ups
 =  Show $ λus
 -> case us of
        UUps ts -> parens $ "XUps" %% show ts


-- | Explicit substitution maps name and depth to expression.
data Snv (s p: Data) where
        SSnv    : List (Tup2 (Tup2 Name Nat) (Exp s p)) -> Snv s p


show_SSnv {Show s} {Show p}: Show (Snv s p)
 =  Show $ λsb
 -> case sb of
        SSnv ts -> parens $ "SSnv" %% show ts


-- Compounds ------------------------------------------------------------------
-- | Make an application of a function to the given list of arguments.
makeXApps (xFun: Exp s p) (xsArgs: List (Exp s p)): Exp s p
 = case xsArgs of
        Nil     -> xFun
        _       -> XApp xFun xsArgs


-- | Take an application of a function to a list of arguments.
takeXApps (xx: Exp s p): Maybe (Tup2 (Exp s p) (List (Exp s p)))
 = case xx of
        XApp x1@(XApp _ _) as2
         -> case takeXApps x1 of
                Just (T2 f1 as1) -> Just (T2 f1 (append as1 as2))
                Nothing          -> Nothing

        XApp x1 as2
          -> Just (T2 x1 as2)

        _ -> Nothing

