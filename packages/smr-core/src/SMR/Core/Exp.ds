
module SMR.Core.Exp
export
{       show_Decl;      lookupDecl;
        show_Exp;
        makeXAbs;
        makeXApps;      takeXApps
}
import Class.Show
import Data.Text
import Data.Tuple
where


-- Name, Ref ------------------------------------------------------------------
-- | Generic names for things.
type Name = Text

-- | Reference to some thing that is not a regular variable.
data Ref (s p: Data) where
        -- Uninterpreted symbol.
        RSym    : s     -> Ref s p

        -- Primitive value.
        RPrm    : p     -> Ref s p

        -- Macro name.
        RMac    : Name  -> Ref s p

        -- Set name.
        RSet    : Name  -> Ref s p


show_Ref {Show s} {Show p}: Show (Ref s p)
 = Show $ λxx
 -> case xx of
        RMac n  -> parens $ "RMac" %% show n
        RSet n  -> parens $ "RSet" %% show n
        RSym s  -> parens $ "RSym" %% show s
        RPrm p  -> parens $ "RPrm" %% show p


-- Decl -----------------------------------------------------------------------
-- | Top-level declaration.
data Decl (s p: Data) where
        DTerm   : Name -> Exp s p -> Decl s p


-- | Lookup the body of a declaration with the given name from a list.
lookupDecl
        (n:     Name)
        (decls: List (Decl s p))
        : Maybe (Exp s p)
 = case decls of
        Nil             -> Nothing

        Cons (DTerm n' x) ds
         | n == n'      -> Just x
         | otherwise    -> lookupDecl n ds


show_Decl {Show s} {Show p}: Show (Decl s p)
 =  Show $ λ(DTerm n x) -> parens $ "DTerm" %% show n %% show x


-- Exp ------------------------------------------------------------------------
-- | Generic expression language.
data Exp (s p: Data) where
        -- Reference to an external thing.
        XRef    : Ref s p   -> Exp s p

        -- Variable with a depth.
        XVar    : Name      -> Nat              -> Exp s p

        -- Application of a functional expression to its arguments.
        XApp    : Exp s p   -> List (Exp s p)   -> Exp s p

        -- Abstraction with a list of parameter names.
        XAbs    : List Name -> Exp s p          -> Exp s p

        -- Substitution train applied to an expression.
        -- The car at the head of the list is applied first.
        XSub    : List (Car s p) -> Exp s p     -> Exp s p

        -- Keyed expressions.
        XKey    : Key -> Exp s p                -> Exp s p


-- | Expression keys (super primitives).
data Key where
        KBox    : Key
        KRun    : Key


-- | A car on the substitution train.
data Car (s p: Data) where
        CSim    : Snv s p       -> Car s p
        CRec    : Snv s p       -> Car s p
        CUps    : Ups           -> Car s p


show_Exp {Show s} {Show p}: Show (Exp s p)
 =  Show $ λxx
 -> case xx of
        XRef r      -> parens $ "XRef" %% show r
        XVar n  b   -> parens $ "XVar" %% show n  %% show b
        XApp xf xs  -> parens $ "XApp" %% show xf %% show xs
        XAbs ns x   -> parens $ "XAbs" %% show ns %% show x
        XSub cs x   -> parens $ "XSub" %% show cs %% show x
        XKey k  x   -> parens $ "XKey" %% show k  %% show x


show_Key: Show Key
 =  Show $ λkk
 -> case kk of
        KBox        -> parens $ "KBox" %% show kk
        KRun        -> parens $ "KRun" %% show kk


show_Car {Show s} {Show p}: Show (Car s p)
 =  Show $ λxx
 -> case xx of
        CSim snv    -> parens $ "CSim" %% show snv
        CRec snv    -> parens $ "CRec" %% show snv
        CUps ups    -> parens $ "CUps" %% show ups


-- Snv ------------------------------------------------------------------------
-- | Explicit substitution maps name and depth to expression.
--   This is a simultaneous substitution, so later bindings
--   do not apply to the bodies of earlier ones.
data Snv (s p: Data) where
        SSnv    : List ((Name, Nat), Exp s p) -> Snv s p


show_Snv {Show s} {Show p}: Show (Snv s p)
 =  Show $ λ(SSnv ts) -> parens $ "SSnv" %% show ts


-- Ups ------------------------------------------------------------------------
-- | Lifting indicator maps name of variable and depth to level to lift.
data Ups where
        -- In the list the first element has priority.
        UUps    : List UpsBump -> Ups

type UpsBump
        = ((Name, Nat), Nat)


show_Ups: Show Ups
 =  Show $ λ(UUps ts) -> parens $ "UUps" %% show ts


-- Compounds ------------------------------------------------------------------
makeXAbs (ns: List Name) (xBody: Exp s p): Exp s p
 | null ns      = xBody
 | otherwise    = XAbs ns xBody


-- | Make an application of a function to the given list of arguments.
makeXApps (xFun: Exp s p) (xsArgs: List (Exp s p)): Exp s p
 = case xsArgs of
        Nil     -> xFun
        _       -> XApp xFun xsArgs


-- | Take an application of a function to a list of arguments.
takeXApps (xx: Exp s p): Maybe (Exp s p, List (Exp s p))
 = case xx of
        XApp x1@(XApp _ _) as2
         -> case takeXApps x1 of
                Just (f1, as1) -> Just (f1, append as1 as2)
                Nothing        -> Nothing

        XApp x1 as2
          -> Just (x1, as2)

        _ -> Nothing

