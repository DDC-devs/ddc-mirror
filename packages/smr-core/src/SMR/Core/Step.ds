
module SMR.Core.Step
export step
import SMR.Core.Push
import SMR.Core.Train
import SMR.Core.Exp
where

-------------------------------------------------------------------------------
-- | Evaluation strength.
data StepStrength where
        StepStrength
         :  Bool                    -- ^ Reduce under lambdas.
         -> Bool                    -- ^ Reduce args when head is not an abs.
         -> StepStrength


-- | Evaluation context.
data StepContext (s p: Data) where
        StepContext
         :  List (p, PrimEval s p)  -- ^ Primitive operator evaluators.
         -> List (Decl s p)         -- ^ Top-level declarations.
         -> StepContext s p


-- | Describe the result of an evaluation.
data Result where
        ResultDone  : Result
        ResultError : Text -> Result


-------------------------------------------------------------------------------
-- | Single step reduction.
step    {Eq p} {Show p}
        (str: StepStrength)       -- ^ Evaluation Strength.
        (ctx: StepContext s p)    -- ^ Evaluation Context.
        (xx:  Exp s p)            -- ^ Expression to evaluate.
        :     Either Result (Exp s p)
 = case xx of
        -- Evaluate multiple values left to right.
        XRet xs
         -> case stepFirst str ctx xs of
                Left  res       -> Left res
                Right xs'       -> Right $ makeXRet xs'

        -- Reference
        XRef (RMac n)
         | StepContext _ decls  <- ctx
         -> case lookupDecl n decls of
                Nothing -> Left ResultDone
                Just x  -> Right x

        XRef _          -> Left ResultDone

        -- Variable
        XVar _ _        -> Left ResultDone

        -- Abstraction
        XAbs ns1 x2
         -- Reduce the body of the abstraction.
         |  StepStrength True _     <- str
         ,  Right x2'               <- step str ctx x2
         -> Right $ XAbs ns1 x2'

         -- Treat abstractions as values.
         |  otherwise   -> Left ResultDone

        -- Application
        XApp x1 x2
         -- Application of a primitive operator.
         | Just (XRef (RPrm prim), xsArgs) <- takeXApps xx
         , StepContext esPrim _            <- ctx
         -> case lookup prim esPrim of
                Nothing
                 -> Left $ ResultError $ "Unknown primitive" %% show prim

                Just primEval
                 -> stepPrim ctx primEval xsArgs

         -- Application of some function abstraction.
         |  Just (x1, xs2) <- takeXApps xx
         -> case step (StepStrength False False) ctx x1 of
                -- Functional expression makes progress.
                Right x1'
                 -> Right $ makeXApps x1' xs2

                -- Functional expression failed.
                Left err@(ResultError _)
                 -> Left err

                -- Functional expression is done.
                Left ResultDone

                 -- Application of seq superprim.
                 --  If the right is an abs directly then just build the subst.
                 --  without going via the intermediate application step.
                 |  XKey KSeq x11  <- x1
                 ,  Cons x2' xs2'  <- xs2
                 ,  XAbs ns11 x12  <- fromMaybe x2' (push x2')
                 ,  Cons n1  ns11' <- ns11
                 -> do  snv     = snvOfNamesArgs (Cons n1 Nil) (Cons x11 Nil)
                        car     = CSim snv
                        cars    = Cons car Nil
                        Right $ makeXApps (trainApply cars $ makeXAbs ns11' x12) xs2'

                 -- Application of a seq superprim to something
                 --   that isn't yet an abstraction.
                 |  XKey KSeq x11 <- x1
                 -> Right $ XApp x2 (XRet (flattenExp x11))

                 -- The function is a abstraction, so apply it.
                 |  XAbs ns11  x12      <- x1
                 -> stepAppAbs str ctx ns11 x12 xs2 (length ns11) (length xs2)

                 -- Reduce arguments of applications.
                 --  TODO: don't introduce XRet at top level if there wasn't
                 --  one there already. If source prog does not have multi
                 --  arg/return then eval should not introduce it.
                 |  StepStrength _ True <- str
                 -> case step str ctx x1 of
                        Right x1'
                         -> Right $ XApp x1' (makeXRet xs2)

                        Left err@(ResultError _)
                         -> Left err

                        Left ResultDone
                         -> case stepFirst (StepStrength True True) ctx xs2 of
                                Right xs2' -> Right (XApp x1 (makeXRet xs2'))
                                Left  r    -> Left r

                 |  otherwise
                 -> Left ResultDone

        -- Substitution train.
        XSub _ _
         -> case push xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'

        -- Boxed expressions are already normal forms.
        XKey KBox _       -> Left ResultDone

        -- Run a boxed expression.
        XKey KRun x1
         -> case step (StepStrength False False) ctx x1 of
                -- Body makes progress.
                Right x1'
                 -> Right (XKey KRun x1')

                -- Body expression failed.
                Left  err@(ResultError _)
                 -> Left err

                -- If the body expression is a box then unwrap it,
                -- otherwise just return the value as-is.
                Left  ResultDone
                 -> case x1 of
                        XKey KBox x11   -> Right x11
                        _               -> Right x1


        -- Step the body of a seq expression.
        XKey KSeq x
         -> case stepFirst str ctx (Cons x Nil) of
                Right xs' -> Right $ XKey KSeq (makeXRet xs')
                Left err  -> Left err


-------------------------------------------------------------------------------
-- | Step the first available expression in a list.
--   This also flattens them out, so at the top level of the result
--   we won't have nested XRets.
stepFirst
        {Eq p} {Show p}
        (str: StepStrength)             -- ^ Evaluation Strength.
        (ctx: StepContext s p)          -- ^ Evaluation Context.
        (xx:  List (Exp s p))           -- ^ List of expressions to step.
        :     Either Result (List (Exp s p))
 = case xx of
        Nil
         -> Left ResultDone

        Cons x xs
         -> case step str ctx x of
                Left err@(ResultError _)
                 -> Left err

                Left ResultDone
                 |  XRet xs'  <- x
                 -> case stepFirst str ctx xs of
                        Left r     -> Left r
                        Right xs'' -> Right $ append xs xs''

                 |  otherwise
                 -> case stepFirst str ctx xs of
                        Left  r   -> Left r
                        Right xs' -> Right $ Cons x xs'

                Right x'          -> Right $ Cons x' xs


-------------------------------------------------------------------------------
-- | Step an application of a function abstraction to some arguments.
stepAppAbs
        (str:   StepStrength)           -- ^ Evaluation strength.
        (ctx:   StepContext s p)        -- ^ Evaluation context.
        (ns11:  List Name)              -- ^ Names of parameters.
        (x12:   Exp s p)                -- ^ Body  of abstraction.
        (xs2:   List (Exp s p))         -- ^ Arguments to abstraction.
        (arity: Nat)                    -- ^ Length of parameters list.
        (args:  Nat)                    -- ^ Length of arguments list.
        :       Either Result (Exp s p)

 -- Saturated application.
 | args == arity
 = do   snv         = snvOfNamesArgs ns11 xs2
        Right $ snvApply False snv x12

 -- Under application.
 | args < arity
 = do   ns11_sat    = take args ns11
        ns11_remain = drop args ns11
        snv         = snvOfNamesArgs ns11_sat xs2
        Right $ snvApply False snv $ XAbs ns11_remain $ x12

 -- Over application.
 | otherwise
 = do   xs2_sat     = take arity xs2
        xs2_remain  = drop arity xs2
        snv         = snvOfNamesArgs ns11 xs2_sat
        Right $ XApp  (snvApply False snv x12) (makeXRet xs2_remain)


-------------------------------------------------------------------------------
-- | Step an application of a primitive operator to some arguments.
stepPrim
        {Eq p} {Show p}
        (ctx:   StepContext s p)    -- ^ Context of evaluation.
        (pe:    PrimEval s p)       -- ^ Evaluator for primitive operator.
        (xsArg: List (Exp s p))     -- ^ Arguments the operator is applied to.
        :       Either Result (Exp s p)
 | PrimEval prim desc csArg eval <- pe
 = evalArgs csArg xsArg Nil
 where
        -- TODO: disaster renaming xsArgDone to xsArgsDone (or vis versa)
        --       for some clauses but not others causes the pattern desugarer
        --       to forget the name of the variables.

        -- Evaluation of arguments is complete.
        evalArgs Nil Nil xsArgsDone
         = case eval (reverse xsArgsDone) of
                Just xResult
                 -> Right xResult

                Nothing
                 -> Left $ ResultError
                         $ "Evaluation of primitive " %% show prim %% "failed."

        -- We have more args than the primitive will accept.
        evalArgs Nil xsArgsRemain xsArgsDone
         = case eval (reverse xsArgsDone) of
                Just xResult
                 -> Right $ XApp xResult (makeXRet xsArgsRemain)

                Nothing
                 -> Left $ ResultError
                         $ "Evaluation of primitive " %% show prim %% "failed."

        -- Evaluate the next argument if neeeded.
        evalArgs (Cons cArg' csArg') (Cons xArg' xsArg') xsArgsDone
         -- Primitive does not demand a value for this arg.
         | Exp  <- cArg'
         = evalArgs csArg' xsArg' (Cons xArg' xsArgsDone)

         -- Primitive demands a value for this arg.
         = case step (StepStrength False False) ctx xArg' of
                Left err@(ResultError _)
                 -> Left err

                Left ResultDone
                 -> evalArgs csArg' xsArg' (Cons xArg' xsArgsDone)

                Right xArg''
                 -> Right $ makeXApps (XRef (RPrm (nameOfPrimEval pe)))
                          $ append (reverse xsArgsDone) (Cons xArg'' xsArg')

        -- We have less args than the prim will accept,
        -- so leave the application as it is.
        evalArgs _ Nil xsArgsDone
         = Left ResultDone
