
module SMR.Core.Step
export 
{       step
}
import SMR.Core.Exp
import SMR.Core.Meta
where


data Result where
        ResultDone  : Result
        ResultError : Result


-- | Single step reduction.
step    (prim:  p -> List (Exp s p) -> Maybe (Exp s p))
        (decls: List (Decl s p))
        (xx:    Exp s p)
        : Either Result (Exp s p) 
 = case xx of
        -- Reference
        XRef (RMac n)
         -> case lookupDecl n decls of
                Nothing -> Left ResultDone
                Just x  -> Right x

        XRef _
         -> Left ResultDone

        -- Variable
        XVar _ _        
         -> Left ResultDone

        -- Abstraction
        XAbs ns1 x2     
         |  Right x2'   <- step prim decls x2
         -> Right $ XAbs ns1 x2'

         |  otherwise
         -> Left ResultDone

        -- Fixpoint
        XFix ns1 x2
         |  Right x2'   <- step prim decls x2
         -> Right $ XFix ns1 x2'

         |  otherwise
         -> Left ResultDone

        -- Application
        XApp x1 xs2
         -> case step prim decls x1 of
                Right x1'
                 -> Right $ XApp x1' xs2

                Left ResultError
                 -> Left ResultError

                Left ResultDone
                 -- Saturated application.
                 |  XAbs ns11 x12 <- x1
                 ,  arity         <- length ns11
                 ,  length xs2  == arity
                 -> let snv     = SSnv (zip (zip ns11 (replicate arity 0)) xs2)
                    in  Right $ XSnv snv x12

                 -- Under application.
                 |  XAbs ns11 x12 <- x1
                 ,  arity         <- length ns11
                 ,  args          <- length xs2
                 ,  args < arity
                 -> do  ns11_sat        = take arity ns11
                        ns11_remain     = drop arity ns11
                        Right $ XAbs ns11_remain (XApp (XAbs ns11_sat x12) xs2)

                 -- Over application.
                 |  XAbs ns11 x12 <- x1
                 ,  arity         <- length ns11
                 ,  args          <- length xs2
                 ,  args > arity
                 -> do  xs2_sat         = take arity xs2
                        xs2_remain      = drop arity xs2
                        Right $ XApp (XApp (XAbs ns11 x12) xs2_sat) xs2_remain

                 | otherwise
                 -> case stepFirst prim decls xs2 of
                        Right xs2'      -> Right (XApp x1 xs2')
                        Left  r         -> Left r

        XUps _ _
         -> case push decls xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'

        XSnv _ _
         -> case push decls xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'


-- | Push down substitutions to reveal the head constructor.
push    (decls: List (Decl s p))
        (xx: Exp s p)
        : Maybe (Exp s p)
 = push1 decls xx


-- | Push down substitutions to reveal the head constructor.
push1   (decls: List (Decl s p))
        (xx: Exp s p)
        : Maybe (Exp s p)
 = case xx of
        XRef _          -> Nothing
        XVar _ _        -> Nothing
        XAbs _ _        -> Nothing
        XFix _ _        -> Nothing
        XApp _ _        -> Nothing

        -- Substitution.
        -- TODO: when subst into subst in debruijn we lower indices
        -- check that this is also happening here.
        XSnv snv1 x2
         -> case x2 of
                -- Unfold macro under a substitution.
                -- Macro bodies  are closed, so we can drop the substitution.
                XRef (RMac n)   -> lookupDecl n decls

                -- Reference to some other thing.
                XRef _          -> Just x2

                -- Lookup element in snv.
                XVar n d
                  | SSnv ts1     <- snv1
                  -> case lookup (T2 n d) ts1 of
                        Nothing -> Just x2
                        Just e  -> Just e

                -- Push snv into both sides of an application.
                XApp x21 xs22
                  -> Just $ XApp (XSnv snv1 x21) (map (XSnv snv1) xs22)

                -- Push snv under abstractions.
                XAbs ns21 x22
                  -> Just $ XAbs ns21 (XSnv (snvBump ns21 snv1) x22)

                XFix ns21 x22
                  -> Just $ XFix ns21 (XSnv (snvBump ns21 snv1) x22)

                -- Push down substitutions under substitutions
                -- TODO: combine these.
                XSnv _ _
                 -> case push1 decls x2 of
                        Just x2' -> Just $ XSnv snv1 x2'
                        Nothing  -> Nothing

                -- Push down liftings under substitutions.
                XUps _ _
                  -> case push1 decls x2 of
                        Just x2' -> Just $ XSnv snv1 x2'
                        Nothing  -> Nothing

                _ -> Nothing


        -- Lifting.
        XUps ups1 x2
         -> case x2 of
                -- Unfold macro under a lifting.
                -- Macro bodies are closed, so we can drop the lifting.
                XRef (RMac n)   -> lookupDecl n decls

                -- Reference to some other thing.
                XRef _          -> Just x2

                -- Lookup element in lift table.
                XVar n d
                  | UUps ts1     <- ups1
                  -> case lookup (T2 n d) ts1 of
                         Nothing -> Just x2
                         Just b  -> Just (XVar n (d + b))

                -- Push ups into both sides of an application.
                XApp x21 xs22
                  -> Just $ XApp (XUps ups1 x21) (map (XUps ups1) xs22)

                -- Push ups under abstractions.
                XAbs ns21 x22
                  -> Just $ XAbs ns21 (XUps (upsBump ns21 ups1) x22)

                -- Push down substitutions under substitutions
                -- TODO: combine these.
                XSnv _ _
                 -> case push1 decls x2 of
                        Just x2' -> Just $ XUps ups1 x2'
                        Nothing  -> Nothing

                -- Combine liftings.
                XUps ups2 x22
                  -> Just $ XUps (upsAppend ups2 ups1) x22

                _ -> Nothing

        _ -> Nothing


stepFirst 
        (prim:  p -> List (Exp s p) -> Maybe (Exp s p))
        (decls: List (Decl s p))
        (xx:    List (Exp s p))
        : Either Result (List (Exp s p))
 = case xx of
        Nil
         -> Left ResultDone

        Cons x xs
         -> case step prim decls x of
                Left ResultDone 
                 -> case stepFirst prim decls xs of
                        Left  r         -> Left r
                        Right xs'       -> Right $ Cons x xs'

                Right x'
                 -> Right $ Cons x' xs


-- Ups ------------------------------------------------------------------------
-- | Bump ups (substitution lifting) due to pushing it
--   under an absraction with the given named binders.
upsBump (ns: List Name) (up: Ups): Ups
 = case up of
        UUps ts -> UUps $ map (upsBump1 ns) ts

upsBump1 (ns: List Name)
         (l:  Tup2 (Tup2 Name Nat) Nat)
           :  Tup2 (Tup2 Name Nat) Nat
 = case l of
        T2 (T2 n d) inc
         | elem n ns    -> T2 (T2 n (d + 1)) inc
         | otherwise    -> l


-- | Append two ups.
upsAppend : Ups -> Ups -> Ups
upsAppend (UUps ts1) (UUps ts2)
 = UUps (append ts1 ts2)


-- Snv ------------------------------------------------------------------------
-- | Bump snv (substitution environment) due to pushing it
--   under an abstraction with the given named binders.
snvBump (ns: List Name) (sn: Snv s p): Snv s p
 = case sn of
        SSnv ts -> SSnv $ map (snvBump1 ns) ts


-- TODO: also need to inc the depth when pushing under abs of same name.
snvBump1
        (ns: List Name)
        (b:  Tup2 (Tup2 Name Nat) (Exp s p))
          :  Tup2 (Tup2 Name Nat) (Exp s p)
 = case b of
        T2 (T2 n d) x
         -> T2 (T2 n d) (XUps (UUps (map (\n' -> T2 (T2 n' 0) 1) ns)) x)

