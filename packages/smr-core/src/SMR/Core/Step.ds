
module SMR.Core.Step
export 
{       step; push;
}
import SMR.Core.Exp
import SMR.Core.Meta
import SMR.Core.Ups
import SMR.Core.Snv
where

-------------------------------------------------------------------------------
data Result where
        ResultDone  : Result
        ResultError : Result


data StepStrength where
        StepStrength
         :  Bool                                -- ^ Reduce under lambdas.
         -> StepStrength


data StepContext (s p: Data) where
        StepContext
         :  (p -> List (Exp s p) -> Maybe (Exp s p))    -- ^ Prim function.
         -> (List (Decl s p))                           -- ^ Top-level decls.
         -> StepContext s p


-------------------------------------------------------------------------------
-- | Single step reduction.
--   TODO: add config to control what is done,
--   eg cbv or normal order, whether to unfold macros.
step    (str:   StepStrength)
        (ctx:   StepContext s p)
        (xx:    Exp s p)
        : Either Result (Exp s p) 
 = case xx of
        -- Reference
        XRef (RMac n)
         | StepContext _ decls  <- ctx
         -> case lookupDecl n decls of
                Nothing -> Left ResultDone
                Just x  -> Right x

        XRef _          -> Left ResultDone

        -- Variable
        XVar _ _        -> Left ResultDone

        -- Abstraction
        XAbs ns1 x2     
         |  StepStrength True   <- str
         ,  Right x2'           <- step str ctx x2
         -> Right $ XAbs ns1 x2'

         |  otherwise   -> Left ResultDone

        -- Fixpoint
        XFix ns1 x2
         |  Right x2'   <- step str ctx x2
         -> Right $ XFix ns1 x2'

         |  otherwise   -> Left ResultDone

        -- Application
        XApp x1 xs2
         -> case step (StepStrength False) ctx x1 of
                Right x1'
                 -> Right $ XApp x1' xs2

                Left ResultError
                 -> Left ResultError

                Left ResultDone
                 |  XAbs ns11  x12      <- x1  
                 -> stepAppAbs str ctx
                        ns11 x12 xs2
                        (length ns11) (length xs2)

                 |  otherwise
                 -> case step str ctx x1 of
                        Right x1'
                         -> Right $ XApp x1' xs2

                        Left ResultError 
                         -> Left ResultError

                        Left ResultDone
                         -> case stepFirst str ctx xs2 of
                                Right xs2' -> Right (XApp x1 xs2')
                                Left  r    -> Left r

        XUps _ _
         -> case push xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'

        XSnv _ _
         -> case push xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'


-- | Step an application of a function abstraction to some arguments.
stepAppAbs
        (str:   StepStrength)
        (ctx:   StepContext s p)
        (ns11:  List Name)              -- ^ Names of parameters.
        (x12:   Exp s p)                -- ^ Body of abstraction.
        (xs2:   List (Exp s p))         -- ^ Arguments to abstraction.
        (arity: Nat)                    -- ^ Length of parameters list.
        (args:  Nat)                    -- ^ Length of arguments list.
        : Either Result (Exp s p) 

 -- Saturated application.
 | args == arity
 = do   snv             = snvOfNamesArgs ns11 xs2
        Right   $ snvGive snv x12

 -- Under application.
 | args < arity
 = do   ns11_sat        = take args ns11
        ns11_remain     = drop args ns11
        snv             = snvOfNamesArgs ns11_sat xs2
        Right   $ snvGive snv $ XAbs ns11_remain $ x12

 -- Over application.
 | otherwise
 = do   xs2_sat         = take arity xs2
        xs2_remain      = drop arity xs2
        snv             = snvOfNamesArgs ns11 xs2_sat
        Right   $ XApp  (snvGive snv x12) xs2_remain


-------------------------------------------------------------------------------
-- | Step the first available expression in a list.
stepFirst 
        (str:   StepStrength)
        (ctx:   StepContext s p)
        (xx:    List (Exp s p))
        : Either Result (List (Exp s p))
 = case xx of
        Nil
         -> Left ResultDone

        Cons x xs
         -> case step str ctx x of
                Left ResultDone 
                 -> case stepFirst str ctx xs of
                        Left  r         -> Left r
                        Right xs'       -> Right $ Cons x xs'

                Right x'
                 -> Right $ Cons x' xs


-------------------------------------------------------------------------------
-- | Push down substitutions to reveal the head constructor.
push    (xx:    Exp s p): Maybe (Exp s p)
 = push1 xx


-- | Push down substitutions to reveal the head constructor.
push1   (xx:    Exp s p): Maybe (Exp s p)
 = case xx of
        XRef _          -> Nothing
        XVar _ _        -> Nothing
        XAbs _ _        -> Nothing
        XFix _ _        -> Nothing
        XApp _ _        -> Nothing
        XSnv snv1 x2    -> pushSnv1 snv1 x2
        XUps ups1 x2    -> pushUps1 ups1 x2


-- | Push down a substitution.
--   TODO: when subst into subst in debruijn we lower indices
--   check that this is also happening here.
pushSnv1
        (snv1:  Snv s p)
        (x2:    Exp s p)
        : Maybe (Exp s p)
 = case x2 of
        -- Unfold macro under a substitution.
        -- Macro and symbol bodies are closed, so we can drop the substitution.
        XRef (RMac n)   -> Just x2
        XRef (RSym n)   -> Just x2

        -- Reference to some other thing.
        XRef _          -> Nothing

        -- Apply the substitution to the variable.
        XVar name depth
          -> Just $ snvApply snv1 name depth

        -- Push snv into both sides of an application.
        XApp x21 xs22
          -> Just $ XApp (snvGive snv1 x21) (map (snvGive snv1) xs22)

        -- Push snv under abstractions.
        XAbs ns21 x22
          -> Just $ XAbs ns21 (snvGive (snvBump ns21 snv1) x22)

        XFix ns21 x22
          -> Just $ XFix ns21 (snvGive (snvBump ns21 snv1) x22)

        -- Push down substitutions under substitutions
        -- TODO: combine these.
        XSnv _ x22
         -> case push1 x2 of
                Just x2' -> Just $ snvGive snv1 x2'
                Nothing  -> Nothing

        -- Push down liftings under substitutions.
        XUps _ _
         -> case push1 x2 of
                Just x2' -> Just $ snvGive snv1 x2'
                Nothing  -> Nothing


-- | Push down a lifting.
pushUps1
        (ups1:  Ups)
        (x2:    Exp  s p)
        : Maybe (Exp s p)
 = case x2 of
        -- Macro and symbols are closed, so we can drop the lifting.
        XRef (RMac n)   -> Just x2
        XRef (RSym n)   -> Just x2

        -- Reference to some other thing.
        XRef _          -> Nothing

        -- Lookup element in lift table.
        XVar name ix
          -> Just $ upsApply ups1 name ix

        -- Push ups into both sides of an application.
        XApp x21 xs22
          -> Just $ XApp (upsGive ups1 x21) (map (upsGive ups1) xs22)

        -- Push ups under abstractions.
        XAbs ns21 x22
          -> Just $ XAbs ns21 (upsGive (upsBump ns21 ups1) x22)

        -- TODO: Apply lifting to substitution, then lift substitued thing.
        -- On the way down the lifting collect under the substitutions.
        XSnv _ _
         -> case push1 x2 of
                Just x2' -> Just $ upsGive ups1 x2'
                Nothing  -> Nothing

        -- Combine liftings.
        XUps ups2 x22
          -> case push1 x2 of
                Just x2' -> Just $ upsGive ups1 x2'
                Nothing  -> Nothing

        -- TODO: fix combine and reinstate.
--          Just $ upsGive (upsCombine ups1 ups2) x22

