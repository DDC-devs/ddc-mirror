
module SMR.Core.Step
export 
{       step; push;
}
import SMR.Core.Train
import SMR.Core.Meta
import SMR.Core.Exp
where

---------------------------------------------------------------------------------------------------
-- | Evaluation strength.
data StepStrength where
        StepStrength
         :  Bool                        -- ^ Reduce under lambdas.
         -> StepStrength


-- | Evaluation context.
data StepContext (s p: Data) where
        StepContext
         :  (p -> List (Exp s p) -> Maybe (Exp s p))    
                                        -- ^ Prim function.
         -> (List (Decl s p))           -- ^ Top-level decls.
         -> StepContext s p


-- | Describe the result of an evaluation.
data Result where
        ResultDone  : Result
        ResultError : Result


---------------------------------------------------------------------------------------------------
-- | Single step reduction.
step    (str:   StepStrength)
        (ctx:   StepContext s p)
        (xx:    Exp s p)
        :       Either Result (Exp s p) 
 = case xx of
        -- Reference
        XRef (RMac n)
         | StepContext _ decls  <- ctx
         -> case lookupDecl n decls of
                Nothing -> Left ResultDone
                Just x  -> Right x

        XRef _          -> Left ResultDone

        -- Variable
        XVar _ _        -> Left ResultDone

        -- Abstraction
        XAbs ns1 x2     
         -- Reduce the body of the abstraction.
         |  StepStrength True   <- str
         ,  Right x2'           <- step str ctx x2
         -> Right $ XAbs ns1 x2'

         -- Treat abstractions as values.
         |  otherwise   -> Left ResultDone

        -- Application
        XApp x1 xs2
         -> case step (StepStrength False) ctx x1 of
                -- Functional expression makes progress.
                Right x1'               -> Right $ XApp x1' xs2

                -- Functional expression failed.
                Left ResultError        -> Left ResultError

                -- Functional expression is done.
                Left ResultDone
                 -- The function is a abstraction, so apply it.
                 |  XAbs ns11  x12      <- x1  
                 -> stepAppAbs str ctx ns11 x12 xs2 (length ns11) (length xs2)

                 -- Reduce arguments of applications.
                 |  otherwise
                 -> case step str ctx x1 of
                        Right x1'          -> Right $ XApp x1' xs2

                        Left ResultError   -> Left ResultError

                        Left ResultDone
                         -> case stepFirst str ctx xs2 of
                                Right xs2' -> Right (XApp x1 xs2')
                                Left  r    -> Left r

        -- Substitution train
        XSub _ _
         -> case push xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'


-- | Step an application of a function abstraction to some arguments.
stepAppAbs
        (str:   StepStrength)           -- ^ Evaluation strength.
        (ctx:   StepContext s p)        -- ^ Evaluation context.
        (ns11:  List Name)              -- ^ Names of parameters.
        (x12:   Exp s p)                -- ^ Body  of abstraction.
        (xs2:   List (Exp s p))         -- ^ Arguments to abstraction.
        (arity: Nat)                    -- ^ Length of parameters list.
        (args:  Nat)                    -- ^ Length of arguments list.
        :       Either Result (Exp s p) 

 -- Saturated application.
 | args == arity
 = do   snv             = snvOfNamesArgs ns11 xs2
        Right   $ simWrap snv x12

 -- Under application.
 | args < arity
 = do   ns11_sat        = take args ns11
        ns11_remain     = drop args ns11
        snv             = snvOfNamesArgs ns11_sat xs2
        Right   $ simWrap snv $ XAbs ns11_remain $ x12

 -- Over application.
 | otherwise
 = do   xs2_sat         = take arity xs2
        xs2_remain      = drop arity xs2
        snv             = snvOfNamesArgs ns11 xs2_sat
        Right   $ XApp  (simWrap snv x12) xs2_remain


-- | Step the first available expression in a list.
stepFirst 
        (str:   StepStrength)           -- ^ Evaluation Strength.
        (ctx:   StepContext s p)        -- ^ Evaluation Context.
        (xx:    List (Exp s p))         -- ^ List of expressions to step.
        :       Either Result (List (Exp s p))
 = case xx of
        Nil
         -> Left ResultDone

        Cons x xs
         -> case step str ctx x of
                Left ResultDone 
                 -> case stepFirst str ctx xs of
                        Left  r   -> Left r
                        Right xs' -> Right $ Cons x xs'

                Right x'          -> Right $ Cons x' xs


---------------------------------------------------------------------------------------------------
-- | Push down any outermost substitution train to reveal the head constructor.
push    (xx: Exp s p): Maybe (Exp s p)
 = case xx of
        XRef _          -> Nothing
        XVar _ _        -> Nothing
        XAbs _ _        -> Nothing
        XApp _ _        -> Nothing
        XSub cs2 x2     -> pushTrain cs2 x2


-- | Push a substitution train down into an expression to reveal the head constructor.
pushTrain
        (cs1:   List (Car s p))
        (x2:    Exp s p)
        :       Maybe (Exp s p)
 = case x2 of
        -- Unfold macro under a substitution.
        -- Macro and symbol bodies are closed, so we can drop the substitution.
        XRef (RMac n)   -> Just x2
        XRef (RSym n)   -> Just x2
        XRef (RPrm n)   -> Just x2

        -- Reference to some other thing.
        XRef _          -> Nothing

        -- Apply the train to a variable.
        XVar name depth
         -> Just $ trainApply cs1 name depth

        -- Push train into both sides of an application.
        XApp x21 xs22
         -> Just $ XApp (trainWrap cs1 x21) (map (trainWrap cs1) xs22)

        -- Push train under abstraction.
        XAbs ns21 x22
         -> Just $ XAbs ns21 (trainWrap (trainBump ns21 cs1) x22)

        -- Combine trains.
        XSub cs2 x22
         -> Just $ trainWrap (append cs2 cs1) x22

