
module SMR.Core.Step
export
{       step; push;
}
import SMR.Core.Train
import SMR.Core.Exp
where

-------------------------------------------------------------------------------
-- | Evaluation strength.
data StepStrength where
        StepStrength
         :  Bool                    -- ^ Reduce under lambdas.
         -> Bool                    -- ^ Reduce args when head is not an abs.
         -> StepStrength


-- | Evaluation context.
data StepContext (s p: Data) where
        StepContext
         :  List (p, PrimEval s p)  -- ^ Primitive operator evaluators.
         -> List (Decl s p)         -- ^ Top-level declarations.
         -> StepContext s p


-- | Describe the result of an evaluation.
data Result where
        ResultDone  : Result
        ResultError : Text -> Result


-------------------------------------------------------------------------------
-- | Single step reduction.
step    {Eq p} {Show p}
        (str: StepStrength)       -- ^ Evaluation Strength.
        (ctx: StepContext s p)    -- ^ Evaluation Context.
        (xx:  Exp s p)            -- ^ Expression to evaluate.
        :     Either Result (Exp s p)
 = case xx of
        -- Reference
        XRef (RMac n)
         | StepContext _ decls  <- ctx
         -> case lookupDecl n decls of
                Nothing -> Left ResultDone
                Just x  -> Right x

        XRef _          -> Left ResultDone

        -- Variable
        XVar _ _        -> Left ResultDone

        -- Abstraction
        XAbs ns1 x2
         -- Reduce the body of the abstraction.
         |  StepStrength True _     <- str
         ,  Right x2'               <- step str ctx x2
         -> Right $ XAbs ns1 x2'

         -- Treat abstractions as values.
         |  otherwise   -> Left ResultDone

        -- Application
        XApp x1 xs2
         -- Application of a primitive operator.
         | Just (XRef (RPrm prim), xsArgs)  <- takeXApps xx
         , StepContext esPrim _                 <- ctx
         -> case lookup prim esPrim of
                Nothing
                 -> Left $ ResultError $ "Unknown primitive" %% show prim

                Just primEval
                 -> stepPrim ctx primEval xsArgs

         -- Application of some function abstraction.
         | otherwise
         -> case step (StepStrength False False) ctx x1 of
                -- Functional expression makes progress.
                Right x1'
                 -> Right $ XApp x1' xs2

                -- Functional expression failed.
                Left err@(ResultError _)
                 -> Left err

                -- Functional expression is done.
                Left ResultDone
                 -- The function is a abstraction, so apply it.
                 |  XAbs ns11  x12      <- x1
                 -> stepAppAbs str ctx ns11 x12 xs2 (length ns11) (length xs2)

                 -- Reduce arguments of applications.
                 |  StepStrength _ True <- str
                 -> case step str ctx x1 of
                        Right x1'
                         -> Right $ XApp x1' xs2

                        Left err@(ResultError _)
                         -> Left err

                        Left ResultDone
                         -> case stepFirst (StepStrength True True) ctx xs2 of
                                Right xs2' -> Right (XApp x1 xs2')
                                Left  r    -> Left r

                 |  otherwise
                 -> Left ResultDone

        -- Substitution train.
        XSub _ _
         -> case push xx of
                Nothing  -> Left ResultDone
                Just xx' -> Right xx'


-------------------------------------------------------------------------------
-- | Step the first available expression in a list.
stepFirst
        {Eq p} {Show p}
        (str: StepStrength)             -- ^ Evaluation Strength.
        (ctx: StepContext s p)          -- ^ Evaluation Context.
        (xx:  List (Exp s p))           -- ^ List of expressions to step.
        :     Either Result (List (Exp s p))
 = case xx of
        Nil
         -> Left ResultDone

        Cons x xs
         -> case step str ctx x of
                Left err@(ResultError _)
                 -> Left err

                Left ResultDone
                 -> case stepFirst str ctx xs of
                        Left  r   -> Left r
                        Right xs' -> Right $ Cons x xs'

                Right x'          -> Right $ Cons x' xs


-------------------------------------------------------------------------------
-- | Step an application of a function abstraction to some arguments.
stepAppAbs
        (str:   StepStrength)           -- ^ Evaluation strength.
        (ctx:   StepContext s p)        -- ^ Evaluation context.
        (ns11:  List Name)              -- ^ Names of parameters.
        (x12:   Exp s p)                -- ^ Body  of abstraction.
        (xs2:   List (Exp s p))         -- ^ Arguments to abstraction.
        (arity: Nat)                    -- ^ Length of parameters list.
        (args:  Nat)                    -- ^ Length of arguments list.
        :       Either Result (Exp s p)

 -- Saturated application.
 | args == arity
 = do   snv         = snvOfNamesArgs ns11 xs2
        Right $ snvApply False snv x12

 -- Under application.
 | args < arity
 = do   ns11_sat    = take args ns11
        ns11_remain = drop args ns11
        snv         = snvOfNamesArgs ns11_sat xs2
        Right $ snvApply False snv $ XAbs ns11_remain $ x12

 -- Over application.
 | otherwise
 = do   xs2_sat     = take arity xs2
        xs2_remain  = drop arity xs2
        snv         = snvOfNamesArgs ns11 xs2_sat
        Right $ XApp  (snvApply False snv x12) xs2_remain


-------------------------------------------------------------------------------
-- | Step an application of a primitive operator to some arguments.
stepPrim
        {Eq p} {Show p}
        (ctx:   StepContext s p)    -- ^ Context of evaluation.
        (pe:    PrimEval s p)       -- ^ Evaluator for primitive operator.
        (xsArg: List (Exp s p))     -- ^ Arguments the operator is applied to.
        :       Either Result (Exp s p)
 | PrimEval prim desc csArg eval <- pe
 = evalArgs csArg xsArg Nil
 where
        -- Evaluation of arguments is complete.
        evalArgs Nil Nil xsArgsDone
         = case eval (reverse xsArgsDone) of
                Just xResult
                 -> Right xResult

                Nothing
                 -> Left $ ResultError
                         $ "Evaluation of primitive " %% show prim %% "failed."

        -- Evaluate the next argument if neeeded.
        evalArgs (Cons cArg' csArg') (Cons xArg' xsArg') xsArgDone
         -- Primitive does not demand a value for this arg.
         | Exp  <- cArg'
         = evalArgs csArg' xsArg' (Cons xArg' xsArgDone)

         -- Primitive demands a value for this arg.
         = case step (StepStrength False False) ctx xArg' of
                Left err@(ResultError _)
                 -> Left err

                Left ResultDone
                 -> evalArgs csArg' xsArg' (Cons xArg' xsArgDone)

                Right xArg''
                 -> Right $ makeXApps (XRef (RPrm (nameOfPrimEval pe)))
                          $ append (reverse xsArgDone) (Cons xArg'' xsArg')

        -- Number of provided arguments does not match primop def.
        evalArgs Nil _  = Left $ ResultError "Primitive call pattern mismatch."
        evalArgs _ Nil  = Left $ ResultError "Primitive call pattern mismatch."


-------------------------------------------------------------------------------
-- | Push down any outermost substitution train to reveal the head constructor.
push    (xx: Exp s p): Maybe (Exp s p)
 = case xx of
        XRef _          -> Nothing
        XVar _ _        -> Nothing
        XAbs _ _        -> Nothing
        XApp _ _        -> Nothing
        XSub cs2 x2     -> pushTrain cs2 x2


-- | Push a substitution train down into an expression to reveal
--   the head constructor.
pushTrain
        (cs1:   List (Car s p))
        (x2:    Exp s p)
        :       Maybe (Exp s p)
 = case x2 of
        -- Unfold macro under a substitution.
        -- Macro and symbol bodies are closed, so we can drop
        -- the substitution.
        XRef (RMac n)   -> Just x2
        XRef (RSym n)   -> Just x2
        XRef (RPrm n)   -> Just x2

        -- Reference to some other thing.
        XRef _          -> Nothing

        -- Apply the train to a variable.
        XVar name depth
         -> Just $ trainApplyVar cs1 name depth

        -- Push train into both sides of an application.
        XApp x21 xs22
         -> Just $ XApp (trainApply cs1 x21) (map (trainApply cs1) xs22)

        -- Push train under abstraction.
        XAbs ns21 x22
         -> Just $ XAbs ns21 (trainApply (trainBump ns21 cs1) x22)

        -- Combine trains.
        XSub cs2 x22
         -> Just $ trainApply (append cs2 cs1) x22

