
module SMR.Source.Parser
export
{       parseDecls; parseExp;
}
import SMR.Source.Lexer
import SMR.Core.Exp
import Control.Parsec
import Data.Maybe
where


-- Parser Config --------------------------------------------------------------
data Config (s p: Data) where
 Config
        :  (Name -> Maybe s)
        -> (Name -> Maybe p)
        -> Config s p

configSym    ((Config ms mp): Config s p): Name -> Maybe s
 = ms

configPrim   ((Config ms mp): Config s p): Name -> Maybe p
 = mp


-- Decls -----------------------------------------------------------------------
parseDecls 
        (c:  Config s p)
        (ts: List Token)
        : Maybe (List (Decl s p))
 = case parse pDeclsEnd ts of
        Nil               -> Nothing
        Cons (T2 xx _) _  -> Just xx
 where  pDeclsEnd 
         = bind (pDecls c)                              $ λ ds      ->
           bind (pEnd)                                  $ λ kEnd    ->
           return ds


-- Decl ------------------------------------------------------------------------
pDecls  (c: Config s p): Parser Token (List (Decl s p))
 = many (pDecl c)


pDecl   (c: Config s p): Parser Token (Decl s p)
 =      (bind   (pName SMac)                            $ λ nDecl   -> 
         bind   (some (pName SVar))                     $ λ nsParam ->
         bind   (pPunc '=')                             $ λ kEq     -> 
         bind   (pExp c)                                $ λ xBody   ->
         bind   (pPunc ';')                             $ λ kSemi   ->
          (if length nsParam == 0
            then return (DTerm nDecl xBody)
            else return (DTerm nDecl $ XAbs nsParam xBody)))


-- Exp ------------------------------------------------------------------------
-- | Parse a complete expression from the given list of tokens.
parseExp (c: Config s p) (ts: List Token): Maybe (Exp s p)
 = case parse pExpEnd ts of
        Nil               -> Nothing
        Cons (T2 xx _) _  -> Just xx
 where  pExpEnd
         = bind (pExp c)                                $ λ x ->
           bind (pEnd)                                  $ λ kEnd ->
           return x


-- | Parser for an expression.
pExp     (c: Config s p): Parser Token (Exp s p)
 =      -- Abstraction.
   alt  (bind   (pPunc '\\')                            $ λ kLam        -> 
         bind   (some (pName SVar))                     $ λ nsParam     ->
         bind   (pPunc '.')                             $ λ kDot        ->
         bind   (pExp c)                                $ λ xBody       ->
         return (XAbs nsParam xBody))

        -- Substitution train.
 $ alt  (bind   (pTrain c)                              $ λ csTrain     ->
         bind   (pPunc '.')                             $ λ kDot        ->
         bind   (pExp  c)                               $ λ xBody       ->
         return (XSub (reverse csTrain) xBody))

        -- Application using '$'
 $      (bind   (pExpApp c)                             $ λ xHead       -> 
         alt    (bind   (pPunc '$')                     $ λ kDollar     ->
                 bind   (pExp c)                        $ λ xRest       -> 
                 return (XApp xHead (Cons xRest Nil)))

                (return xHead))

-- | Parser for an application.
pExpApp (c: Config s p): Parser Token (Exp s p)
 =      -- Application.
        (bind   (pExpAtom c)                            $ λ xFun   ->
         bind   (some (pExpAtom c))                     $ λ xsArgs ->
         return (makeXApps xFun xsArgs))


-- | Parser for an atomic expression.
pExpAtom (c: Config s p): Parser Token (Exp s p)
 = alt  (bind   (pPunc '(')                             $ λ xBra   ->
         bind   (pExp c)                                $ λ xx     ->
         bind   (pPunc ')')                             $ λ xKet   ->
         return xx)

 $ alt  (bind   (pName SVar)                            $ λ n      ->
        (bind   (pPunc '^')                             $ λ xHat   ->
        (bind   pNat                                    $ λ i      ->
         return (XVar n i))))

 $ alt  (bind   (pName SVar)                            $ λ n      ->
         return (XVar n 0))

 $ alt  (bind   (pName SMac)                            $ λ n      ->
         return (XRef (RMac n)))

 $ alt  (bind   (pName SSet)                            $ λ n      -> 
         return (XRef (RSet n)))

 $ alt  (bind   (pName SSym)                            $ λ n      -> 
         case configSym  c n of
          Just s        -> return (XRef (RSym  s))
          Nothing       -> zero)

 $      (bind   (pName SPrm)                            $ λ n      -> 
         case configPrim c n of
          Just p        -> return (XRef (RPrm  p))
          Nothing       -> zero)


-- Train ----------------------------------------------------------------------
-- | Parser for a substitution train.
--   The cars are produced in reverse order.
pTrain  (c: Config s p): Parser Token (List (Car s p))
 = alt  (bind   (pTrainCar c)                           $ λ cCar   ->
         bind   (pTrain    c)                           $ λ csCar  ->
         return (Cons cCar csCar))

        (return Nil)


-- | Parse a single car in the train.
pTrainCar (c: Config s p): Parser Token (Car s p)
 = alt  -- Substitution,
        -- both simultaneous and recursive
        (bind   (pCarSimRec c)                          $ λ car   -> 
         return car)

        -- Ups.
        (bind    pUps                                   $ λ uUps   ->
         return (CUps uUps))


-- Snv ------------------------------------------------------------------------
-- | Parser for a substitution environment.
--   Snv   ::= '[' Bind*, ']'
pCarSimRec (c: Config s p): Parser Token (Car s p)
 = bind (pPunc '[')                                     $ \ko1  -> 
   alt  (bind (pPunc '[')                               $ \ko2  -> 
         bind (sepBy  (pBind c) (pPunc ','))            $ \bs   ->
         bind (pPunc ']')                               $ \kc1  ->
         bind (pPunc ']')                               $ \kc2  ->
         return (CRec (SSnv (reverse bs))))

        (bind (sepBy  (pBind c) (pPunc ','))            $ \bs   -> 
         bind (pPunc ']')                               $ \kc1  ->
         return (CSim (SSnv (reverse bs))))


-- | Parser for a binding.
--   
--   Bind ::= Name '=' Exp
--         |  Name '^' Nat '=' Exp
--
pBind   (c: Config s p)
        : Parser Token (Tup2 (Tup2 Name Nat) (Exp s p))
 = bind (from (takeNameOfToken SVar)) $ λ name ->
   (alt  (bind (pPunc '=')                              $ \xColon ->
          bind (pExp c)                                 $ \x      ->
          return (T2 (T2 name 0) x))

         (bind (pPunc '^')                              $ \xHat   ->
          bind pNat                                     $ \nDepth ->
          bind (pPunc '=')                              $ \xColon ->
          bind (pExp c)                                 $ \x      ->
          return (T2 (T2 name nDepth) x)))


-- Ups ------------------------------------------------------------------------
-- | Parser for an ups.
--
--   Ups  ::= '{' Bump*, '}'
pUps: Parser Token Ups
 = bind (pPunc '{')                                     $ \x1   -> 
   bind (sepBy  pBump (pPunc ','))                      $ \bs   ->
   bind (pPunc '}')                                     $ \x2   ->
   return (UUps (reverse bs))


-- | Parser for a bump.
--   
--   Bump ::= Name '=' Nat
--         |  Name '^' Nat '=' Nat
--
pBump: Parser Token (Tup2 (Tup2 Name Nat) Nat)
 = bind (pName SVar)                                    $ λ name ->
   (alt  (bind (pPunc ':')                              $ \xColon ->
          bind pNat                                     $ \nBump  ->
          return (T2 (T2 name 0) nBump))

         (bind (pPunc '^')                              $ \xHat   ->
          bind pNat                                     $ \nDepth ->
          bind (pPunc ':')                              $ \xColon ->
          bind pNat                                     $ \nBump  ->
          return (T2 (T2 name nDepth) nBump)))


-------------------------------------------------------------------------------
-- | Parser for the end of input token.
pEnd: Parser Token Unit
 =  bind (satisfies (isToken KEnd))     $ λk
 -> return ()


-- | Parser for a natural number.
pNat: Parser Token Nat
 =  bind (from takeNatOfToken) $ λn
 -> return n


-- | Parser for a punctuation character.
pPunc (c: Char): Parser Token Unit
 =  bind (satisfies (isToken (KPunc c))) $ λk
 -> return ()


-- | Parser for a name in the given space
pName (s: Space): Parser Token Name
 = from (takeNameOfToken s)

