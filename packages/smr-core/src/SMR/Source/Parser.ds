
module SMR.Source.Parser
export
{       parseDecls; parseExp;
        pretty_ParseError; pretty_Blocker;
        pretty_LocatedToken;
        pretty_Expected
}
import SMR.Source.Lexer
import SMR.Core.Exp
import Control.Parsec
import Data.Maybe
import Data.Lens
where


-- Interface ------------------------------------------------------------------
parseDecls
        (c:  Config s p)
        (ts: List (Located Token))
        :    Either (ParseError (Located Token) (Expected s p))
                    (List (Decl s p))
 = case parse pDeclsEnd ts of
        ParseResult bs Nothing          -> Left $ ParseError bs
        ParseResult bs (Just (xx, _))   -> Right xx
 where
        pDeclsEnd
         = do   ds      <- pDecls {c}
                _       <- pEnd
                return ds


-- | Parse a complete expression from the given list of tokens.
parseExp (c:  Config s p)
         (ts: List (Located Token))
        : Either (ParseError (Located Token) (Expected s p))
                 (Exp s p)
 = case parse pExpEnd ts of
        ParseResult bs Nothing          -> Left $ ParseError bs
        ParseResult bs (Just (xx, _))   -> Right xx
 where
        pExpEnd
         = do   x       <- pExp {c}
                _       <- pEnd
                return x


pretty_LocatedToken: Pretty (Located Token)
 = Pretty show

data ParseError (t e: Data) where
        ParseError
         :  List (Blocker t e)
         -> ParseError t e

pretty_ParseError
        {Pretty t} {Pretty e}
        : Pretty (ParseError t e)
 =  Pretty $ \(ParseError bs)
 -> unlines $ map ppr bs

---
pretty_Blocker
        {Pretty t} {Pretty e}
        : Pretty (Blocker t e)
 =  Pretty $ \(Blocker e ts)
 -> case ts of
        Nil             -> ppr e
        Cons t _        -> "at token" %% ppr t %% ppr e


----
data Expected (s p: Data) where
        ExEnd   : Expected s p
        ExName  : Space         -> Expected s p
        ExNat   : Expected s p
        ExPunc  : Char          -> Expected s p
        ExMsg   : Text          -> Expected s p
        ExNameAny:              Expected s p


pretty_Expected
        {Pretty s} {Pretty p}
        : Pretty (Expected s p)
 = Pretty $ \bb
 -> case bb of
        ExEnd     -> "expecting end of input"
        ExName s  -> "expecting name" %% show s
        ExNat     -> "expecting natural number"
        ExPunc c  -> "expecting punctuation" %% textOfChar c
        ExMsg t   -> "expecting" %% t
        ExNameAny -> "expecting name"



unlines (txs: List Text): Text
 = case txs of
        Nil     -> ""
        Cons t txs' -> t % "\n" % unlines txs'

-- Decl ------------------------------------------------------------------------
pDecls  {c: Config s p}
        : Parser (Located Token) (Expected s p) (List (Decl s p))
 =      many pDecl


pDecl   {c: Config s p}
        : Parser (Located Token) (Expected s p) (Decl s p)
 = do   name    <- pNameOfSpace SMac
        nsParam <- some (pNameOfSpace SVar)
        _       <- pPunc '='
        xBody   <- pExp
        _       <- pPunc ';'
        if length nsParam == 0
         then return (DTerm name xBody)
         else return (DTerm name $ XAbs nsParam xBody)


-- Exp ------------------------------------------------------------------------
-- | Parser for an expression.
pExp    {c: Config s p}
        :   Parser (Located Token) (Expected s p) (Exp s p)
        -- Abstraction.
 = alt (withRangeExp $ do
        _       <- pPunc '\\'
        nsParam <- some (pNameOfSpace SVar)
        _       <- pPunc '.'
        xBody   <- pExp
        return  $ XAbs nsParam xBody)

        -- Substitution train.
 $ alt (withRangeExp $ do
        csTrain <- pTrain
        _       <- pPunc '.'
        xBody   <- pExp
        return  $  XSub (reverse csTrain) xBody)

        -- Application possibly using '$'
 $ alt (withRangeExp $ do
        xHead   <- pExpApp
        alt (do _       <- pPunc '$'
                xRest   <- pExp
                return  $  XApp xHead (Cons xRest Nil))
            (return xHead))
 $ expected (ExMsg "derp")


-- | Parser for an application.
pExpApp {c: Config s p}
        :   Parser (Located Token) (Expected s p) (Exp s p)
 = do   xFun    <- pExpAtom
        alt (do _       <- pPunc '<'
                xsArgs  <- sepBy pExp (pPunc ',')
                _       <- pPunc '>'
                return  $ makeXApps xFun xsArgs)

            (do xsArgs  <- some pExpAtom
                return  $ makeXApps xFun xsArgs)


-- | Parser for an atomic expression.
pExpAtom {c: Config s p}
         :   Parser (Located Token) (Expected s p) (Exp s p)
        -- Parenthesised expression.
 = alt (withRangeExp $ do
        _       <- pPunc '('
        x       <- pExp
        _       <- pPunc ')'
        return x)

        -- Named variable with or without index.
 $     (withRangeExp $ do
        (space, name) <- pName

        case space of
         -- Named variable.
         SVar
          -> alt (do    _       <- pPunc '^'
                        ix      <- pNat
                        return  $ XVar name ix)
                 (return $ XVar name 0)

         -- Named macro.
         SMac ->  return $ XRef (RMac name)

         -- Named set.
         SSet ->  return $ XRef (RSet name)

         -- Named symbol
         SSym
          -> case configSym c name of
                Just s  -> return (XRef (RSym s))
                Nothing -> fail

         -- Named primitive.
         SPrm
          -> case configPrim c name of
                Just p  -> return (XRef (RPrm p))
                Nothing -> fail)


-- Train ----------------------------------------------------------------------
-- | Parser for a substitution train.
--   The cars are produced in reverse order.
pTrain  {c: Config s p}
        :   Parser (Located Token) (Expected s p) (List (Car s p))
 = do   cCar    <- pTrainCar
        alt
         (do csCar <- pTrain
             return $ Cons cCar csCar)
         (do return $ Cons cCar Nil)


-- | Parse a single car in the train.
pTrainCar  {c: Config s p}
           : Parser (Located Token) (Expected s p) (Car s p)
 = alt  -- Substitution, both simultaneous and recursive
    (do car     <- pCarSimRec
        return car)

    (do -- An ups car.
        ups     <- pUps
        return (CUps ups))


-- Snv ------------------------------------------------------------------------
-- | Parser for a substitution environment.
--
--   Snv   ::= '[' Bind*, ']'
--
pCarSimRec {c: Config s p}
           :   Parser (Located Token) (Expected s p) (Car s p)
 = do   _       <- pPunc '['

        alt     -- Recursive substitution.
         (do    _       <- pPunc '['
                bs      <- sepBy pBind (pPunc ',')
                _       <- pPunc ']'
                _       <- pPunc ']'
                return  $ CRec (SSnv (reverse bs)))

                -- Simultaneous substitution.
         (do    bs      <- sepBy pBind (pPunc ',')
                _       <- pPunc ']'
                return  $ CSim (SSnv (reverse bs)))


-- | Parser for a binding.
--
--   Bind ::= Name '=' Exp
--         |  Name '^' Nat '=' Exp
--
pBind   {c: Config s p}
        :   Parser (Located Token) (Expected s p) ((Name, Nat), Exp s p)
 = do   name    <- pNameOfSpace SVar
        alt
         (do    _       <- pPunc '='
                x       <- pExp
                return  ((name, 0), x))

         (do    _       <- pPunc '^'
                bump    <- pNat
                _       <- pPunc '='
                x       <- pExp
                return  ((name, bump), x))


-- Ups ------------------------------------------------------------------------
-- | Parser for an ups.
--
--   Ups  ::= '{' Bump*, '}'
--
pUps: Parser (Located Token) (Expected s p) Ups
 = do   _       <- pPunc '{'
        bs      <- sepBy pBump (pPunc ',')
        _       <- pPunc '}'
        return  $ UUps (reverse bs)


-- | Parser for a bump.
--
--   Bump ::= Name ':' Nat
--         |  Name '^' Nat ':' Nat
--
pBump: Parser (Located Token) (Expected s p) ((Name, Nat), Nat)
 = do   name    <- pNameOfSpace SVar
        alt
         (do    _       <- pPunc ':'
                inc     <- pNat
                return  ((name, 0), inc))

         (do    _       <- pPunc '^'
                depth   <- pNat
                _       <- pPunc ':'
                inc     <- pNat
                return  ((name, depth), inc))


-------------------------------------------------------------------------------
-- | Parser for a natural number.
pNat:   Parser (Located Token) (Expected s p) Nat
 = from ExNat (takeNatOfToken    ∘ valueOfLocated)


-- | Parser for a name in the given space
pNameOfSpace
        (s: Space): Parser (Located Token) (Expected s p) Name
 = from (ExName s) (takeNameOfToken s ∘ valueOfLocated)


-- | Parser for a name of any spacec.
pName:  Parser (Located Token) (Expected s p) (Space, Name)
 =      from ExNameAny (takeAnyNameOfToken ∘ valueOfLocated)


-- | Parser for the end of input token.
pEnd:   Parser (Located Token) (Expected s p) Unit
 = do   _ <- satisfies ExEnd     (isToken KEnd      ∘ valueOfLocated)
        return ()


-- | Parser for a punctuation character.
pPunc   (c: Char)
        : Parser (Located Token) (Expected s p) Unit
 = do   _ <- satisfies (ExPunc c) (isToken (KPunc c) ∘ valueOfLocated)
        return ()


-- Parser Config --------------------------------------------------------------
-- | Configuration for a parser.
--
data Config (s p: Data) where
 Config
        :  (Name     -> Maybe s)        -- ^ Read a symbol name.
        -> (Name     -> Maybe p)        -- ^ Read a primitive name.
        -> Lens (Exp s p) (Maybe (Location, Location))
        -> Config s p

configSym  ((Config ms mp _): Config s p): Name -> Maybe s
 = ms

configPrim ((Config ms mp _): Config s p): Name -> Maybe p
 = mp

configAttach  ((Config _ _ a): Config s p)
        : Lens (Exp s p) (Maybe (Location, Location))
 = a


-- | Attach source locations to an expression,
--   if there is an attach function specified in the config.
attachRangeExp
        {config:      Config s p}
        (lStart lEnd: Location) (xx: Exp s p): Exp s p
 = lens_set (configAttach config) (Just (lStart, lEnd)) xx


-- | Run an expression parser,
--   and wrap the result in the source location.
withRangeExp
        {c: Config s p}
        (p: Parser (Located Token) (Expected s p) (Exp s p))
        :   Parser (Located Token) (Expected s p) (Exp s p)
 = do   -- TODO: binding against pattern yield 'bad pattern' error.
        --(kStart, xx, kEnd) <- delim p
        res     <- withDelims p
        case res of
         (kStart, xx, kEnd)
          -> do lStart  = startOfLocated kStart
                lEnd    = endOfLocated   kEnd
                return  $ attachRangeExp lStart lEnd xx

