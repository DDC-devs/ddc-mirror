
module SMR.Source.Parser
export
{       parseDecls; parseExp;
}
import SMR.Source.Lexer
import SMR.Core.Exp
import Control.Parsec
import Data.Maybe
where


-- Parser Config --------------------------------------------------------------
data Config (s p: Data) where
 Config
        :  (Name -> Maybe s)
        -> (Name -> Maybe p)
        -> Config s p

configSym    ((Config ms mp): Config s p): Name -> Maybe s
 = ms

configPrim   ((Config ms mp): Config s p): Name -> Maybe p
 = mp


-- Decls -----------------------------------------------------------------------
parseDecls
        (c:  Config s p)
        (ts: List (Located Token))
        : Maybe (List (Decl s p))
 = case parse pDeclsEnd ts of
        Nil               -> Nothing
        Cons (T2 xx _) _  -> Just xx
 where
        pDeclsEnd
         = do   ds      <- pDecls c
                _       <- pEnd
                return ds


-- Decl ------------------------------------------------------------------------
pDecls  (c: Config s p): Parser (Located Token) (List (Decl s p))
 =      many (pDecl c)


pDecl   (c: Config s p): Parser (Located Token) (Decl s p)
 = do   name    <- pName SMac
        nsParam <- some (pName SVar)
        _       <- pPunc '='
        xBody   <- pExp c
        _       <- pPunc ';'
        if length nsParam == 0
         then return (DTerm name xBody)
         else return (DTerm name $ XAbs nsParam xBody)


-- Exp ------------------------------------------------------------------------
-- | Parse a complete expression from the given list of tokens.
parseExp (c:  Config s p)
         (ts: List (Located Token)): Maybe (Exp s p)
 = case parse pExpEnd ts of
        Nil               -> Nothing
        Cons (T2 xx _) _  -> Just xx
 where
        pExpEnd
         = do   x       <- pExp c
                _       <- pEnd
                return x


-- | Parser for an expression.
pExp    (c: Config s p)
        :   Parser (Located Token) (Exp s p)
 = alt  -- Abstraction.
   (do  _       <- pPunc '\\'
        nsParam <- some (pName SVar)
        _       <- pPunc '.'
        xBody   <- pExp c
        return  $ XAbs nsParam xBody)

 $ alt  -- Substitution train.
   (do  csTrain <- pTrain c
        _       <- pPunc '.'
        xBody   <- pExp c
        return  $  XSub (reverse csTrain) xBody)

 $     -- Application possibly using '$'
   (do  xHead   <- pExpApp c
        alt (do _       <- pPunc '$'
                xRest   <- pExp c
                return  $  XApp xHead (Cons xRest Nil))
            (return xHead))


-- | Parser for an application.
pExpApp (c: Config s p)
        :   Parser (Located Token) (Exp s p)
 = do   xFun    <- pExpAtom c
        alt (do _       <- pPunc '<'
                xsArgs  <- sepBy (pExp c) (pPunc ',')
                _       <- pPunc '>'
                return  $ makeXApps xFun xsArgs)

            (do xsArgs  <- some (pExpAtom c)
                return  $ makeXApps xFun xsArgs)


-- | Parser for an atomic expression.
pExpAtom (c: Config s p)
         :   Parser (Located Token) (Exp s p)
 = alt  -- Parenthesised expression.
   (do  _       <- pPunc '('
        x       <- pExp c
        _       <- pPunc ')'
        return x)

 $ alt  -- Named variable with or without index.
   (do  name    <- pName SVar
        alt (do _       <- pPunc '^'
                ix      <- pNat
                return  $ XVar name ix)
            (return $ XVar name 0))

 $ alt  -- Named macro.
   (do  name    <- pName SMac
        return  $ XRef (RMac name))

 $ alt  -- Named set.
   (do  name    <- pName SSet
        return  $ XRef (RSet name))

 $ alt  -- Named symbol.
   (do  name     <- pName SSym
        case configSym c name of
         Just s  -> return (XRef (RSym s))
         Nothing -> zero)

 $      -- Named primitive.
   (do  name     <- pName SPrm
        case configPrim c name of
         Just p  -> return (XRef (RPrm p))
         Nothing -> zero)


-- Train ----------------------------------------------------------------------
-- | Parser for a substitution train.
--   The cars are produced in reverse order.
pTrain  (c: Config s p)
        :   Parser (Located Token) (List (Car s p))
 = alt  -- A new car on a train.
    (do cCar    <- pTrainCar c
        csCar   <- pTrain c
        return  $  Cons cCar csCar)

    (do -- An empty train.
        return Nil)


-- | Parse a single car in the train.
pTrainCar  (c: Config s p)
           : Parser (Located Token) (Car s p)
 = alt  -- Substitution, both simultaneous and recursive
    (do car     <- pCarSimRec c
        return car)

    (do -- An ups car.
        ups     <- pUps
        return (CUps ups))


-- Snv ------------------------------------------------------------------------
-- | Parser for a substitution environment.
--
--   Snv   ::= '[' Bind*, ']'
--
pCarSimRec (c: Config s p)
           :   Parser (Located Token) (Car s p)
 = do   _       <- pPunc '['

        alt     -- Recursive substitution.
         (do    _       <- pPunc '['
                bs      <- sepBy (pBind c) (pPunc ',')
                _       <- pPunc ']'
                _       <- pPunc ']'
                return  $ CRec (SSnv (reverse bs)))

                -- Simultaneous substitution.
         (do    bs      <- sepBy (pBind c) (pPunc ',')
                _       <- pPunc ']'
                return  $ CSim (SSnv (reverse bs)))


-- | Parser for a binding.
--
--   Bind ::= Name '=' Exp
--         |  Name '^' Nat '=' Exp
--
pBind   (c: Config s p)
        :   Parser (Located Token) (Tup2 (Tup2 Name Nat) (Exp s p))
 = do   name    <- pName SVar
        alt
         (do    _       <- pPunc '='
                x       <- pExp c
                return  $ T2 (T2 name 0) x)

         (do    _       <- pPunc '^'
                bump    <- pNat
                _       <- pPunc '='
                x       <- pExp c
                return  $ T2 (T2 name bump) x)


-- Ups ------------------------------------------------------------------------
-- | Parser for an ups.
--
--   Ups  ::= '{' Bump*, '}'
pUps: Parser (Located Token) Ups
 = do   _       <- pPunc '{'
        bs      <- sepBy pBump (pPunc ',')
        _       <- pPunc '}'
        return  $ UUps (reverse bs)


-- | Parser for a bump.
--
--   Bump ::= Name ':' Nat
--         |  Name '^' Nat ':' Nat
--
pBump: Parser (Located Token) (Tup2 (Tup2 Name Nat) Nat)
 = do   name    <- pName SVar
        alt
         (do    _       <- pPunc ':'
                inc     <- pNat
                return  $  T2 (T2 name 0) inc)

         (do    _       <- pPunc '^'
                depth   <- pNat
                _       <- pPunc ':'
                inc     <- pNat
                return  $  T2 (T2 name depth) inc)


-------------------------------------------------------------------------------
-- | Parser for the end of input token.
pEnd: Parser (Located Token) Unit
 = do   _       <- satisfies (isToken KEnd ∘ fromLocated)
        return ()


-- | Parser for a natural number.
pNat: Parser (Located Token) Nat
 = from (takeNatOfToken ∘ fromLocated)


-- | Parser for a name in the given space
pName (s: Space): Parser (Located Token) Name
 = from (takeNameOfToken s ∘ fromLocated)


-- | Parser for a punctuation character.
pPunc (c: Char): Parser (Located Token) Unit
 = do   _       <- satisfies (isToken (KPunc c) ∘ fromLocated)
        return ()

