
module SMR.Source.Lexer
export lexTokens
import SMR.Source.Token
import SMR.Core.Exp
import System.Posix.Stdlib
import Control.Parsec
import Class.Show
import Data.Tuple
import Data.Text
where


-- | Lex a sequence of tokens.
lexTokens (cs: List Char): Tup2 (List Token) (List Char)
 = case lexToken cs of
        Nothing                 -> T2 Nil cs
        Just (T2 k cs')  
         -> case lexTokens cs' of
                T2 ks cs''      -> T2 (Cons k ks) cs''


-- | Lex a single token.
lexToken (xx: List Char)
         : Maybe (Tup2 Token (List Char))
 = case xx of
    Nil                 -> Nothing
    Cons c xs
        -- Skip leading whitespace.
        | c == ' '      -> lexToken xs
        | c == '\n'     -> lexToken xs
        | c == '\t'     -> lexToken xs

        -- Skip comments
        |  c == '!'
        -> lexToken (dropWhile (\x -> x /= '\n') xs)

        -- Punctuation.
        |  isCharPunc c
        -> Just (T2 (KPunc c) xs)

        -- Variable name.
        -- TODO: Inlining takeSpace into the guard causes an LLVM dominator error.
        |  Just (T2 space xx')   <- takeSpace c xs
        ,  Just (T2 name csRest) <- lexName   xx'
        -> Just (T2 (KName space name) csRest)

        --  Natural number.
        |  isDigit c
        ,  Just (T2 n csRest)    <- lexNat (Cons c xs)
        -> Just (T2 (KNat n) csRest)

        |  otherwise     
        -> Nothing


-- | Take the namespace qualifier from the front of a name.
takeSpace (c: Char) (cs: List Char)
          : Maybe (Tup2 Space (List Char))
 | isLower c ∨ isLower c   
                = Just (T2 SVar (Cons c cs))
 | c == '@'     = Just (T2 SMac cs)
 | c == '+'     = Just (T2 SSet cs)
 | c == '%'     = Just (T2 SSym cs)
 | c == '#'     = Just (T2 SPrm cs)
 | otherwise    = Nothing


-- | Check if this is a punctuation character.
isCharPunc (c: Char): Bool
 | c == '('     = True
 | c == ')'     = True
 | c == '{'     = True
 | c == '}'     = True
 | c == '['     = True
 | c == ']'     = True
 | c == '<'     = True
 | c == '>'     = True
 | c == '^'     = True
 | c == ','     = True
 | c == ':'     = True
 | c == '\\'    = True
 | c == '.'     = True
 | c == ';'     = True
 | c == '='     = True
 | c == '$'     = True
 | otherwise    = False


-- | Lex a variable name.
lexName (xx: List Char): Maybe (Tup2 Name (List Char))
 = go Nil xx
 where  
        go acc Nil              
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name Nil

        go acc (Cons c cs)
         | isNameBodyChar c     = go (Cons c acc) cs

         | otherwise            
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name (Cons c cs)


-- TODO: check fixity of ∨, should be able to write these as one clause.
isNameBodyChar (c: Char): Bool
 = isLower c ∨ (isUpper c ∨ (isDigit c ∨ (c == '-' ∨ (c == '\'' ∨ c == '_'))))


-- | Lex a natural number.
lexNat (xx: List Char): Maybe (Tup2 Nat (List Char))
 = go Nil xx
 where
        go acc Nil
         | Just nat     <- readNat (textOfCharList (reverse acc))
         = Just $ T2 nat Nil

        go acc (Cons c cs)
         | isDigit c    = go (Cons c acc) cs

         | Just nat     <- readNat (textOfCharList (reverse acc))
         = Just $ T2 nat (Cons c cs)

        go _ _
         = Nothing

