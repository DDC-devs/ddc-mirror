
module SMR.Source.Lexer
export lexTokens
import SMR.Source.Token
import SMR.Core.Exp
import System.Posix.Stdlib
import Control.Parsec
import Class.Show
import Data.Tuple
import Data.Text
where


-- | Lex a sequence of tokens.
lexTokens
        (lStart0: Location)
        (cs0:     List Char)
        :        Tup3 (List (Located Token)) Location (List Char)
 = case skipSpace lStart0 cs0 of
        T2 lStart Nil
         -> T3  (Cons (Located lStart lStart KEnd) Nil)
                lStart
                Nil

        T2 lStart cs
         -> case lexToken lStart cs of
                Nothing
                 -> T3 Nil lStart cs

                Just (T2 k cs')
                 -> case lexTokens (endOfLocated k) cs' of
                        T3 ks lStart' cs''
                         -> T3 (Cons k ks) lStart' cs''


-- | Lex a single token.
lexToken (lStart: Location)
         (xx:   List Char)
         :      Maybe (Tup2 (Located Token) (List Char))
 = case xx of
    Nil
     -> Nothing

    Cons c xs
        -- Punctuation.
        |  isCharPunc c
        -> do   lEnd    = incChar 1 lStart
                tok     = KPunc c
                Just $ T2 (Located lStart lEnd tok) xs

        -- Variable name.
        -- TODO: Inlining takeSpace into the guard causes an LLVM dominator error.
        |  Just (T2 space xx')          <- takeSpace c xs
        ,  Just (T3 name  lEnd csRest)  <- lexName   lStart xx'
        -> do   tok      = KName space name
                Just $ T2 (Located lStart lEnd tok) csRest

        --  Natural number.
        |  isDigit c
        ,  Just (T3 nat   lEnd csRest)  <- lexNat lStart (Cons c xs)
        -> do   tok      = KNat nat
                Just $ T2 (Located lStart lEnd tok) csRest

        |  otherwise
        -> Nothing


skipSpace
        (lStart: Location) (xx: List Char)
        : Tup2 Location (List Char)
 = case xx of
        Nil             -> T2 lStart xx
        Cons c cs
         -- Skip whitespace.
         | c == ' '     -> skipSpace (incChar 1 lStart) cs
         | c == '\n'    -> skipSpace (incLine 1 lStart) cs
         | c == '\t'    -> skipSpace (incChar 8 lStart) cs

         -- Skip comments
         |  c == '!'    -> skipSpace (incLine 1 lStart)
                        $  dropWhile (\x -> x /= '\n') cs

         | otherwise    -> T2 lStart xx


-- | Increment the line count in a location.
incLine (inc: Nat) ((Location nLine nChar): Location): Location
 = Location (nLine + inc) 1


-- | Increment the char count in a location.
incChar (inc: Nat) ((Location nLine nChar): Location): Location
 = Location nLine (nChar + inc)


-- | Lex a variable name.
lexName (lStart: Location) (xx: List Char)
        :    Maybe (Tup3 Name Location (List Char))
 = go lStart Nil xx
 where
        go lStart' acc Nil
         = do   name    = textOfCharList (reverse acc)
                Just $ T3 name lStart' Nil

        go lStart' acc (Cons c cs)
         | isNameBodyChar c
         =      go (incChar 1 lStart') (Cons c acc) cs

         | otherwise
         = do   name    = textOfCharList (reverse acc)
                Just $ T3 name lStart' (Cons c cs)


-- | Lex a natural number.
lexNat  (lStart: Location) (xx: List Char)
        :    Maybe (Tup3 Nat Location (List Char))
 = go lStart Nil xx
 where
        go lStart' acc Nil
         | Just nat     <- readNat (textOfCharList (reverse acc))
         = Just $ T3 nat lStart' Nil

        go lStart' acc (Cons c cs)
         | isDigit c
         =      go (incChar 1 lStart') (Cons c acc) cs

         | Just nat     <- readNat (textOfCharList (reverse acc))
         = Just $ T3 nat lStart' (Cons c cs)

        go _ _
         = Nothing


-- TODO: check fixity of ∨, should be able to write these as one clause.
isNameBodyChar (c: Char): Bool
 = isLower c ∨ (isUpper c ∨ (isDigit c ∨ (c == '-' ∨ (c == '\'' ∨ c == '_'))))


-- | Take the namespace qualifier from the front of a name.
takeSpace (c: Char) (cs: List Char)
          : Maybe (Tup2 Space (List Char))
 | isLower c ∨ isLower c
                = Just (T2 SVar (Cons c cs))
 | c == '@'     = Just (T2 SMac cs)
 | c == '+'     = Just (T2 SSet cs)
 | c == '%'     = Just (T2 SSym cs)
 | c == '#'     = Just (T2 SPrm cs)
 | otherwise    = Nothing


-- | Check if this is a punctuation character.
isCharPunc (c: Char): Bool
 | c == '('     = True
 | c == ')'     = True
 | c == '{'     = True
 | c == '}'     = True
 | c == '['     = True
 | c == ']'     = True
 | c == '<'     = True
 | c == '>'     = True
 | c == '^'     = True
 | c == ','     = True
 | c == ':'     = True
 | c == '\\'    = True
 | c == '.'     = True
 | c == ';'     = True
 | c == '='     = True
 | c == '$'     = True
 | otherwise    = False
