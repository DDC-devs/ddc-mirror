
-- Shimmer v1.0. The Lambda Machine.
module Main
import SMR.Core.Exp
import SMR.Core.Step
import SMR.Prim.Op
import SMR.Prim.Name
import SMR.Source.Pretty
import SMR.Source.Token
import SMR.Source.Parser
import System.IO.Console
import System.IO.File
import Main.Args
import Data.Maybe
where

---------------------------------------------------------------------------------------------------
data Cmd where
        CmdNone : Cmd
        CmdStep : Exp Name Prim -> Cmd


data State where
        State
         :  Config Name Prim                            -- ^ Parser config.
         -> List (Tup2 Prim (PrimEval Name Prim))       -- ^ Primitive evaluators.
         -> List (Decl Name Prim)                       -- ^ Top-level declarations
         -> State

configOfState    ((State config _ _): State): Config Name Prim
 = config

primTableOfState ((State _ evals _):  State): List (Tup2 Prim (PrimEval Name Prim))
 = evals

declsOfState     ((State _ _ decls):  State): List (Decl Name Prim)
 = decls



-- Utils ------------------------------------------------------------------------------------------
-- Shift this stuff somewhere else.
show_Unit: Show Unit
 = Show   $ λxx -> "()"

pretty_Text: Pretty Text
 = Pretty $ λxx -> xx

-- TODO: need explicit run/box
getLine: S Console Text
 = box do
        txt     = run readl 2014
        textOfCharList $ init Nil $ charListOfText txt



---------------------------------------------------------------------------------------------------
main ()
 = do   writel "Shimmer, version 1.0. The Lambda Machine."

        mSource
         = mainArgs_load Nothing
         $ Cons (ArgText "-i" "include file" (\s _ -> Just s))
         $ Nil

        -- Build the table of primitive evaluators.
        primEvals
         = makePrimOps ()

        -- Extract a list of primitive names.
        -- TODO: find out why we need explicit type app,
        --       as well as explicit type abs to set the tyvar order.
        primNames
         = map (nameOfPrimEval [Text] [Prim]) primEvals

        -- Extract textual names of primitives.
        primNamesText
         = mapMaybe
                (\e -> case e of
                        PrimOp n        -> Just n
                        _               -> Nothing)
         $ primNames

        -- Build table of prim name to evaluator.
        primTable
         = zip primNames primEvals

        -- Build the parser config.
        config
         = Config (\z -> Just z)
                  (\z -> parsePrim primNamesText z)

        case mSource of
         Just (TextLit path)
          -> case loadSource config path of
                 Nothing        -> writel "load failed"
                 Just decls     -> repl (State config primTable decls) CmdNone

         Nothing
          -> repl (State config primTable Nil) CmdNone


-- | Load a list of top-level declarations from a source file.
loadSource
        (config: Config Name Prim)
        (path:   TextLit)
        :        S (File + Console) (Maybe (List (Decl Name Prim)))
 = do
        str     = file_read (takeTextLit path)

        case lexTokens (Location 1 1) $ charListOfText str of
         T3 toks _ cs
          |  not $ all isSpace cs
          -> do writel "! error at end of input."
                writel (show cs)
                Nothing

          |  otherwise
          -> case parseDecls config toks of
                 Nothing  -> Nothing
                 Just ds' -> Just ds'

         _ -> Nothing

show_Char: Show Char
 = Show textOfChar


-- | Read-Eval-Print loop.
--   TODO: need to put the explicit box.
--
--   TODO: closing stdin with control-D causes prompt to print infinitely.
--
--   TODO: suspect that tail call opt isn't working so that every intermediate
--   expression is retained in the state. We could store the expression
--   in a ref to hack around this.
--
repl    (state: State) (cmd: Cmd): S Console Unit
 = box do
        -- Write the prompt.
        write "> "
        flush

        -- Get the line and convert it to tokens.
        str     = getLine

        case lexTokens (Location 1 1) $ charListOfText str of
         -- If only whitespace was provided then run the default command.
         T3 (Cons lt Nil) _ Nil
          |  fromLocated lt == KEnd
          -> case cmd of
                CmdNone    -> repl      state CmdNone
                CmdStep xx -> repl_step state xx

         -- We have some tokens, to parse them.
         T3 toks _ Nil
          ->    repl_toks state CmdNone toks

         -- We couldn't lex all the characters into tokens.
         T3 toks lStart' cs
          -> case last toks of
                Nothing
                 -> do  writell $ "!"
                                %% "1:1"
                                %% "<interactive>: lexical error."

                Just tok
                 | Location nLine nChar <- lStart'
                 , Cons c _             <- cs
                 -> do  writell $ "!"
                                %% show nLine % ":" % show nChar
                                %% "<interactive>: lexical error on"
                                %% "'" % textOfChar c % "'."

                        repl state CmdNone


-- | Given some tokens, try to parse an expression and evaluate it.
repl_toks
        (state: State) (cmd: Cmd)
        (toks:  List (Located Token))
        :       S Console Unit
 = case parseExp (configOfState state) toks of
         Nothing
          -> case last toks of
                Nothing
                 -> do  writell "! parser error at end of input."
                        repl state CmdNone

                Just tok'
                 | Location nLine nChar <- startOfLocated tok'
                 -> do  writell $  "!"
                                %% show nLine % ":" % show nChar
                                %% "parse error."
                        repl state CmdNone

         Just x
          ->    repl_step state x


-- | Given an expression,
--   try to perform a single evaluation step.
repl_step
        (state: State)
        (xx:    Exp Name Prim)
        :       S Console Unit
 = case step' state True xx of
        Left (ResultError err)
         -> do  writel    "! runtime error."
                writell $ "! " % err

                repl state CmdNone

        Left ResultDone
         -> do  writell "! done."
                repl state CmdNone

        Right x'
         -> do  -- writell "! step."
                writell (ppr x')
                repl state (CmdStep x')


-- | Single step an expression.
step'   (state: State)
        (red:   Bool)
        (xx:    Exp Name Prim)
        :       Either Result (Exp Name Prim)
 = step (StepStrength red True)
        (StepContext
                (primTableOfState state)
                (declsOfState state))
         xx

