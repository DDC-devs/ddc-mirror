
-- Shimmer v1.0.
--   The Turtle at the Bottom of the World.
--
module Main
import SMR.Core.Exp
import SMR.Core.Eval
import SMR.Core.Step
import SMR.Prim.Op
import SMR.Prim.Name
import SMR.Source.Pretty
import SMR.Source.Token
import SMR.Source.Parser
import System.IO.Console
import System.IO.File
import Main.Args
import Data.Maybe
where


-- TODO: need explict run/box.
main ()
 = do   writel "Shimmer, version 1.0. The Lambda Machine."

        mSource
         = mainArgs_load Nothing
         $ Cons (ArgText "-i" "include file" (\s _ -> Just s))
         $ Nil

        config  = makeParserConfig ()

        case mSource of
         Just (TextLit path)
          -> case loadSource config path of
                 Nothing        -> writel "load failed"
                 Just decls     -> repl config decls CmdNone

         Nothing        
          -> repl config Nil CmdNone


makeParserConfig (u: Unit): Config Name Prim
 = do
        primNames       
         = mapMaybe 
                -- TODO: find out why we need explicit type app,
                -- as well as explicit type abs to set the tyvar order.
                (\e -> case nameOfPrimEval [Text] [Prim] e of
                        PrimOp n        -> Just n
                        _               -> Nothing)
         $ makePrimOps ()

        Config  (\z -> Just z)
                (\z -> if elem z primNames
                        then Just (PrimOp z)
                        else Nothing)


-- | Load a list of top-level declarations from a source file.
loadSource 
        (config: Config Name Prim)
        (path:   TextLit)
        : S File (Maybe (List (Decl Name Prim)))
 = do   
        str     = file_read (takeTextLit path)

        case lexTokens $ charListOfText str of
         T2 toks cs
          |  not $ all isSpace cs       -> Nothing
          |  otherwise
          -> case parseDecls config toks of
                Nothing                 -> Nothing
                Just ds'                -> Just ds'

         _ -> Nothing


show_Unit: Show Unit
 = Show   $ λxx -> "()"

pretty_Text: Pretty Text
 = Pretty $ λxx -> xx

-- TODO: need explicit run/box 
getLine: S Console Text
 = box do   
        txt     = run readl 2014
        textOfCharList $ init Nil $ charListOfText txt        

data Cmd where
        CmdNone : Cmd
        CmdStep : Exp Name Prim -> Cmd


-- | Read-Eval-Print loop.
--   TODO: need to put the explicit box.
--
--   TODO: closing stdin with control-D causes prompt to print infinitely.
--
repl    (config: Config Name Prim)
        (decls:  List (Decl Name Prim))
        (cmd:    Cmd)
        : S Console Unit
 = box do   
        -- Write the prompt.
        write "> "
        flush

        -- Get the line and convert it to tokens.
        str     = getLine

        case lexTokens $ charListOfText str of
         -- If only whitespace was provided then run the default command.
         T2 Nil  Nil    
          -> case cmd of
                CmdNone         -> repl      config decls cmd
                CmdStep xx      -> repl_step config decls xx

         -- We have some tokens, to parse them.
         T2 toks Nil    
          ->    repl_toks config decls CmdNone toks

         -- We couldn't lex all the characters into tokens.
         T2 _    cs   
          -> do writell "! lexical error."
                repl config decls CmdNone


-- | Given some tokens, try to parse an expression and evaluate it.
repl_toks 
        (config: Config Name Prim)
        (decls:  List (Decl Name Prim))
        (cmd:    Cmd)
        (toks:   List Token)
        : S Console Unit
 = case parseExp config toks of
         Nothing
          -> do writell "! parse error."
                repl config decls CmdNone

         Just x
          ->    repl_step config decls x


-- | Given an expression,
--   try to perform a single evaluation step.
repl_step
        (config: Config Name Prim)
        (decls:  List (Decl Name Prim))
        (xx:     Exp Name Prim)
        : S Console Unit
 = case step' decls True xx of
        Left ResultError 
         -> do  writell "! runtime error."
                repl config decls CmdNone

        Left ResultDone
         -> do  -- writell "! done."
                repl config decls CmdNone

        Right x'
         -> do  -- writell "! step."
                writell (ppr x')
                repl config decls (CmdStep x')


-- | Single step an expression.
step'   (decls: List (Decl Name Prim))
        (red:   Bool)
        (xx:    Exp Name Prim)
        : Either Result (Exp Name Prim)
 = step (StepStrength red)
        (StepContext
                (evalPrim (\xp -> case step' decls red xp of
                                        Left _    -> Nothing
                                        Right xp' -> Just xp'))
                decls)
         xx

