
-- Shimmer v1.0. The Lambda Machine.
module Main
import SMR.Core.Exp
import SMR.Core.Step
import SMR.Repl.Error
import SMR.Prim.Op
import SMR.Prim.Name
import SMR.Source.Pretty
import SMR.Source.Token
import SMR.Source.Parser
import System.IO.Console
import System.IO.File
import Main.Args
import Data.Maybe
import Data.Text.Location
where


-------------------------------------------------------------------------------
data Cmd where
        CmdNone : Cmd
        CmdStep : Exp Name Prim -> Cmd


data State where
        State
         :  Config Name Prim                    -- ^ Parser config.
         -> List (Prim, PrimEval Name Prim)     -- ^ Primitive evaluators.
         -> List (Decl Name Prim)               -- ^ Top-level declarations
         -> State

configOfState
        ((State config _ _): State)
        : Config Name Prim
 = config

primTableOfState
        ((State _ evals _):  State)
        : List (Prim, PrimEval Name Prim)
 = evals

declsOfState
        ((State _ _ decls):  State)
        : List (Decl Name Prim)
 = decls


-- Utils ----------------------------------------------------------------------
-- TODO:
-- Shift this stuff somewhere else.
show_Unit: Show Unit
 = Show   $ λxx -> "()"

pretty_Text: Pretty Text
 = Pretty $ λxx -> xx

-- TODO: need explicit run/box
getLine: S Console Text
 = box do
        txt     = run readl 2014
        textOfCharList $ init Nil $ charListOfText txt


-------------------------------------------------------------------------------
main ()
 = do   writel "Shimmer, version 1.0. The Lambda Machine."

        mSource
         = mainArgs_load Nothing
         $ Cons (ArgText "-i" "include file" (\s _ -> Just s))
         $ Nil

        -- Build the table of primitive evaluators.
        primEvals
         = makePrimOps ()

        -- Extract a list of primitive names.
        -- TODO: find out why we need explicit type app,
        --       as well as explicit type abs to set the tyvar order.
        primNames
         = map (nameOfPrimEval [Text] [Prim]) primEvals

        -- Extract textual names of primitives.
        primNamesText
         = mapMaybe
                (\e -> case e of
                        PrimOp n -> Just n
                        _        -> Nothing)
         $ primNames

        -- Build table of prim name to evaluator.
        primTable
         = zip primNames primEvals

        -- Build the parser config.
        config
         = Config (\z -> Just z)
                  (\z -> parsePrim primNamesText z)

        case mSource of
         Just (TextLit path)
          -> case loadSource config path of
                 Nothing    -> writel "load failed"
                 Just decls -> repl (State config primTable decls) CmdNone

         Nothing
          -> repl (State config primTable Nil) CmdNone


-- | Load a list of top-level declarations from a source file.
loadSource
        (config: Config Name Prim)
        (path:   TextLit)
        :        S (File + Console)
                   (Maybe (List (Decl Name Prim)))
 = do
        str     = file_read (takeTextLit path)
        lStart  = Location 1 1
        result  = lexTokens lStart $ charListOfText str

        case result of
         (toks, _, cs)
          |  not $ all isSpace cs
          -> do writel "! error at end of input."
                writel (show cs)
                Nothing

          |  otherwise
          -> case parseDecls config toks of
                Nothing  -> Nothing
                Just ds' -> Just ds'

         _ -> Nothing

show_Char: Show Char
 = Show textOfChar


-- | Read-Eval-Print loop.
--   TODO: need to put the explicit box.
--
--   TODO: closing stdin with control-D causes prompt to print infinitely.
--
--   TODO: suspect that tail call opt isn't working so that every intermediate
--   expression is retained in the state. We could store the expression
--   in a ref to hack around this.
--
repl    (state: State) (cmd: Cmd): S Console Unit
 = box do
        -- Write the prompt.
        write "> "
        flush

        -- Get the line and convert it to tokens.
        str     = getLine
        result  = lexTokens (Location 1 1)
                $ charListOfText str

        case result of
         -- If only whitespace was provided then run the default command.
         (Cons lt Nil, _, Nil)
          |  valueOfLocated lt == KEnd
          -> case cmd of
                CmdNone    -> repl      state CmdNone
                CmdStep xx -> repl_step state xx

         -- We have some tokens, to parse them.
         (toks, _, Nil)
          ->    repl_toks state CmdNone toks

         -- We couldn't lex all the characters into tokens.
         (toks, lStart', cs)
          -> case last toks of
                Just tok
                 |  Cons c _ <- cs
                 -> do  writell $ ppr
                         $ ErrorReplLexer "<interactive>" lStart' (Just c)
                        repl state CmdNone

                _ -> do writell $ ppr
                         $ ErrorReplLexer "<interactive>" lStart' Nothing


-- | Given some tokens, try to parse an expression and evaluate it.
repl_toks
        (state: State) (cmd: Cmd)
        (toks:  List (Located Token))
        :       S Console Unit
 = case parseExp (configOfState state) toks of
        -- Parse succeeded.
        Just x
         ->     repl_step state x

        Nothing
         -- Parse failed on some token.
         -- TODO: Get the token just before parsing failed.
         | Just tok'    <- last toks
         -> do  writell $ ppr
                 $ ErrorReplParser
                        "<interactive>"
                        (startOfLocated tok')
                        (Just $ valueOfLocated tok')
                repl state CmdNone

         -- Parse failed because there was no input,
         -- just read the next line.
         | otherwise
         ->     repl state CmdNone


-- | Given an expression,
--   try to perform a single evaluation step.
repl_step
        (state: State)
        (xx:    Exp Name Prim)
        :       S Console Unit
 = case step' state True xx of
        Left (ResultError err)
         -> do  writell $ ppr $ ErrorReplRuntime  "<interactive>" err
                repl state CmdNone

        Left ResultDone
         -> do  writell "! done."
                repl state CmdNone

        Right x'
         -> do  writell (ppr x')
                repl state (CmdStep x')


-- | Single step an expression.
step'   (state: State)
        (red:   Bool)
        (xx:    Exp Name Prim)
        :       Either Result (Exp Name Prim)
 = step (StepStrength red True)
        (StepContext
                (primTableOfState state)
                (declsOfState state))
         xx

