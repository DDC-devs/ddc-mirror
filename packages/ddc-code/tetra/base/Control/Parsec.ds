
module Control.Parsec
export
{       parser_Functor; parser_Applicative; parser_Monad;
        parse;
        fail; expected; enter;
        peek; item; satisfies;
        from; alt;
        some; many;
        sepBy; sepBy1;
        withDelims;
}
import Class.Monad
import Data.List
import Data.Tuple
import Data.Maybe
import Data.Either
where


-------------------------------------------------------------------------------
-- | Parser is a function that takes a list of tokens,
--   and eturns a list of remaining tokens along with
--    (on error)   a list of descriptions of expected input,
--    (on success) a parsed value.
--
data Parser  (t e a: Data) where
        Parser
         : (List t → ParseResult t e a)
         → Parser t e a


data ParseResult (t e a: Data) where
        -- Parser failed after consuming no input.
        --  The parser looked at one or more tokens at the front of the
        --  input but based on these the input does not look like whatever
        --  syntax the parser was supposed to parse.
        ParseSkip
         :  List e              -- ^ Explanations of what has been skipped.
         -> ParseResult t e a

        -- Parser yielding a value after consuming no input.
        --  The parser returned a value without looking at any tokens,
        --  this is a pure value returning action.
        ParseReturn
         :  List e              -- ^ Explanations of what has been skipped.
         -> a                   -- ^ Produced value.
         -> ParseResult t e a

        -- Parse failed after partially consuming input.
        --   The parser thought that the input sequence looked like what it
        --   was supposed to parse, but complete parsing failed once it
        --   had committed.
        ParseFailure
         :  List (Blocker t e)  -- ^ Other parses that we tried, but failed.
         -> ParseResult t e a

        -- Parse succeeded yielding a value after consuming input.
        --   We have a complete value, and have consumed some input tokens.
        ParseSuccess
         :  List (Blocker t e)  -- ^ Other parses that we tried, but failed.
         -> a                   -- ^ Produced value.
         -> List t              -- ^ Tokens leftover.
         -> ParseResult t e a

-- TODO Lists of expectations shoud be bags, so we can append them easily.
-- TOOD: Always store blockers instead of raw expectations so that
--       we can put them in bags and wrap them uniformly when entering contexts.

-- | Describes why the parser could not make further progress.
data Blocker (t e: Data) where
        Blocker
         :  List t      -- ^ Remaining unparsed tokens where we gave up.
         ->  e          -- ^ Representation of what we were expecting.
         -> Blocker t e


-- | Apply a parser to a list of input tokens.
parse   ((Parser p): Parser t e a) (ts: List t)
        : ParseResult t e a
 = p ts


-- Functor --------------------------------------------------------------------
parser_Functor [t e: Data]: Functor (Parser t e)
 = Functor parser_fmap
 where
        parser_fmap
                [t e a b: Data]
                (f: a → b) (parserA: Parser t e a): Parser t e b
         =  Parser $ λts0
         -> case parse parserA ts0 of
                ParseSkip    es1        -> ParseSkip    es1
                ParseReturn  es1 x      -> ParseReturn  es1 (f x)
                ParseFailure bs1        -> ParseFailure bs1
                ParseSuccess bs1 a ts1  -> ParseSuccess bs1 (f a) ts1


-- Applicative ----------------------------------------------------------------
parser_Applicative [t e: Data]: Applicative (Parser t e)
 = Applicative parser_Functor parser_pure parser_ap

parser_pure
        [t' e' a': Data]
        (x: a'): Parser t' e' a'
 = Parser $ λts → ParseReturn Nil x

-- TODO: these vars need to have diff names as otherwise
-- they're not fresh enough to go through the type checker.
parser_ap
        [t' e' a' b': Data]
        (parserF: Parser t' e' (a' → b'))
        (parserA: Parser t' e' a')
        : Parser t' e' b'
 =  Parser $ λts0
 -> case parse parserF ts0 of
        ParseSkip es1
         -> ParseSkip es1

        ParseFailure bs1
         -> ParseFailure bs1

        ParseReturn  es1 f
         -> case parse parserA ts0 of
                ParseSkip es2
                 -> ParseSkip   (append es1 es2)
                ParseReturn es2 x
                 -> ParseReturn (append es1 es2) (f x)
                ParseFailure bs2
                 -> ParseFailure bs2
                ParseSuccess bs2 x ts2
                 -> ParseSuccess bs2 (f x) ts2

        ParseSuccess bs1 f ts1
         -> case parse parserA ts1 of
                ParseSkip    es2
                 -> ParseFailure (append bs1 (map (Blocker ts1) es2))
                ParseReturn  es2 x
                 -> ParseSuccess (append bs1 (map (Blocker ts1) es2)) (f x) ts1
                ParseFailure bs2
                 -> ParseFailure bs2
                ParseSuccess bs2 x ts2
                 -> ParseSuccess bs2 (f x) ts2


-- Monad ----------------------------------------------------------------------
parser_Monad [t e: Data]: Monad (Parser t e)
 = Monad parser_Applicative parser_return parser_bind


parser_return
        [t' e' a': Data]
        (x: a'): Parser t' e' a'
 = Parser $ λts → ParseReturn Nil x


parser_bind
        [t' e' a' b': Data]
        (parserA:   Parser t' e' a')
        (mkParserB: a' → Parser t' e' b')
        : Parser t' e' b'
 =  Parser $ \ts0
 -> case parse parserA ts0 of
        ParseSkip bs1
         -> ParseSkip bs1

        ParseFailure bs1
         -> ParseFailure bs1

        ParseReturn  es1 xa
         -> case parse (mkParserB xa) ts0 of
                ParseSkip    es2        -> ParseSkip    (append es1 es2)
                ParseReturn  es2 xb     -> ParseReturn  (append es1 es2) xb
                ParseFailure bs2        -> ParseFailure bs2
                ParseSuccess bs2 x ts2  -> ParseSuccess bs2 x ts2


        ParseSuccess bs1 xa ts1
         -> case parse (mkParserB xa) ts1 of
                ParseSkip    es2
                 -> ParseFailure (append bs1 (map (Blocker ts1) es2))
                ParseReturn  es2 xb
                 -> ParseSuccess (append bs1 (map (Blocker ts1) es2)) xb ts1
                ParseFailure bs2
                 -> ParseFailure bs2
                ParseSuccess bs2 xb ts2
                 -> ParseSuccess bs2 xb ts2


-- Prim -----------------------------------------------------------------------
-- Primitive parsers.

-- | Always fail, producing no possible parses and no helpful error message.
fail : Parser t e a
 = Parser $ λts → ParseFailure Nil


-- | Always fail, yielding the given message describing what was expected.
expected (xe: e): Parser t e a
 = Parser $ λts → ParseFailure (Cons (Blocker ts xe) Nil)


-- | Parse in an expectation context.
enter    (mk: List e -> e) (parserA: Parser t e a): Parser t e a
 = Parser $ λts0
 → case parse parserA ts0 of
        ParseSkip    e          → ParseSkip   (Cons (mk e)   Nil)
        ParseReturn  es1 x      → ParseReturn (Cons (mk es1) Nil) x

        ParseFailure bs1
         → ParseFailure (map (\(Blocker ts e) → Blocker ts (mk (Cons e Nil))) bs1)

        ParseSuccess bs1 xb ts2
         → ParseSuccess (map (\(Blocker ts e) → Blocker ts (mk (Cons e Nil))) bs1)
                        xb ts2


-- | Peek at the first input token, without consuming at it.
peek: Parser t e t
 = Parser $ λts
 → case ts of
        Nil             → ParseFailure Nil
        Cons t ts'      → ParseReturn  Nil t


-- | Consume the first input token, failing if there aren't any.
item (xe: e): Parser t e t
 = Parser $ λts
 → case ts of
        Nil             → ParseSkip    (Cons xe Nil)
        Cons t ts'      → ParseSuccess Nil t ts'


-- | Consume the first input token if it matches the given predicate,
--   failing without consuming if the predicate does not match.
satisfies (xe: e) (pred: t → Bool): Parser t e t
 = Parser $ λts
 → case ts of
        Nil             → ParseSkip    (Cons xe Nil)
        Cons t ts'
         | pred t       → ParseSuccess Nil t ts'
         | otherwise    → ParseSkip    (Cons xe Nil)


-- | Consume the first input token if it is accepted by the given match
--   function. Fail without consuming if there is no match.
from      (xe: e) (accept: t → Maybe a): Parser t e a
 = Parser $ λts
 → case ts of
        Nil             → ParseSkip    (Cons xe Nil)
        Cons t ts'
         → case accept t of
               Just x   → ParseSuccess Nil x ts'
               Nothing  → ParseSkip    (Cons xe Nil)


-- | Given two parsers, try the first and if it succeeds produce
--   the output of that parser, if not try the second.
alt (parserA parserB: Parser t e a): Parser t e a
 = Parser $ λts0
 → case parse parserA ts0 of
        ParseSkip es1
         -> case parse parserB ts0 of
                ParseSkip    es2        → ParseSkip   (append es1 es2)
                ParseReturn  es2 x      → ParseReturn (append es1 es2) x
                ParseFailure bs2        → ParseFailure bs2
                ParseSuccess bs2 x ts2  → ParseSuccess bs2 x ts2

        ParseReturn es1
         -> case parse parserB ts0 of
                ParseSkip es2           → ParseSkip    (append es1 es2)
                ParseReturn es2 x       → ParseReturn  (append es1 es2) x
                ParseFailure bs2        → ParseFailure bs2
                ParseSuccess bs2 x ts1  → ParseSuccess bs2 x ts1

        ParseFailure bs1
         -> case parse parserB ts0 of
                ParseSkip _             → ParseFailure bs1
                ParseReturn _           → ParseFailure bs1
                ParseFailure bs2        → ParseFailure bs2
                ParseSuccess bs2 x ts2  → ParseSuccess bs2 x ts2

        ParseSuccess bs1 x ts1          → ParseSuccess bs1 x ts1


-- Derived --------------------------------------------------------------------
-- Parsers derived from the primitive ones.

-- | Combine a list of argument parsers, producing a new one that
--   gives the result produced by the first matching argument parser.
alts (parsers: List (Parser t e a)): Parser t e a
 = case parsers of
        Nil             → fail
        Cons p ps       → alt p (alts ps)


-- | Like `alts`, accept use the given default parser if no
--   parser from the first list succeeds.
altss (parsers: List (Parser t e a)) (def: Parser t e a): Parser t e a
 = case parsers of
        Nil             → def
        Cons p ps       → alt p (altss ps def)


-- | Parse zero or more things, yielding a list of those things.
some (parserA: Parser t e a): Parser t e (List a)
 = alt (do
        x       <- parserA
        xs      <- some parserA
        return  $ Cons x xs)
       (return Nil)


-- | Parse one or more things, yielding a list of those things.
many (parserA: Parser t e a): Parser t e (List a)
 = do   x       <- parserA
        alt (do xs      <- some parserA
                return  $  Cons x xs)
            (do return  $  Cons x Nil)


-- | Parse some things separated by other things.
sepBy1  (parserA: Parser t e a) (parserS: Parser t e s): Parser t e (List a)
 = alt (do
        x       <- parserA
        s       <- parserS
        xs      <- sepBy1 parserA parserS
        return  $ Cons x xs)

       (do
        x       <- parserA
        return  $ Cons x Nil)

sepBy   (parserA: Parser t e a) (parserS: Parser t e s): Parser t e (List a)
 = alt  (sepBy1 parserA parserS)
        (return Nil)


-- | Run a parser, peeking at the starting and ending tokens.
withDelims (p: Parser t e a): Parser t e (t, a, t)
 = do   kStart  <- peek
        x       <- p
        kEnd    <- peek
        return  (kStart, x, kEnd)

