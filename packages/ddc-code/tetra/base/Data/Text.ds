
module Data.Text 
export  { textLit; paste; pastes
        ; showBool
        ; showNat; showBinaryNat; showDecimalNat; showHexNat; showBaseNat
        ; sizeOfText; vectorOfText
        ; digitBinary; digitDecimal; digitHex }
import Data.Numeric.Nat
import Data.Numeric.Bool

import foreign boxed type
 TextLit : Data

-- | Top level region containing text vectors.
import foreign abstract type
 TopText        : Region

-- | Capabilities to allocate and read top-level text vectors.
import foreign abstract capability
 topTextAlloc   : Alloc TopText
 topTextRead    : Read  TopText

import foreign c value
 makeTextLit    : TextLit# -> TextLit
 sizeOfTextLit  : TextLit  -> Nat#
 indexTextLit   : TextLit  -> Nat# -> Word8#

where

-------------------------------------------------------------------------------
-- Names used by the Source Tetra desugarer to implement string literals.
textLit (x : TextLit#) : Text
 = TextLit (makeTextLit x)

paste  (x y : Text) : Text
 = TextApp x y

pastes (x y : Text) : Text
 = x % " " % y


-------------------------------------------------------------------------------
-- TODO: put the vector in the Top region.
data Text where
        TextLit : TextLit               -> Text
--      TextVec : Vector# Top Word8#   -> Text
        TextApp : Text -> Text          -> Text


-- | Convert a Bool to a String.
showBool (x : Bool#) : Text
 = if x then "True" 
        else "False"


-- | Show a natural number.
showNat (x: Nat#): Text
 = showBaseNat 10 digitDecimal 0 "X" x


-- | Get the size of the utf8 data in a Text object, in bytes.
sizeOfText (tt: Text):  Nat#
 = case tt of
        TextLit lit     -> sizeOfTextLit lit
--      TextVec vec     -> vectorLength# vec
        TextApp t1 t2   -> sizeOfText t1 + sizeOfText t2


-- | Copy a Text object into a flat vector of utf-8 bytes.
vectorOfText [r1: Region] (tt: Text): S (Alloc r1) (Vector# r1 Word8#)
 = box extend r1 using r2 with { Alloc r2; Write r2 } in
   do   
        vec     = run vectorAlloc# [r2] [Word8#] (sizeOfText tt)
        copyTextToVector tt vec
        vec


-- | Copy a text literal to a mutable vector of utf-8 bytes.
--   TODO: need (Read Top) capability.
copyTextToVector [r: Region] 
        (tt: Text) (vec: Vector# r Word8#) (i0: Nat#)
        : S (Write r) Nat#
 = box case tt of
        TextLit lit
         -> run copyTextLitToVector lit  vec i0 0 (sizeOfTextLit lit)

--      TextVec vec2
--       -> run copyTextVecToVector vec2 vec i0 0 (vectorLength# vec2)

        TextApp t1 t2
         -> do  i1      = run copyTextToVector t1 vec i0
                i2      = run copyTextToVector t2 vec i1
                i2


-- | Copy a text literal to a mutable vector of utf-8 bytes.
copyTextLitToVector [r: Region]
        (tt: TextLit) (vec: Vector# r Word8#) 
        (iDst: Nat#)  (iSrc: Nat#) (nSrc: Nat#)
        : S (Write r) Nat#
 = box case iSrc == nSrc of
        True  -> iDst
        False -> run do
                x       = indexTextLit tt iSrc
                run vectorWrite# vec iDst x
                copyTextLitToVector tt vec (iDst + 1) (iSrc + 1) nSrc


-- | Copy a text source vector to a mutable destination of utf-8 bytes.
copyTextVecToVector [r1 r2: Region]
        (vecSrc: Vector# r1 Word8#) (vecDst: Vector# r2 Word8#)
        (iDst:   Nat#) (iSrc: Nat#) (nSrc: Nat#)
        : S (Read r1 + Write r2) Nat#
 = box case iSrc == nSrc of
        True    -> iDst
        False   -> run do
                x       = run vectorRead# vecSrc iSrc
                run vectorWrite# vecDst iDst x
                copyTextVecToVector vecSrc vecDst (iDst + 1) (iSrc + 1) nSrc


-------------------------------------------------------------------------------
-- | Show a natural number, in binary.
showBinaryNat (x: Nat#): Text
 = showBaseNat 2 digitBinary 0 "X" x

digitBinary (n: Nat#): Text
 = case n of
        0       -> "0"
        1       -> "1"
        _       -> "X"


-- | Show a natural number in decimal.
showDecimalNat (x: Nat#): Text
 = showBaseNat 10 digitDecimal 0 "X" x

digitDecimal (n: Nat#): Text
 = case n of
        0       -> "0"
        1       -> "1"
        2       -> "2"
        3       -> "3"
        4       -> "4"
        5       -> "5"
        6       -> "6"
        7       -> "7"
        8       -> "8"
        9       -> "9"
        _       -> "X"


-- | Show a natural number in hex.
showHexNat (x: Nat#): Text
 = showBaseNat    16 digitHex 0 "X" x

digitHex (n: Nat#): Text
 = case n of
        0       -> "0"
        1       -> "1"
        2       -> "2"
        3       -> "3"
        4       -> "4"
        5       -> "5"
        6       -> "6"
        7       -> "7"
        8       -> "8"
        9       -> "9"
        10      -> "a"
        11      -> "b"
        12      -> "c"
        13      -> "d"
        14      -> "e"
        15      -> "f"
        _       -> "X"


-------------------------------------------------------------------------------
-- | Show a natural number using an arbitrary base encoding.
showBaseNat 
        (base:  Nat#)           -- ^ Base of encoding.
        (digit: Nat# -> Text)   -- ^ Show a digit in this base.
        (width: Nat#)           -- ^ Width of output, or 0 to not pad.
        (pad:   Text)           -- ^ Character to pad output with.
        (x:     Nat#)           -- ^ Number to print.
        : Text

 = do   s       = showBaseNat' base digit width pad True x
        if x < 0 
         then "-" % s 
         else s

showBaseNat' base digit width pad first x
 | and (x == 0) first
 = showBaseNat' base digit (width - 1) pad False x
 % "0"

 | and (x == 0) (width > 0)
 = showBaseNat' base digit (width - 1) pad False x
 % pad

 | x == 0
 = ""

 | otherwise
 = showBaseNat' base digit (width - 1) pad False (div x base) 
 % digit (rem x base) 

