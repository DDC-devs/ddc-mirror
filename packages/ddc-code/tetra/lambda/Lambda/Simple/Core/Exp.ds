
module Lambda.Simple.Core.Exp
export
{       show_Decl;      lookupDecl;
        show_Exp;       makeXApps;
}
import Class.Show
import Data.Text
import Data.Tuple
where


-- Name -----------------------------------------------------------------------
-- | Represent names as text.
type Name = Text


-- Decl -----------------------------------------------------------------------
-- | Top-level declaration.
data Decl (p: Data) where
        DTerm   : Name -> Exp p -> Decl p


lookupDecl
        (n: Name)
        (decls: List (Decl p))
        : Maybe (Exp p)
 = case decls of
        Nil             -> Nothing

        Cons (DTerm n' x) ds
         | n == n'      -> Just x
         | otherwise    -> lookupDecl n ds


show_Decl {Show p}: Show (Decl p)
 =  Show $ λdd
 -> case dd of
        DTerm n x
         -> parens $ "DTerm"    %% show n %% show x


-- Exp ------------------------------------------------------------------------
-- | Untyped lambda calculus expressions.
data Exp (p: Data) where
        -- Functional Core.
        XVar    : Name  -> Nat   -> Exp p
        XAbs    : Name  -> Exp p -> Exp p
        XApp    : Exp p -> Exp p -> Exp p

        -- Macro expansion.
        XMacro  : Name  -> Exp p

        -- Primitive values.
        XPrim   : p     -> Exp p


show_Exp {Show p}: Show (Exp p)
 =  Show $ λxx
 -> case xx of
        XVar n b     
         -> parens $ "XVar"   %% show n  %% show b
        
        XAbs n x
         -> parens $ "XAbs"   %% show n  %% show x
        
        XApp x1 x2
         -> parens $ "XApp"   %% show x1 %% show x2

        XMacro n
         -> parens $ "XMacro" %% show n

        XPrim p
         -> parens $ "XPrim"  %% show p


-- | Make an application of a function to the given list of arguments.
makeXApps (xFun: Exp p) (xsArgs: List (Exp p)): Exp p
 = build (reverse xsArgs)
 where  
        build xs
         = case xs of
                Nil             -> xFun
                Cons x1 xsArgs' -> XApp (build xsArgs') x1

