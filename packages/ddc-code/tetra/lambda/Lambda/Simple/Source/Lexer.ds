
module Lambda.Simple.Source.Lexer
export lexTokens
import Lambda.Simple.Source.Token
import Lambda.Simple.Core.Exp
import Control.Parsec
import Class.Show
import Data.Tuple
import Data.Text
where


-- | Lex a sequence of tokens.
lexTokens (cs: List Char): Tup2 (List Token) (List Char)
 = case lexToken cs of
        Nothing                 -> T2 Nil cs
        Just (T2 k cs')  
         -> case lexTokens cs' of
                T2 ks cs''      -> T2 (Cons k ks) cs''


-- | Lex a single token.
lexToken (xx: List Char)
        : Maybe (Tup2 Token (List Char))
 = case xx of
    Nil                 -> Nothing
    Cons c xs
        -- Skip leading whitespace.
        | c == ' '      -> lexToken xs
        | c == '\n'     -> lexToken xs
        | c == '\t'     -> lexToken xs

        -- Punctuation.
        | c == '('      -> Just (T2 KBra    xs)
        | c == ')'      -> Just (T2 KKet    xs)
        | c == '\\'     -> Just (T2 KLambda xs)
        | c == '.'      -> Just (T2 KDot    xs)
        | c == ';'      -> Just (T2 KSemi   xs)
        | c == '='      -> Just (T2 KEquals xs)

        -- Names.
        |  isLower c     
        ,  Just (T2 name          cs')   <- lexName xx
        -> Just (T2 (KName name)  cs')

        |  c == '$'     
        ,  Just (T2 name          cs')   <- lexName xs
        -> Just (T2 (KMacro name) cs')

        | otherwise     -> Nothing


-- | Lex a variable name.
lexName (xx: List Char)
        : Maybe (Tup2 Name (List Char))
 = go Nil xx
 where  
        go acc Nil              
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name Nil

        go acc (Cons x xs)   
         | isLower x
         = go (Cons x acc) xs

         | otherwise            
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name (Cons x xs)

