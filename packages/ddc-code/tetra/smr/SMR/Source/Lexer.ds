
module SMR.Source.Lexer
export lexTokens
import SMR.Source.Token
import SMR.Core.Exp
import System.Posix.Stdlib
import Control.Parsec
import Class.Show
import Data.Tuple
import Data.Text
where


-- | Lex a sequence of tokens.
lexTokens (cs: List Char): Tup2 (List Token) (List Char)
 = case lexToken cs of
        Nothing                 -> T2 Nil cs
        Just (T2 k cs')  
         -> case lexTokens cs' of
                T2 ks cs''      -> T2 (Cons k ks) cs''


-- | Lex a single token.
lexToken (xx: List Char)
        : Maybe (Tup2 Token (List Char))
 = case xx of
    Nil                 -> Nothing
    Cons c xs
        -- Skip leading whitespace.
        | c == ' '      -> lexToken xs
        | c == '\n'     -> lexToken xs
        | c == '\t'     -> lexToken xs

        -- Punctuation.
        |  Just tok     <- lexPunc1 c
        -> Just (T2 tok xs)

        -- Names.
        |  isLower c     
        ,  Just (T2 name          cs')   <- lexName xx
        -> Just (T2 (KName name)  cs')

        -- Macro names.
        |  c == '@'     
        ,  Just (T2 name          cs')   <- lexName xs
        -> Just (T2 (KMacro name) cs')

        -- Primitive names.
        |  c == '#'
        ,  Just (T2 name          cs')   <- lexName xs
        -> Just (T2 (KPrim  name) cs')

        -- Primitive natural numbers.
        |  isDigit c
        ,  Just (T2 nat           cs')   <- lexNat  (Cons c xs)
        -> Just (T2 (KLitNat nat) cs')

        | otherwise     -> Nothing


-- | Lex a punctuation character.
lexPunc1 (c: Char): Maybe Token
 | c == '('     = Just KBra
 | c == ')'     = Just KKet
 | c == '\\'    = Just KLambda
 | c == '.'     = Just KDot
 | c == ';'     = Just KSemi
 | c == '='     = Just KEquals
 | otherwise    = Nothing


-- | Lex a variable name.
lexName (xx: List Char): Maybe (Tup2 Name (List Char))
 = go Nil xx
 where  
        go acc Nil              
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name Nil

        go acc (Cons x xs)   
         | isLower x âˆ¨ x == '-' 
         = go (Cons x acc) xs

         | otherwise            
         = do   name    = textOfCharList (reverse acc)
                Just $ T2 name (Cons x xs)


-- | Lex a natural number.
lexNat (xx: List Char): Maybe (Tup2 Nat (List Char))
 = go Nil xx
 where  
        go acc xs
         | Cons x xs'   <- xs
         , isDigit x
         = go (Cons x acc) xs'

         | otherwise
         = case readNat (textOfCharList (reverse acc)) of
                Nothing         -> Nothing
                Just nat        -> Just $ T2 nat xs

