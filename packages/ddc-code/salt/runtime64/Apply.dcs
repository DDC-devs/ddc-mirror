
 -- Thunk application.
module Runtime.Apply

export value
 ddcRunThunk    : [r1 r2 : Region]. Ptr# r1 Obj -> Ptr# r2 Obj

 ddcApply0      :  [r0 r1 : Region]
                .  Ptr# r0 Obj -> Ptr# r1 Obj

 ddcApply1      :  [r0 r1 r2 : Region]
                .  Ptr# r0 Obj -> Ptr# r1 Obj -> Ptr# r2 Obj

 ddcApply2      :  [r0 r1 r2 r3 : Region]
                .  Ptr# r0 Obj -> Ptr# r1 Obj -> Ptr# r2 Obj -> Ptr# r3 Obj

 ddcApply3      :  [r0 r1 r2 r3 r4 : Region]
                .  Ptr# r0 Obj -> Ptr# r1 Obj -> Ptr# r2 Obj -> Ptr# r3 Obj 
                -> Ptr# r4 Obj

 ddcApply4      :  [r0 r1 r2 r3 r4 r5 : Region]
                .  Ptr# r0 Obj -> Ptr# r1 Obj -> Ptr# r2 Obj -> Ptr# r3 Obj 
                -> Ptr# r4 Obj -> Ptr# r5 Obj

import value
 ddcAllocThunk  : [r1    : Region]. Addr# -> Nat# -> Nat# -> Nat# -> Nat# -> Ptr# r1 Obj
 ddcCopyThunk   : [r1 r2 : Region]. Ptr# r1 Obj -> Ptr# r2 Obj -> Nat# -> Nat# -> Ptr# r2 Obj
 ddcExtendThunk : [r1 r2 : Region]. Ptr# r1 Obj -> Nat# -> Ptr# r2 Obj

 ddcFunThunk    : [r1    : Region]. Ptr# r1 Obj -> Addr#
 ddcParamsThunk : [r1    : Region]. Ptr# r1 Obj -> Nat#
 ddcBoxesThunk  : [r1    : Region]. Ptr# r1 Obj -> Nat#
 ddcArgsThunk   : [r1    : Region]. Ptr# r1 Obj -> Nat#
 ddcRunsThunk   : [r1    : Region]. Ptr# r1 Obj -> Nat#

 ddcSetThunk    : [r1 r2 : Region]. Ptr# r1 Obj -> Nat# -> Nat# -> Ptr# r2 Obj -> Void#
 ddcGetThunk    : [r1 r2 : Region]. Ptr# r1 Obj -> Nat# -> Ptr# r2 Obj

with letrec


-------------------------------------------------------------------------------
-- | Run a thunk.
--   If this is the last run the evaluate it, 
--   otherwise increment the run count.
--
ddcRunThunk 
        [r1 r2 : Region]
        (src   : Ptr# r1 Obj) : Ptr# r2 Obj
 = do   
        boxes   = ddcBoxesThunk src
        case boxes of

         -- The thunk is not boxed,
         -- so running it would be a type error.
         0# ->  fail#

         -- We don't know what region the result is going to be allocated
         -- into, so need to assign it to rT.
         1# ->  ddcEval0 src

         _ -> do
                fun     = ddcFunThunk    src
                params  = ddcParamsThunk src
                args    = ddcArgsThunk   src
                runs'   = add# (ddcRunsThunk src) 1#

                dst     = ddcAllocThunk [r2] fun params boxes args runs'
                ddcCopyThunk src dst 0# args


-------------------------------------------------------------------------------
-- The apply family of functions work out how call the function in a thunk.
-- Some arguments come from in the thunk itself, while some can be provided
-- directly to the evaluators.
--
-- The hard limits are:
--   - The maximum arity for the function in a thunk is 12. 
--     See the comment on applyZ.
--   - The maximum number of directly applied arguments is 4, 
--     because we only have apply0 - apply4.
--
-- The choice of where to set the limit is a balance between being able to 
-- enumerate all possible calling conventions, and polluting the instruction
-- cache with code for too many evaluators.
--

----------------------------------------------------------- 0
-- | Apply (evaluate) a thunk, given no more arguments.
ddcApply0 [r0 r1 : Region]
          (t : Ptr# r0 Obj) : Ptr# r1 Obj
 = do
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        b       = ddcBoxesThunk  t
        r       = ddcRunsThunk   t
        case mul# (eq# a p) (eq# b r) of
         True#  -> ddcEval0 t
         False# -> makePtr# (takePtr# t)


-- | Evaluate a saturated thunk, give no more arguments.
ddcEval0  [r0 r1 : Region]
          (t     : Ptr# r0 Obj) : Ptr# r1 Obj
 = do   
        f       = ddcFunThunk    t 
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        case p of
         0# -> ddcCallP0 f

         1# -> ddcCallP1 f      (ddcGetThunk t 0#)

         2# -> ddcCallP2 f      (ddcGetThunk t 0#) (ddcGetThunk t 1#)

         3# -> ddcCallP3 f      (ddcGetThunk t 0#) (ddcGetThunk t 1#) 
                                (ddcGetThunk t 2#) 

         4# -> ddcCallP4 f      (ddcGetThunk t 0#) (ddcGetThunk t 1#) 
                                (ddcGetThunk t 2#) (ddcGetThunk t 3#)

         _  -> ddcEvalZ t f p   (ddcGetThunk t (sub# a 4#))
                                (ddcGetThunk t (sub# a 3#))
                                (ddcGetThunk t (sub# a 2#))
                                (ddcGetThunk t (sub# a 1#))


----------------------------------------------------------- 1
-- | Apply a thunk to one more argument.
ddcApply1 [r0 r1 r2 : Region] 
          (t : Ptr# r0 Obj) (arg1 : Ptr# r1 Obj)
          : Ptr# r2 Obj
 = do
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        b       = ddcBoxesThunk  t
        r       = ddcRunsThunk   t

        case mul# (eq# (add# a 1#) p) (eq# b r) of { 
        True# ->
                ddcEval1 t arg1;

        False# ->
        do      t' = ddcExtendThunk t 1#
                ddcSetThunk t' a 0# arg1
                t'
        }

-- | Evaluate a saturated thunk, given one more argument.
ddcEval1  [r0 r1 r2 : Region] 
          (t : Ptr# r0 Obj) (arg1 : Ptr# r1 Obj) 
          : Ptr# r2 Obj
 = do   
        f       = ddcFunThunk    t
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        case p of
         0# -> ddcApply1 (ddcCallP0 f) arg1

         1# -> ddcCallP1 f             arg1

         2# -> ddcCallP2 f             (ddcGetThunk t 0#)  arg1

         3# -> ddcCallP3 f             (ddcGetThunk t 0#) (ddcGetThunk t 1#) 
                                        arg1

         4# -> ddcCallP4 f             (ddcGetThunk t 0#) (ddcGetThunk t 1#)
                                       (ddcGetThunk t 2#)  arg1

         _  -> ddcEvalZ t f p          (ddcGetThunk t (sub# a 3#))
                                       (ddcGetThunk t (sub# a 2#))
                                       (ddcGetThunk t (sub# a 1#))
                                        arg1


----------------------------------------------------------- 2
ddcApply2 [r0 r1 r2 r3 : Region]
          (t    : Ptr# r0 Obj) 
          (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
          : Ptr# r3 Obj
 = do   
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        b       = ddcBoxesThunk  t
        r       = ddcRunsThunk   t

        case eq#  (add# a 1#) p of { True# ->
                ddcApply1 (ddcEval1 t arg1) arg2;

        False# ->
        case mul# (eq# (add# a 2#) p) (eq# b r) of { True# ->
                ddcEval2 t arg1 arg2;  

        False# ->
        do      t' = ddcExtendThunk t 2#
                ddcSetThunk t' a 0# arg1
                ddcSetThunk t' a 1# arg2
                t'
        }}


-- | Evaluate a saturated thunk, given two more arguments.
ddcEval2 [r0 r1 r2 r3 : Region]
         (t    : Ptr# r0 Obj)
         (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
         : Ptr# r3 Obj
 = do   
        f       = ddcFunThunk      t
        p       = ddcParamsThunk   t
        a       = ddcArgsThunk     t
        case p of
         0# -> ddcApply2 (ddcCallP0 f)  arg1  arg2

         1# -> ddcApply1 (ddcCallP1 f   arg1) arg2

         2# -> ddcCallP2 f              arg1  arg2

         3# -> ddcCallP3 f             (ddcGetThunk t 0#)  
                                        arg1  arg2

         4# -> ddcCallP4 f             (ddcGetThunk t 0#) (ddcGetThunk t 1#)
                                        arg1  arg2

         _  -> ddcEvalZ  t f p         (ddcGetThunk t (sub# a 2#))
                                       (ddcGetThunk t (sub# a 1#))
                                        arg1  arg2


----------------------------------------------------------- 3
-- | Apply a thunk to three more arguments.
ddcApply3 [r0 r1 r2 r3 r4 : Region] 
          (t    : Ptr# r0 Obj)
          (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
          (arg3 : Ptr# r3 Obj)
          : Ptr# r4 Obj
 = do
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        b       = ddcBoxesThunk  t
        r       = ddcRunsThunk   t

        case eq#  (add# a 2#) p of { True# ->
                ddcApply1 (ddcEval2 t arg1  arg2) arg3;

        False# ->
        case eq#  (add# a 1#) p of { True# ->
                ddcApply2 (ddcEval1 t arg1) arg2  arg3;

        False# ->
        case mul# (eq# (add# a 3#) p) (eq# b r) of { True# ->
                ddcEval3 t arg1 arg2 arg3;

        False# ->
        do      t' = ddcExtendThunk t 3#
                ddcSetThunk t' a 0# arg1
                ddcSetThunk t' a 1# arg2
                ddcSetThunk t' a 2# arg3
                t'
        }}}


-- | Evaluate a saturated thunk, given three more arguments.
ddcEval3 [r0 r1 r2 r3 r4 : Region]
         (t    : Ptr# r0 Obj)
         (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
         (arg3 : Ptr# r3 Obj)
         : Ptr# r4 Obj
 = do   
        f       = ddcFunThunk    t
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        case p of
         0# -> ddcApply3 (ddcCallP0 f) arg1  arg2  arg3

         1# -> ddcApply2 (ddcCallP1 f  arg1) arg2  arg3

         2# -> ddcApply1 (ddcCallP2 f  arg1  arg2) arg3

         3# -> ddcCallP3 f             arg1  arg2  arg3

         4# -> ddcCallP4 f            (ddcGetThunk t 0#) 
                                       arg1  arg2  arg3

         _  -> ddcEvalZ  t f p        (ddcGetThunk t (sub# a 1#))
                                       arg1  arg2  arg3


----------------------------------------------------------- 4
-- | Apply a thunk to four more arguments.
ddcApply4 [r0 r1 r2 r3 r4 r5 : Region]
          (t    : Ptr# r0 Obj)
          (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
          (arg3 : Ptr# r3 Obj) (arg4 : Ptr# r4 Obj) 
          : Ptr# r5 Obj
 = do
        p       = ddcParamsThunk t
        a       = ddcArgsThunk   t
        b       = ddcBoxesThunk  t
        r       = ddcRunsThunk   t

        case eq# (add# a 3#) p of { True# ->
                ddcApply1 (ddcEval3 t arg1  arg2  arg3) arg4;

        False# ->
        case eq# (add# a 2#) p of { True# ->
                ddcApply2 (ddcEval2 t arg1  arg2) arg3  arg4;

        False# ->
        case eq# (add# a 1#) p of { True# ->
                ddcApply3 (ddcEval1 t arg1) arg2  arg3  arg4;

        False# ->
        case mul# (eq# (add# a 4#) p) (eq# b r) of { True# ->
                ddcEval4 t arg1 arg2 arg3 arg4;

        False# ->
        do      t' = ddcExtendThunk t 4#
                ddcSetThunk t' a 0# arg1
                ddcSetThunk t' a 1# arg2
                ddcSetThunk t' a 2# arg3
                ddcSetThunk t' a 3# arg4
                t'
        }}}}


-- | Evaluate a saturated thunk, given four more arguments.
ddcEval4  [r0 r1 r2 r3 r4 r5 : Region]
          (t    : Ptr# r0 Obj)
          (arg1 : Ptr# r1 Obj) (arg2 : Ptr# r2 Obj)
          (arg3 : Ptr# r3 Obj) (arg4 : Ptr# r4 Obj)
          : Ptr# r5 Obj
 = do   
        f       = ddcFunThunk    t
        p       = ddcParamsThunk t
        case p of
         0# -> ddcApply4 (ddcCallP0 f) arg1  arg2  arg3  arg4

         1# -> ddcApply3 (ddcCallP1 f  arg1) arg2  arg3  arg4

         2# -> ddcApply2 (ddcCallP2 f  arg1  arg2) arg3  arg4

         3# -> ddcApply1 (ddcCallP3 f  arg1  arg2  arg3) arg4

         4# -> ddcCallP4 f             arg1  arg2  arg3  arg4

         _  -> ddcEvalZ  t f p         arg1  arg2  arg3  arg4


----------------------------------------------------------- Z
-- Evaluate a saturated thunk, given its last 4 arguments.
-- We read the first (n-4) arguments directly from the thunk.
--
-- In the object code, this function serves to enumerate the function calling
-- conventions for functions of 4-12 parameters. The fact that it stops at 12
-- places a hard limit on the arity of the core programs that we're prepared
-- to compile. Supers higher than this arity need to be transformed to take
-- some of their arguments from a tuple instead of as direct parameters.
--
-- In terms of the generated object program, we don't want to add more
-- alternatives here anyway because the underlying machine is unlikely to have
-- good calling convention when the object function has > 12 arguments. It
-- isn't useful for the 'arity' here to be more than the number of general
-- purpose registers we're likely to have in the machine. 
-- 
-- Note that some registers will also be needed for the stack pointer etc.
-- If the machine has 16 general purpose registers, then setting the maximum
-- arity here to 12 is probably enough.
--
ddcEvalZ [r0 r1 r2 r3 r4 r5 : Region]
         (t : Ptr# r0 Obj) (fun : Addr#) (arity : Nat#)
         (argL3 : Ptr# r1 Obj) (argL2 : Ptr# r2 Obj)
         (argL1 : Ptr# r3 Obj) (argL0 : Ptr# r4 Obj)
         : Ptr# r5 Obj

 = do   argA3   = takePtr# argL3
        argA2   = takePtr# argL2
        argA1   = takePtr# argL1
        argA0   = takePtr# argL0

        case arity of
         4#  -> makePtr# (call4#  fun
                                argA3 argA2 argA1 argA0)

         5#  -> makePtr# (call5#  fun
                                (ddcGetThunkA t 0#) 
                                argA3 argA2 argA1 argA0)

         6#  -> makePtr# (call6#  fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                argA3 argA2 argA1 argA0)

         7#  -> makePtr# (call7#  fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#)
                                argA3 argA2 argA1 argA0)

         8#  -> makePtr# (call8#  fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#) (ddcGetThunkA t 3#)
                                argA3 argA2 argA1 argA0)

         9#  -> makePtr# (call9#  fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#) (ddcGetThunkA t 3#)
                                (ddcGetThunkA t 4#)
                                argA3 argA2 argA1 argA0)

         10# -> makePtr# (call10# fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#) (ddcGetThunkA t 3#)
                                (ddcGetThunkA t 4#) (ddcGetThunkA t 5#)
                                argA3 argA2 argA1 argA0)

         11# -> makePtr# (call11# fun
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#) (ddcGetThunkA t 3#)
                                (ddcGetThunkA t 4#) (ddcGetThunkA t 5#)
                                (ddcGetThunkA t 6#)
                                argA3 argA2 argA1 argA0)

         12# -> makePtr# (call12# fun    
                                (ddcGetThunkA t 0#) (ddcGetThunkA t 1#)
                                (ddcGetThunkA t 2#) (ddcGetThunkA t 3#)
                                (ddcGetThunkA t 4#) (ddcGetThunkA t 5#)
                                (ddcGetThunkA t 6#) (ddcGetThunkA t 7#)
                                argA3 argA2 argA1 argA0)

         _   -> fail#


ddcCallP0  [r1 : Region]
        (f  : Addr#) : Ptr# r1 Obj
 = makePtr# (call0# f)

ddcCallP1  [r1 r2 : Region]
        (f  : Addr#) 
        (a1 : Ptr# r1 Obj) 
        : Ptr# r2 Obj 
 = makePtr# (call1# f (takePtr# a1))

ddcCallP2  [r1 r2 r3 : Region]
        (f  : Addr#) 
        (a1 : Ptr# r1 Obj) (a2 : Ptr# r2 Obj)
        : Ptr# r3 Obj 
 = makePtr# (call2# f (takePtr# a1) (takePtr# a2))

ddcCallP3  [r1 r2 r3 r4 : Region]
        (f  : Addr#) 
        (a1 : Ptr# r1 Obj) (a2 : Ptr# r2 Obj) (a3 : Ptr# r3 Obj)
        : Ptr# r4 Obj 
 = makePtr# (call3# f (takePtr# a1) (takePtr# a2) (takePtr# a3))

ddcCallP4  [r1 r2 r3 r4 r5 : Region]
        (f  : Addr#) 
        (a1 : Ptr# r1 Obj) (a2 : Ptr# r2 Obj) (a3 : Ptr# r3 Obj) (a4 : Ptr# r4 Obj)
        : Ptr# r5 Obj 
 = makePtr# (call4# f (takePtr# a1) (takePtr# a2) (takePtr# a3) (takePtr# a4))


-- | Like `getThunk`, but convert the result to a raw address.
ddcGetThunkA
        [r1 : Region]
        (obj   : Ptr# r1 Obj) (index : Nat#) : Addr#
 =      read#  (takePtr# obj)
               (add# 16# (shl# index (size2# [Addr#])))

