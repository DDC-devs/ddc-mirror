
-- | The Garbage Collector
module Collect

export value

  ddcCollectHeap 
        :  Addr# -- ^ Start of root chain.
        -> Addr# -- ^ @Word**@  From Base -- first byte in from space.
        -> Addr# -- ^ @Word**@  From Top  -- addr of next byte to be allocated.
        -> Addr# -- ^ @Word**@  From Max  -- addr of last byte that can be allocated.
        -> Addr# -- ^ @Word**@  To   Base -- first byte that can be allocated.
        -> Addr# -- ^ @Word**@  To   Top  -- addr of next byte to be allocated (during evac)
        -> Addr# -- ^ @Word**@  To   Max  -- addr of last byte that can be allocated.
        -> Unit

import foreign c value
  malloc              : Nat# -> Addr#

  ddcFormatOfObject   : [r     : Region]. Ptr# r  Obj -> Nat#
  ddcSizeOfObject     : [r     : Region]. Ptr# r  Obj -> Nat#

  ddcReadBrokenHeart  : [r1 r2 : Region]. Ptr# r1 Obj -> Ptr# r2 Obj
  ddcWriteBrokenHeart : [r1 r2 : Region]. Ptr# r1 Obj -> Ptr# r2 Obj -> Void#

  ddcIsAnchored       : [r     : Region]. Ptr# r  Obj -> Bool#

  ddcArgsThunk        : [r     : Region]. Ptr# r  Obj -> Nat#
  ddcGetThunk         : [r     : Region]. Ptr# r  Obj -> Nat# -> Addr#

  ddcArityOfBoxed     : [r     : Region]. Ptr# r  Obj -> Nat#
  ddcGetBoxed         : [r1 r2 : Region]. Ptr# r1 Obj -> Nat# -> Ptr# r2 Obj

  ddcArityOfMixed     : [r     : Region]. Ptr# r  Obj -> Nat#
  ddcGetMixed         : [r1 r2 : Region]. Ptr# r1 Obj -> Nat# -> Ptr# r2 Obj

  ddcTraceAlloc  
        :  Bool# -> Addr#
        -> Addr# -> Addr# -> Addr#
        -> Addr# -> Addr# -> Addr#
        -> Unit

  ddcTraceObj         : Bool# -> Bool# -> Addr# -> Nat#
  ddcTraceRoots       : Bool# -> Unit

  ddcLlvmRootIsEnd       : Addr# -> Bool#

  primPutString       : TextLit# -> Void#
  primShowAddr        : Addr#    -> TextLit#
  primShowNat         : Nat#     -> TextLit#
  primShowWord32      : Word32#  -> TextLit#

  exit                : Int# -> Void#

with letrec


-- | Perform a collection on on this heap.
--   This is a simple Cheney-scan collection.
ddcCollectHeap
        (aRootStart                      : Addr#)
        (aaHeapBase aaHeapTop aaHeapMax  : Addr#)
        (aaBackBase aaBackTop aaBackMax  : Addr#) : Unit
 = do
        primPutString "* ddc-runtime.ddcCollectHeap start\n"#

        -- Trace the allocator state before we start.
        ddcTraceAlloc
                False#
                aRootStart
                aaHeapBase aaHeapTop aaHeapMax
                aaBackBase aaBackTop aaBackMax

        -- Evacuate all the root objects to the to-space.
        ddcEvacuateRoots
                aRootStart
                (read# aaBackBase 0#)
                aaBackTop 
                (read# aaBackMax  0#)

        -- Recursively follow pointers in to-space,
        --   copying out any reachable objects in the from-space.
        ddcScanHeap 
                (read# aaBackBase 0#)
                (read# aaBackTop  0#)

        primPutString "* ddc-runtime.ddcCollectHeap end\n"#

{-
        ddcTraceAlloc 
                True#
                pRootStart
                ppHeapBase ppHeapTop ppHeapMax
                ppBackBase ppBackTop ppBackMax
-}

        exit 0i#
        ()

        -- Update collection counter
        -- _PROFILE_GC (count++);

        -- Check sanity again now the GC is finished.
        -- _DEBUG(_lintHeap  (heapBackBase, *heapBackPtr));
        -- _DEBUG(_lintSlots (_ddcSlotBase, _ddcSlotPtr, heapBackBase, *heapBackPtr));



-- | Recursively follow pointers in the to-space, copying
--   out any reachable objects in the from-space.
ddcEvacuateRoots
        (aRootStart     : Addr#)
        (aBackBase      : Addr#)
        (aaBackTop      : Addr#)
        (aBackMax       : Addr#) : Unit
 = do
        primPutString "* ddc-runtime.ddcEvacutateRoots\n"#

        ddcEvacuateStackEntry
                aaBackTop
                aRootStart

        ()

-- | Evacuate the roots from the given stack entry.
ddcEvacuateStackEntry
        (aaBackTop      : Addr#)
        (aEntry         : Addr#) : Unit
 = do
        -- Address of next entry in the chain.
        aEntryNext      = read#     aEntry       0#

        -- Address of frame that hold the number of roots, and meta-data.
        aEntryFrame     = read#     aEntry            (size# [Addr#])

        -- Address of array of roots for this frame.
        aEntryRoots     = plusAddr# aEntry      (add# (size# [Addr#]) (size# [Addr#]))

        -- Number of roots without meta-data in the frame.
        numRoots        = read#     aEntryFrame  0#

        -- Number of roots with meta-data in the frame.
        numMeta         = read#     aEntryFrame (size# [Word32#])

        -- Print the current stack entry.
        primPutString "Entry\n"#
        fieldAddr     "{ pEntry      = "# aEntry
        fieldAddr     "  pEntryNext  = "# aEntryNext
        fieldAddr     "  pEntryFrame = "# aEntryFrame
        fieldAddr     "  pEntryRoots = "# aEntryRoots
        fieldWord32   "  numRoots    = "# numRoots
        fieldWord32   "  numMeta     = "# numMeta

        ddcEvacuateRootFrame 
                aaBackTop
                aEntryRoots
                0#
                (promote# numRoots)

        -- If we have not reached the end of the chain then go
        -- to the next frame.
        case ddcLlvmRootIsEnd aEntryNext of
         True#  -> ()
         False# -> ddcEvacuateStackEntry aaBackTop aEntryNext


-- Evacuate all the roots in the given stack frame.
ddcEvacuateRootFrame 
        (aaBackTop:     Addr#)  -- Top of back heap.
        (aaObj:         Addr#)  -- Current address in frame.
        (ix:            Nat#)   -- Number of roots evacuated so far.
        (n:             Nat#)   -- Total number of roots to evacuate.
        : Unit
 = case sub# n ix of
    0#  -> ()
    _   -> do
        ddcEvacuateRoot 
                aaBackTop
                aaObj

        ddcEvacuateRootFrame
                aaBackTop
                (plusAddr# aaObj (size# [Addr#]))
                (add# ix 1#)
                n


-- Evacuate the object pointed to by a single root.
ddcEvacuateRoot
        (aaBackTop:     Addr#)
        (aaObj:         Addr#)
        : Unit
 = do
        -- Read the pointer to the object from the root slot.
        aObj    = read# aaObj 0#

        -- Skip slot stack values that have been assigned null values.
        case eq# aObj (promote# 0#) of
         True#  -> ()
         False# 
          -> do 
                -- Evacuate an object, returning its new address in the to-space.
                aObjNew = ddcEvacuateObject aaBackTop aObj

                -- Update the slot entry to point to the new location.
                write# aaObj 0# aObjNew

                primPutString "* ddcEvacuateRoot\n"#
                fieldAddr     "  aObj        = "# aObj
                fieldAddr     "  aObjNew     = "# aObjNew

                ()


-- | Evacuate a single object and update the to-space
--   to point to the word _after_ the new copy.
ddcEvacuateObject
        (aaBackTop      : Addr#)
        (aObj           : Addr#)
                        : Addr#
 = do
        pObj    = makePtr# aObj
        format  = ddcFormatOfObject pObj

        -- If this object is a broken heart then return the forwarding pointer.
        --   We have a "broken heart" because the object we were expecting
        --   to be here has aready been copied out to the to-space. The old 
        --   header in the from-space will have been over-written by the
        --   address of where it is now in the to-space.
        case format of 
         1# -> do       pNewObj0 = ddcReadBrokenHeart (makePtr# aObj)
                        takePtr# pNewObj0

         _  -> case ddcIsAnchored (makePtr# aObj) of
                -- If the object is anchored then leave it alone.
                --   Anchored objects are allocated outside of our heap,
                --   and are outside our juristiction.
                True# 
                 ->     aObj

                -- This is a real object in the from-space,
                -- so evacuate it to the to-space.
                False#
                 ->     ddcEvacuateCopy aaBackTop aObj 


-- | Copy a single object from the from-space to the to-space.
ddcEvacuateCopy 
        (aaBackTop      : Addr#)
        (aObj           : Addr#)
                        : Addr#

 = do   -- Get the size of the whole object.
        size    = ddcSizeOfObject (makePtr# aObj)

        -- Where we're going to copy it to in the to-space.
        aObjNew = read# aaBackTop 0#

        -- Copy the sucker.
        copy# aObjNew aObj size

        -- Advance the to-pointer to point to the first byte of
        -- where the next object could be copied to.
        write# aaBackTop 0# (plusAddr# aObjNew size)

        -- Overwrite the object header with a broken heart.
        --   This records the fact that we've copied the object,
        --   so if we come back here again we'll know where it's gone.
        ddcWriteBrokenHeart (makePtr# aObj) (makePtr# aObjNew)

        aObjNew


-- Scan functions -------------------------------------------------------------
--   "Scanning" means to look at the other objects this one points to and also
--   copy those to the to-space.
--
--   There is one scan function for each object format in the heap.

-- | Scan all the objects in the to space.
--     This copies in the data that is reachable from the object already there.
ddcScanHeap
        (pScanA     : Addr#)
        (ppBackTopA : Addr#)
                    : Unit
 = do
        pBackTopA       = read# ppBackTopA 0#

        case ge# pScanA pBackTopA of
          True#  -> ()
          False# -> do
            pScan       = makePtr# pScanA

            ddcScanObject pScan ppBackTopA
            pScanA'     = plusAddr# pScanA (ddcSizeOfObject pScan)

            ddcScanHeap pScanA' ppBackTopA


-- | Scan an arbitrary object.
--   This examines the tag of the object to determine what sort it is, then
--   calls the scan function specific to that object.
ddcScanObject
        [r          : Region]
        (pObj       : Ptr# r Obj)
        (ppBackTopA : Addr#)
                    : Unit
  =     case ddcFormatOfObject pObj of
          0# -> fail#   -- unknown object.
          1# -> fail#   -- broken heart.
          2# -> ddcScanThunk pObj ppBackTopA
          3# -> ddcScanBoxed pObj ppBackTopA
          4# -> ()      -- raw data contains no pointers to scan.
          5# -> ddcScanMixed pObj ppBackTopA
          6# -> ()      -- small raw data contains no pointers to scan.
       -- 7# -> ???     -- ISSUE #341: SuspIndir not implemented
          _  -> fail#   -- invalid format


-- | Scan a thunk.
ddcScanThunk
        [r          : Region]
        (pObj       : Ptr# r Obj)
        (ppBackTopA : Addr#)
                    : Unit
 =      ddcScanThunk_arg pObj (ddcArgsThunk pObj) ppBackTopA

-- | Scan a thunk argument.
ddcScanThunk_arg
        [r             : Region]
        (pObj          : Ptr# r Obj)
        (argsRemaining : Nat#)
        (ppBackTopA    : Addr#)
                       : Unit
 = do
        primPutString "* scan thunk\n"#

        case eq# argsRemaining 0# of
          True#  -> ()
          False# -> do
            argIx   = sub# argsRemaining 1#
            pFieldA = ddcGetThunk pObj argIx

            ddcEvacuateObject pFieldA ppBackTopA

            ddcScanThunk_arg pObj argIx ppBackTopA


-- | Scan a boxed data object.
ddcScanBoxed
        [r          : Region]
        (pObj       : Ptr# r Obj)
        (ppBackTopA : Addr#)
                    : Unit
 =      ddcScanBoxed_arg pObj (ddcArityOfBoxed pObj) ppBackTopA

-- | Scan a boxed argument.
ddcScanBoxed_arg
        [r             : Region]
        (pObj          : Ptr# r Obj)
        (argsRemaining : Nat#)
        (ppBackTopA    : Addr#)
                       : Unit
 = do
        primPutString "* scan boxed\n"#

        case eq# argsRemaining 0# of
          True#  -> ()
          False# -> do
            argIx   = sub# argsRemaining 1#
            pFieldA = takePtr# (ddcGetBoxed pObj argIx)

            ddcEvacuateObject pFieldA ppBackTopA

            ddcScanBoxed_arg pObj argIx ppBackTopA


-- | Scan a mixed data object.
ddcScanMixed
        [r          : Region]
        (pObj       : Ptr# r Obj)
        (ppBackTopA : Addr#)
                    : Unit
 =      ddcScanMixed_arg pObj (ddcArityOfMixed pObj) ppBackTopA

-- | Scan a boxed argument.
ddcScanMixed_arg
        [r             : Region]
        (pObj          : Ptr# r Obj)
        (argsRemaining : Nat#)
        (ppBackTopA    : Addr#)
                       : Unit
 = do
        case eq# argsRemaining 0# of
          True#  -> ()
          False# -> do
            argIx   = sub# argsRemaining 1#
            pFieldA = takePtr# (ddcGetMixed pObj argIx)

            ddcEvacuateObject pFieldA ppBackTopA

            ddcScanMixed_arg pObj argIx ppBackTopA


---------------------------------------------------------------------------------------------------
-- | Print an Addr# field to stdout.
fieldAddr (name: TextLit#) (val: Addr#): Void#
 = do   primPutString name
        primPutString (primShowAddr val)
        primPutString ";\n"#


-- | Print a Nat# field to stdout.
fieldNat (name: TextLit#) (val: Nat#): Void#
 = do   primPutString name
        primPutString (primShowNat val)
        primPutString ";\n"#


-- | Print a Word32# field to stdout.
fieldWord32 (name: TextLit#) (val: Word32#): Void#
 = do   primPutString name
        primPutString (primShowWord32 val)
        primPutString ";\n"#

            