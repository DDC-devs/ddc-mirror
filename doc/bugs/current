------------------------------------------------------------------------------------
-- INCOMING bugs
------------------------------------------------------------------------------------

2007/5/6.3
*	Might want to optimise type graph by eliminating CFowards.
		.. though this would reuse classids at different types
		.. make sure all classIds are updated.

2007/5/6.2
*	Make fetters a different sort of equivalence class in Type.Base.Class


2007/5/6.1
*	Desugar.Slurp.Util.makeCtorType
	closure information is wrong.

2007/4/19.1
*	Is refreshing monomorphic vars safe, considering sink eliminates effect
	masking constructors?
	
	If we eliminate the TMask too early, perhaps an effect unified into 
	the RHS will no longer be masked?
	

2007/4/14.4
*	Revisit Var.Info. 
	Have put sourcepos on Source.Exp and Constraints.
	Do we really need to carry around this extra list as well?

2007/4/14.3
*	Lint source, check that all nodes in source tree have valid source positions.

2007/4/13.3
*	Collect effects generate by cafs.
	We probably want to disallow effects in cafs.

2007/4/13.2
*	Write a real Type.Unify and use it for Type.Bits.crushTMask

2007/4/13.1
*	Redo threading of parent classes in Type.Feed


2007/4/12.1
*	Lint type graph.
	Check all constructors have Type Source information attached
	Check kinds of data
	Check backrefs.
	

2007/4/1.4
*	Desugar.Project
	Check that constructed projection functions have the correct effect/closure info

2007/4/1.3
*	Desugar.Slurp.Slurp
	Constraint slurper doen't decent into expresison part of class definitions.
	

2007/4/1.2
*	Ditch Constraint.Sequence, Constraint.Degen
	-- don't use these anymore, solve handles it directly.


2007/3/31.1
*	Desugar.Slurp.Util.makeCtorType
	Closure information for Constructor types is wrong.
		This will break if we partially apply a constructor.


2007/3/30.1
* 	Shape constraints aren't getting crushed out properly.

	this works
	fun2 x y z = x + y + z + 1;
	
	but this doesn't
	fun2 x y z = x + y + 1 + z;


h2007/3/27.1
* Merge Core.Slurp.slurpTypeX and maybeSlurpTypeX

2007/3/26.1
* Don't flatten out effects/closures so early
	have 	
		$e1 = !{ !Read %r1}
		$e2 = !{ !e1; !Read %r2 }
		
	instead of
		$e1 = !{ !Read %r1}
		$e2 = !{ !Read %r1; !Read %r2 }


2007/3/26.1
* C code variable name clashes
	see bug in library/Graphics/Bressenham


2007/2/26.4
* Merge all the regions with the same mode at one level.
	Can use this to have segmented heaps. Reduce amount of copying / pause times.
	Regions lower down are totally invisible to higher up.
	But lower can still allocate data into higher.
	Alloc effects. 
	
	Check if a fn is going to allocate anything into this region.


2007/2/26.3
* Fixup Ditch for conversion to sea
	Change core data type kinds so region mutability information is local
	
	Int %m %d
		
	Change type annotations to operational types.
	Generate const qualifier on C side.
	Move field labels -> numbers here
	

2007/2/26.2
* Fix up driver.
	Change order of stages so lambda lifting isn't last

	Lambda lift
	prim
	boxing
	
	Defer generation of operational types until ditch 


2007/2/16.12
* Pass Mutable / Const witnesses around in core


2007/2/16.14
* Core Lint
	Do all type applications and make sure types work out.


2007/2/18.4
* work nbody and gfx compilation into tests
	add support for compilation scripts to war
	step nbody a few times and dump out forces to file, use this as the test.


2007/2/19.3
* Allow definition of top level regions.
	Allow cafs to be exported from modules.
	top level value definitions, ala pi.


2007/2/19.2
* Source dependencies / make
	Implement recursive make, should compile required modules first.
	Also, be able to supply a list of sources and have them compiled
	in the correct order.


2007/2/19.4
* Implement negative numeric literals.


2007/2/16.5
* Make sure main function has the correct type
		main :: () -> a;
	
	if main is defined as
		main = do { ... }; 
	
	without matching first arg then it seems to run twice.
	type badness.	


2007/2/16.3
* Vars don't shadow properly
	
	fun ()
	 = do {	length = ....;
	 	length;				-- conflicts with top level length function.
	 };
		
		
2007/2/16.1
* Scheme ordering for projections is broken
	Types for projection functions aren't being inferred in the right order.
	Sometimes try to instantiate a scheme before it has been generalised. 


2007/2/18.3
* pragma include silently discards arg if its not a list
	do some type checking!


2007/2/18.2 
* nbody doesn't compile if OptFullLaziness is turned on.


2007/2/19.1
* Finish projections
	Make sure you can merge projection dicts from multiple modules.
	Make sure you can reuse field labels for different types.
	Check the scheme ordering code.
	Check can provide own field projections.
	Write unit tests.
	

2007/2/16.17
* Finish pattern matching
	Wild cards in patterns.
	Make sure case can handle full patterns
	Multiple bindings, merge into match expression
	More tests.
	

2007/2/16.8
* Allow unboxed values to be retuned from functions
	! workarounds in System.File

2007/2/16.7
* Improve elaboration mechanism so we can elaborate a type for the File functions
	should be able to provide types for fopenU, freadU etc in a less painful way

	fopenU :: elaborate. String# -> String# -(!File)> Ptr# FILE#;

	freadU 	:: elaborate
		.  write  String# 
		-> read	  Int32# 
		-> read	  Int32# 
		-> read	  Ptr# FILE# 
		-(!File)> Int32#;
	
	fun 	:: elaborate
		.  read		Int32#
		-> write 	String# %r1
		-(!File)> (String# %r1, String# %r1);
		
	dude	:: shared a. a -> a;
	
	auto elaborate foreign defs?
		but use elaborate keyword internally?
		
	add . for elaborate.
	
	read/write annotations similar to C#
		calls them in/out?
		
	auto quantify unless have shared directive
		shared TREC.
		
	Assume arg regions are read.
	Write elaborated types into interface file.
	
	Also include closure information.
	Closure, assume each is used in final effect.
	
	What to do about args which are not read.
	
	

2007/2/16.6
* Provide unsafe unboxed casting operations
	as in System.File
	

2007/2/15.2
* String unboxing.
	String unboxing isn't safe.
	String exists inside the heap allocated object.
	
	Useful for writing foreign bindings, but not safe in general.
	change unboxing function to unsafe_

	Provide other unboxing function which copies it out into the C heap.
	Would also need a free function so it can be freed when done.


2007/2/15.1
* Prevent unboxed data being free in closures.
	This isn't possible, can't create a thunk with free unboxed data.
	should check for this and rejet the program.
	
	fun ()
	 = do {
	 	dude	= 100#;
		f	= (\t -> dude + #100);
	 	f;
	 };


2007/2/14.1
* Check defixer
	
	a <= b && b <= d 
	
	should work, even though <= is non-assoc.
	<= is higher priority than &&
	

--------------------------------------------------------------------------------
-- JOBS that need doing
--------------------------------------------------------------------------------

2007/4/1.6
* Revisit TQuant and friends
	The renamer should just rename, not rewrite TQuants to TForalls as it runs through.

2007/4/1.5
* Revisit Source.Lint
	Should be able to rewrite most of this with Source.Plate.Trans

2007/4/1.1
* Sort through Type.TypeSource and source generation in Slurp
	Make sure constraints are tagged with an appropriate source, and check that
	Type.Error can print out each one.
	
	We should also insert snippets of code into these TypeSources so we
	can print them out in the error messages.
	

2007/2/21.1
* Not sure about the whole inst puncturing thing in Desugar.ToCore.Lambda
	What if we get effects between input and output unified together, as in select?
	Work out if this is really correct.
		

2007/2/19.4
* Implement selective forcing of Direct data.
	Call unboxDirect on values which aren't lazy.
	
2007/2/19.5
* In Sea code, eliminate extra switch cases for suspensions if 
	the objects are Direct.
		

2007/2/18.5
* prim array code is not GC safe.
	Rewrite this code in native disciple code, using more primitive 
	foreign calls

2007/2/16.13
* Fixup inlining
	That Beta reduction thing.. how many times around to go?
	Forcing it twice statically isn't good.
	Auto choose functions to inline.


2007/2/16.4
* Fixup exception mechanism.
	
	Ideally, Should be able to throw an object of any type, not just exception.
	
	throw 	:: a -(!e1)> b 
		:- !e1 = { !Throw a } 	

	Catching should only look at object of a specific type.
	-- do we need a reflection mechanism for this.
	
	try 	:: (() -(!e1)> b) -> (a -(!e2)> b) -(!e3)> b;
		:- !e3 = { !e1 / !Throw a; !e2 }

	Remember seeing another ML paper about this.. shoudn't use throw/try mechanism?


2007/2/16.9
* Add GC slot sharing
	
	
2007/2/16.10
* Check full laziness transform.
	Don't lift mutable data.
	Is this even working?
	
	
2007/2/16.11
* Atomisation
	Atomise constant constructors.

	Is this still working?
		No: zero airity constructors are called in Core.Curry
	
		
2007/2/16.15
* Offside rule / indenting
	Lexer should emit tokens representing spaces, tabs and newlines in the source file.


2007/2/16.16
* Haddoc style documentation

