------------------------------------------------------------------------------------------
-- Example from Drowning in Kinds - Ben Lippmeier
--	SAPLING 2007-06
--
-- Note: This probably isn't that readable without syntax highlighting...
--

------------------------------------------------------------------------------------------
-- Source code

map f xx
 = case xx of {
 	Nil		-> Nil;
	Cons x xs	-> Cons (f x) (map f xs);
 };


------------------------------------------------------------------------------------------
-- Type constraints
-- Notes:
--	* is the kind of data
--	% is the kind of regions
--	! is the kind of effects
--	$ is the kind of closures
--
--	*<...> denotes a unification of types
--	!{...} denotes a sum (l.u.b) of effects
--	${...} denotes a sum (l.u.b) of closures

@CBranch (@BLetGroup [map])
{
        @CBranch (@BLet [map])
        {
                @CEq   map             tTC11lam;
                @CBranch (@BLambda [f, xx])
                {
                        @CEq   tTC11lam        (f -($cTC0lam)> tTC13lam);
                        @CEq   $cTC0lam        ($cTC1lam \ f);
                        @CEq   tTC13lam        (xx -(!eTC0match $cTC1lam)> tTC15matchRHS);
                        @CEq   $cTC1lam        ($cTC2match \ xx);
                        @CEq   tTC16_xx        (*<tTC17guards; tTC20guards>);
                        @CEq   tTC15matchRHS   (*<tTC19_Nil; tTC24app>);
                        @CEq   !eTC1matchI     (Base.!ReadH tTC16_xx);
                        @CEq   !eTC0match      !{!eTC1matchI; !eTC2alt; !eTC3alt};
                        @CEq   $cTC2match      ${xx : xx; $cTC3alt; $cTC4alt};
                        @CInst tTC16_xx        xx;
                        @CBranch (@BNil)
                        {
                                @CEq   tTC17guards     (Main.List %rTC0 tTC18);
                                @CEq   !eTC2alt        !Bot;
                                @CEq   $cTC3alt        (Main.Nil : Nil);
                                @CInst tTC19_Nil       Nil;
                        }
                        
                        @CBranch (@BDecon [x, xs])
                        {
                                @CEq   tTC20guards     (Main.List %rTC1 tTC21);
                                @CEq   !eTC3alt        !eTC4app;
                                @CEq   $cTC4alt        ($cTC5app \ ${x : x; xs : xs});
                                @CEq   x               tTC21;
                                @CEq   xs              (Main.List %rTC1 tTC21);
                                @CInst tTC26_Cons      Cons;
                                @CInst tTC28_f         f;
                                @CInst tTC29_x         x;
                                @CEq   tTC28_f         (tTC29_x -(!eTC9app)> tTC27app);
                                @CEq   !eTC8app        !eTC9app;
                                @CEq   $cTC7app        ${f : f; x : x};
                                @CEq   tTC26_Cons      (tTC27app -(!eTC7app)> tTC25app);
                                @CEq   !eTC6app        !{!eTC8app; !eTC7app};
                                @CEq   $cTC6app        ${Main.Cons : Cons; $cTC7app};
                                @CInst tTC32_map       map;
                                @CInst tTC33_f         f;
                                @CEq   tTC32_map       (tTC33_f -(!eTC13app)> tTC31app);
                                @CEq   !eTC12app       !eTC13app;
                                @CEq   $cTC9app        ${Main.map : map; f : f};
                                @CInst tTC34_xs        xs;
                                @CEq   tTC31app        (tTC34_xs -(!eTC11app)> tTC30app);
                                @CEq   !eTC10app       !{!eTC12app; !eTC11app};
                                @CEq   $cTC8app        ${$cTC9app; xs : xs};
                                @CEq   tTC25app        (tTC30app -(!eTC5app)> tTC24app);
                                @CEq   !eTC4app        !{!eTC6app; !eTC10app; !eTC5app};
                                @CEq   $cTC5app        ${$cTC6app; $cTC8app};
                        }
                        
                }
                
                @CGen  map;
        }
        
}

-------------------------------------------------------------------------------------
-- Extract subgraph for map.

*** Scheme.extractType map

-- this is the type directly from the constraint graph.

    tTrace           =
        *10
        :- *8         = forall %r1 a. Main.List %r1 a
        ,  *9         = forall %r1 a. a -> Main.List %r1 a -> Main.List %r1 a
        ,  *10        = *13 -(!15 $16)> *14
        ,  *13        = *40 -(!71 $72)> *45
        ,  *14        = *20 -(!22 $18)> *21
        ,  *20        = Main.List %39 *40
        ,  *21        = Main.List %44 *45
        ,  !22        = !{!30; !33; !34}
        ,  !30        = Base.!Read %39
        ,  !34        = !{!80; !98; !63}
        ,  !80        = !{!71; !65}
        ,  !98        = !{!15; !22}
        ,  $16        = $18 \ f
        ,  $18        = $24 \ xx
        ,  $24        = ${xx : *20; $36; $37}
        ,  $36        = Main.Nil : *8
        ,  $37        = $51 \ $52
        ,  $51        = ${$82; $100}
        ,  $52        = ${x : *40; xs : *20}
        ,  $74        = ${f : *13; x : *40}
        ,  $82        = ${Main.Cons : *9; $74}
        ,  $91        = ${Main.map : *10; f : *13}
        ,  $100       = ${$91; xs : *20}


-- the type packed into a more familiar form.

    tPack            =
        (*40 -(!71 $72)> *45) -(!15 $16)> Main.List %39 *40 -(!22 $18)> Main.List %44 *45
        :- !22        = !{Base.!Read %39; !33; !71; !65; !15; !63}
        ,  $16        = $18 \ f
        ,  $18        = ${ Main.Nil  : forall %r1 a. Main.List %r1 a; 
	                   Main.Cons : forall %r1 a. a -> Main.List %r1 a -> Main.List %r1 a; 
			   f : *40 -(!71 $72)> *45; 
			   Main.map : (*40 -(!71 $72)> *45) -(!15 $16)> Main.List %39 *40 -(!22)> Main.List %44 *45}


-- closure terms trimmed of uninteresting information.
--	we're only really interested in monomorphic type, region and closure variables.

    tTrim            =
        (*40 -(!71 $72)> *45) -(!15 $16)> Main.List %39 *40 -(!22 $18)> Main.List %44 *45
        :- !22        = !{Base.!Read %39; !33; !71; !65; !15; !63}
        ,  $18        = f : $72


-------------------------------------------------------------------------------------------
-- Generalisation of type for map

*** Scheme.generaliseType map

-- the monotype to generalise, from above.

    tCore
        (*40 -(!71 $72)> *45) -(!15 $16)> Main.List %39 *40 -(!22 $18)> Main.List %44 *45
        :- !22        = !{Base.!Read %39; !33; !71; !65; !15; !63}
        ,  $18        = f : $72


-- no monovars in the environment, static regions, or dangerous type vars.

    envCids          = []
    staticRsData     = []
    staticCids       = []

-- rewrite effect and closure vars in contra-variant branches to ensure that they're acting as parameters.

    tPort
        (*40 -(!eTS0 $cTS0)> *45) -(!15 $16)> Main.List %rTS2 *40 -(!22 $18)> Main.List %44 *45
        :- !22        = !{Base.!Read %rTS2; !33; !eTS0; !65; !15; !63}
        ,  $18        = f : $cTS0


-- make up new names for monovars that are going to be generalised

    tPlug
        (x -(!eTS0 $cTS0)> tTS1) -(!eTC12app $cTC0lam)> Main.List %rTS2 x -(!eTC11app $cTC1lam)> Main.List %rTS1 tTS1
        :- !eTC11app  = !{Base.!Read %rTS2; !eTC2alt; !eTS0; !eTC7app; !eTC12app; !eTC5app}
        ,  $cTC1lam   = f : $cTS0

-- clean out 'dead' effect / closure vars - ones that don't serve as unification points.

    vsFree           = [x, tTS1, !eTS0, $cTS0, %rTS2, %rTS1, !eTC12app, $cTC0lam, Base.!Read, !eTC2alt, !eTC7app, !eTC5app]
    vsPorts          = [!eTS0, $cTS0]
    vsClean          = [!eTC12app, $cTC0lam, !eTC2alt, !eTC7app, !eTC5app]

    tClean
        = (x -(!eTS0 $cTS0)> tTS1) -> Main.List %rTS2 x -(!eTC11app $cTC1lam)> Main.List %rTS1 tTS1
        :- !eTC11app  = !{Base.!Read %rTS2; !eTS0}
        ,  $cTC1lam   = f : $cTS0


-- add the foralls out the front.

    tScheme
        forall x tTS1 %rTS2 %rTS1 !eTS0 $cTS0
        .  (x -(!eTS0 $cTS0)> tTS1) -> Main.List %rTS2 x -(!eTC11app $cTC1lam)> Main.List %rTS1 tTS1
        :- !eTC11app  = !{Base.!Read %rTS2; !eTS0}
        ,  $cTC1lam   = f : $cTS0


-- normalise the names of quantified vars.

    tNormal
        forall t0 t1 %r0 %r1 !e0 $c0
        .  (t0 -(!e0 $c0)> t1) -> Main.List %r0 t0 -(!e1 $c1)> Main.List %r1 t1
        :- !e1        = !{Base.!Read %r0; !e0}
        ,  $c1        = f : $c0



