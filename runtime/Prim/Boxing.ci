
#include "../Profile.h"
#include "../Force.h"
#include "../Alloc.h"
#include "../Macro.h"
#include "../Object.h"
#include "../State.h"

#include "../Collect.ci"
#include "../Alloc.ci"

// ----- Macros
//
// 	 macros + token pasting == polymorphism.
//
#define MAKE_BOXFUN(Type,TypeSize) \
	static inline \
	Obj* _box##Type (Type v) \
	{ 	DataRS* data	= (DataRS*)_allocDataRS (_tagBase, TypeSize); \
		Type* x		= (Type*) data->payload; \
		*x		= v; \
		_PROFILE_BOXING ( b##Type.count ++); \
		_PROFILE_BOXING ( b##Type.bytes += sizeof(DataRS) + TypeSize); \
		return (Obj*)data; \
	}

#define MAKE_GETFUN(Type) \
	static inline \
	Type _unbox##Type (Obj* obj) \
	{ 	DataRS* data	= (DataRS*) _force (obj); \
		Type* x		= (Type*) data->payload; \
		Type v		= *x; \
		_PROFILE_BOXING ( b##Type.gets ++); \
		return	(Type)v; \
	}

// -- Box up a naked value.
#define _box(Type,data) \
	_box##Type(data)

// -- Force and unbox a value.
#define _unbox(Type,data) \
	_unbox##Type(data)

// -- Unbox a value without forcing it.
//	This object MUST be direct (not a suspension) else badness.
#define _unboxDirect(Type,data) \
	*((Type*) ((DataRS*)data)->payload)


static inline UInt _unboxEnum(Obj* obj)
{
	Obj* data	= _force(obj);
	return		_getObjTag(data);
}

static inline Int32 _unboxInt32(Obj* obj)
{
	Obj32* o32	= (Obj32*) _force(obj);
	return		o32->u32.i;
}

static inline Float32 _unboxFloat32(Obj* obj)
{
	Obj32* o32	= (Obj32*) _force(obj);
	return		o32->u32.f;
}

// -----
// -- Boxing Functions
//
MAKE_BOXFUN (Char32,	sizeof(Word32));
MAKE_BOXFUN (Word8,	sizeof(Word32));
MAKE_BOXFUN (Int64,	sizeof(Int64));
MAKE_BOXFUN (Float64,	sizeof(Float64));

// Int32
static inline
Obj*	_boxInt32 (Int32 v)
{
	if (_ddcHeapPtr + sizeof (Obj32) > _ddcHeapMax)
		_allocCollect (sizeof (Obj32));

	Obj32*	obj	= (Obj32*)_ddcHeapPtr;
	_ddcHeapPtr 	+= sizeof (Obj32);

	obj->tagFlags	= 0x00000013;			// (tag << 8) | _ObjModeDataRS | (dataSize << 4);
	obj->u32.i	= v;

	_PROFILE_ALLOC  ( dataRawSmall.count++ );
	_PROFILE_ALLOC  ( dataRawSmall.bytes += sizeof (Obj32) );
	_PROFILE_BOXING ( bInt32.count ++);
	_PROFILE_BOXING ( bInt32.bytes += sizeof (Obj32));

	return (Obj*)obj;
}


// Float32
static inline
Obj*	_boxFloat32 (Float32 v)
{
	if (_ddcHeapPtr + sizeof (Obj32) > _ddcHeapMax)
		_allocCollect (sizeof (Obj32));

	Obj32*	obj	= (Obj32*)_ddcHeapPtr;
	_ddcHeapPtr	+= sizeof (Obj32);

	obj->tagFlags	= 0x00000013;		// (tag << 8) | _ObjModeDataRS | (dataSize << 4);
	obj->u32.f	= v;

	_PROFILE_ALLOC  ( dataRawSmall.count++ );
	_PROFILE_ALLOC  ( dataRawSmall.bytes += sizeof (Obj32));
	_PROFILE_BOXING ( bFloat32.count ++);
	_PROFILE_BOXING ( bFloat32.bytes += sizeof (Obj32));

	return (Obj*)obj;
}


// Enum
static inline
Obj*	_boxEnum (Word32 tag)
{
	if (_ddcHeapPtr + sizeof (Obj32) > _ddcHeapMax)
		_allocCollect (sizeof (Obj32));

	Obj32*	obj	= (Obj32*)_ddcHeapPtr;
	_ddcHeapPtr	+= sizeof (Obj32);

	obj->tagFlags	= (tag << 8) | 0x021;		// (tag << 8) | _ObjFixedData
	obj->u32.i	= 0;

	return (Obj*)obj;
}


static inline
Obj* 	primProjField  (Obj* obj, Int32 ix)
{
	Data* data	= (Data*)obj;
	return	data ->a[ix];
}


static inline
Obj*	primProjFieldR (Obj* obj, Int32 ix)
{
	Data* data	= (Data*)obj;
	return	_boxRef (obj, &(data ->a[ix]));
}


MAKE_GETFUN (Char32);
MAKE_GETFUN (Int64);
MAKE_GETFUN (Float64);


static inline
void	primFloat32U_write (Obj* obj, Int32 offset, Float32 data)
{
	*(Float32*) ((Word8*)obj + offset)	= data;
}

static inline
Float32	primFloat32U_read (Obj* obj, Int32 offset)
{
	return		* (Float32*) ((Word8*)obj + offset);
}

