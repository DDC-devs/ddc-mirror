
import Util

-----
-- After changing these you must also update
--	Apply.h, then run makeEval.sh to actually generate the functions.
--
maxAirity	= 20
maxImm		= 4

-----
main
 = do
	putStr	"#ifndef _DDC_Eval\n"
	putStr	"#define _DDC_Eval\n"

	putStr	"/* -----------------------------------------------------\n"
	putStr	" *  Eval.ci\n"
	putStr	" *    - This file was generated by EvalGen.hs\n"
	putStr	" *    - Editing it directly probably isn't worthwhile.\n"
	putStr	" *\n"
	putStr	" */\n\n"

	putStr	"\n"
	
	putStr	"// ----- Func Typedefs\n"
	mapM
		(\x -> putStr $ genFunc x) 
		[1 .. maxAirity]
	putStr "\n"

	
	putStr	"// ----- Eval Funcs\n"
	mapM 
		(\(a, i) -> putStr $ genEval a i)
		[(a, i) | a <- [1 .. maxAirity] , i <- [1 .. maxImm], a >= i]
		
	putStr	"\n"
	putStr	"#endif\n"
	putStr	"\n"

-----------------------
-- genFunc
--	Generate a function type def
--
genFunc ::	Int 	-> String
genFunc		airity
	= pretty
	$ "typedef Obj* (*_FUNC" % airity % ") (" % ", " %!% replicate airity "Word" % ");\n"



-----------------------
-- genEval
--	Generate an eval function
--	
genEval :: 	Int -> Int -> String
genEval		airity imm
 	= pretty

	-- prototype
	$ "inline Obj* _eval" % airity % "_" % show imm 
	% " (Thunk* thunk, " 
		% ", " %!% ["Obj* a" % i | i <- [airity - imm .. airity - 1]] 
	% ")\n"

	-- body
	% "{\n"
		-- count the use of this function.
		%> ("_PROFILE_APPLY (eval[" % airity % "][" % imm % "]++);") 	% "\n"

		-- extract the function ptr from the thunk and cast it to the correct type.
 		%> ("_FUNC" % airity % " func " 
			%>> " = " % "(_FUNC" % airity % ") thunk->func;") 	% "\n"
 		
		-- call the function
		%> ("return func\n" 
			%> ("( " % "\n, " %!%

				-- args from the thunk
				(  ["thunk ->a[" % i % "]" 	| i <- [0 .. airity - imm - 1]]

				-- args passed into eval function
				++ ["a" % i			| i <- [airity - imm .. airity -1]])
 			% ");\n"))

	% "}\n\n"
	
