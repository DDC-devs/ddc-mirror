
#ifndef _DDC_Alloc_I
#define _DDC_Alloc_I

#include "Config.h"
#include "Alloc.h"
#include "Profile.h"
#include "State.h"
#include "Macro.h"
#include "Collect.h"
#include "Object.h"
#include "Lint.h"

#include <stdlib.h>
#include <stdio.h>

// Heap Allocations --------------------------------------------------------------------------------

// Allocate some space in the heap.
//	This just makes the space, the caller is responsible for building
//	a valid object and adding the header.
static inline 
void*	_alloc		(UInt byteCount)
{
#if _DDC_DEBUG
	// Avoid allocating object of a size that will mis-align the heap.
	assert(byteCount >= 8);
	assert((byteCount % 4) == 0);
#endif

	// If there's not enough space for the requested object then 
	//	its time to perform a collection.
	if (_ddcHeapPtr + byteCount > _ddcHeapMax) 
		_allocCollect (byteCount);

	Obj* obj	= (Obj*)_ddcHeapPtr;
	_ddcHeapPtr	+= byteCount;

	_PROFILE_ALLOC (total.count++);
	_PROFILE_ALLOC (total.bytes += byteCount);

	return obj;
}


// Allocate a thunk object.
//	TODO: 	This makes an object big enough to hold the full airity, 
//		even though only some args are used.
static inline
Obj*	_allocThunk	(FunPtr func, UInt arity, UInt args)
{
	UInt	size	= sizeof(Thunk) + sizeof(Obj*) * arity;
	Thunk*	thunk	= (Thunk*)_alloc (size);

	thunk->tagFlags	= (_tagThunk << 8) | _ObjFixedThunk;
	thunk->func	= func;
	thunk->arity	= arity;
	thunk->args	= args;

	_PROFILE_ALLOC (thunk.count++);
	_PROFILE_ALLOC (thunk.bytes += size);

	return (Obj*)thunk;	
}


// Copy a thunk object.
//	We need to do this when we add extra arguments to a partial application.
//	TODO: 	Make the caller build a new object of the correct size, 
//		which would save the copy from becoming dead straight away.
static inline
Thunk*	_copyThunk	(Thunk* thunk)
{
	_ENTER(1);
	_S(0)		= (Obj*)thunk;

	// Work out the size of the object to be copied, and allocate a new one
	UInt	size	= sizeof(Thunk) + sizeof(Obj*) * thunk ->arity;
	Thunk*	thunkC	= (Thunk*)_alloc (size);

	// Copy across all the parts
	Thunk*	thunk1	= (Thunk*)_S(0);
	thunkC ->tagFlags	= thunk1 ->tagFlags;
	thunkC ->func		= thunk1 ->func;
	thunkC ->arity		= thunk1 ->arity;
	thunkC ->args		= thunk1 ->args;

	for (UInt i = 0; i < thunk1->args; i++)
		thunkC ->a[i]	= thunk1 ->a[i];

	_PROFILE_ALLOC (thunkCopy.count++);
	_PROFILE_ALLOC (thunkCopy.bytes += size);
	
	_LEAVE(1);
	return thunkC;
}


// Allocate a data object.
static inline
Obj*	_allocData	
		( Tag tag
		, UInt arity)
{
	UInt	size	= sizeof(Data) + sizeof(Obj*) * arity;
	Data*	data	= (Data*)_alloc (size);

	data ->tagFlags	= (tag << 8) | _ObjFixedData;
	data ->arity	= arity;

	_PROFILE_ALLOC (data.count++);
	_PROFILE_ALLOC (data.bytes += size);

	return (Obj*)data;
}


// Allocate a raw data object.
static inline
Obj*	_allocDataR	(Tag tag, UInt dataSize)
{
	UInt	size	= sizeof(DataR)
			+ dataSize;
			
	DataR*	data	= (DataR*)_alloc (size);
	
	data ->tagFlags	= (tag << 8) | _ObjFixedDataR;
	data ->size	= size;
	
	_PROFILE_ALLOC (dataRaw.count++);
	_PROFILE_ALLOC (dataRaw.bytes += size);
	
	return (Obj*)data;
}


// Allocate a small, raw data object.
static inline
Obj*	_allocDataRS	(Tag tag, UInt dataSize)
{
	UInt dataSizeWords
			= dataSize / 4;

	UInt	size	= sizeof(DataRS)
			+ dataSize;

	DataRS*	data	= (DataRS*)_alloc (size);
	
	data ->tagFlags	= (tag << 8) | _ObjModeDataRS | (dataSizeWords << 4);

	_PROFILE_ALLOC (dataRawSmall.count++);
	_PROFILE_ALLOC (dataRawSmall.bytes += size);
	
	return (Obj*)data;
}


// Allocate a mixed data object.
static inline
Obj*	_allocDataM	
		( Tag tag
		, UInt ptrCount		// the number of pointers appearing at the start of the object
		, UInt dataSize)	// the size of the trailing data. 
					//	this needs to be a valid size, so the new object will 
					//	not misalign the heap.
{
	UInt	size	= sizeof(DataM) 
			+ ptrCount * sizeof (Obj*)
			+ dataSize;
			
	DataM*	data	= (DataM*)_alloc (size);
	
	data ->tagFlags	= (tag << 8) | _ObjFixedDataM;
	data ->size	= size;
	data ->ptrCount	= 0;
	
	_PROFILE_ALLOC (dataMixed.count++);
	_PROFILE_ALLOC (dataMixed.bytes += size);
	
	return (Obj*)data;
}


// Allocate a suspension
static inline
Obj*	_allocSusp	(Obj* thunk, UInt args)
{
	_ENTER(1);
	_S(0)	= thunk;

	UInt		size	= sizeof (SuspIndir) + sizeof(Obj*) * args;
	SuspIndir*	susp	= (SuspIndir*)_alloc (size);

	susp ->tagFlags	= (_tagSusp << 8) | _ObjFixedSuspIndir;
	susp ->obj	= _S(0);
	susp ->arity	= args;

	_PROFILE_ALLOC (susp.count++);
	_PROFILE_ALLOC (susp.bytes += size);
	
	_LEAVE(1);
	return (Obj*)susp;
}


// External Allocations ----------------------------------------------------------------------------

// These function allocate space in the external, C heap.
// They won't be moved around by the GC, but need to be freed manually.

// Allocate an anchored data object.
static inline
Obj*	_allocData_anchored
		( Tag 	tag
		, UInt	arity)
{
	// TODO: The GC doesn't handler ptrs in anchored objects yet.
	assert (arity == 0);

	UInt	size	= sizeof(Data) + sizeof(Obj*) * arity;
	Data*	data	= (Data*)malloc(size);
	
	data ->tagFlags	= (tag << 8) | _ObjFixedData | _ObjFlagAnchored;
	data ->arity	= arity;
	
	_PROFILE_ALLOC (data.count++);
	_PROFILE_ALLOC (data.bytes += size);
	
	return (Obj*)data;
}


// Allocate a raw anchored data object.
static inline
Obj*	_allocDataR_anchored
		(Tag tag, UInt dataSize)
{
	UInt	size	= sizeof(DataR)
			+ dataSize;
			
	DataR*	data	= (DataR*)malloc (size);
	
	data ->tagFlags	= (tag << 8) | _ObjFixedDataR | _ObjFlagAnchored;
	data ->size	= size;
	
	_PROFILE_ALLOC (dataRaw.count++);
	_PROFILE_ALLOC (dataRaw.bytes += size);
	
	return (Obj*)data;
}


#endif
