
-- Demonstration of list combinators and combining commutable effects.
-- 
-- This module can be type-checked with "ddc -check" and "ddc -load"
-- but will not compile to object code yet because back-end support for
-- higher order functions is not complete.
--
module Main 
export main 
import Data.Numeric.Nat
import Data.List
import Data.Maybe
import IO.Console

import foreign boxed type
 Ref      : Region ~> Data ~> Data

import foreign c value
 allocRef : [r : Region]. [a : Data]. a  -> S (Alloc r) (Ref r a)
 readRef  : [r : Region]. [a : Data]. Ref r a -> S (Read r) a
 writeRef : [r : Region]. [a : Data]. Ref r a -> a -> S (Write r) Void#

where


main (_ : Unit) : S Console Unit
 = box private r with { Alloc r; Read r; Write r } in 
   do
        -- Create a demo list.
        xx      = enumFromTo 0 100

        -- Select only the even elements
        xx'     = run filterS (\(x : Nat#). box rem# x 2 == 0) xx

        -- Mutable reference to hold list length.
        ref     = run allocRef [r] [Nat#] 0

        -- Eat the list, updating the mutable counter while printing
        -- the elements to the console.
        run forS xx' (\(x : Nat#).
         box do run writeRef ref ((run readRef ref) + 1)
                run putStrLn (showNat [r] x)
                ())
        
        -- Print out the final list length.
        run putStrLn (showNat [r] (run readRef ref))
        ()

