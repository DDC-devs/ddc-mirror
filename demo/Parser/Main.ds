
import Data.Char
import Class.Monad

-- Parser -----------------------------------------------------------------------------------------

data Parser %r !e1 $c1 tok a 
	= Parser ([tok] -(!e1 $c1)> Reply tok a)

data Reply tok a
	= Success a [tok]
	| Error (ParserError tok)

-- Possible parser errors
data ParserError tok
	= ErrorUnexpected tok	-- ^ token was unexpected
	| ErrorEOF		-- ^ end of string was reached


-- Run a parser across a string of input tokens
runParser :: Parser %r !e $c tok a -> [tok] -> Reply tok a
runParser (Parser fun) str
	= fun str


instance Monad (Parser !e1 $c1 tok) where
	return x	
	 = Parser $ \str -> Success x str

	(>>=) (Parser parse1) mkParser2
	 = Parser $ \str ->
		case parse1 str of
			Success result rest	-> runParser (mkParser2 result) rest
			err			-> err

-- Bits and pieces ---------------------------------------------------------------------------------
isSuccess rr
 = case rr of
	Success _ _	-> True
	_		-> False


-- Combinators ------------------------------------------------------------------------------------

-- | If the first parser fails then try the second one.
(<|>) 	:: Parser %r1 !e1 $c1 tok a 
	-> Parser %r2 !e2 $c2 tok a
	-> Parser %r3 !e3 $c3 tok a
	
(<|>) (Parser parse1) parser2
 = Parser $ \str ->
 	case parse1 str of
	 result@(Success _ _)	-> result
	 _			-> runParser parser2 str

{-
-- | Parse many strings in sequence
many :: Parser %r1 !e1 $c1 tok a -> Parser %r2 !e2 $c2 tok [a]
many parser1
 =   do	x	<- parser1
	rest	<- many parser1
	return	$ x : rest

 <|>	return []
-}


-----
test	= ['d', 'b', 'c']

pChar :: Char -> Parser !e $c Char ()
pChar c
 = Parser $ \str -> 
 	case str of
 	 (s : rest) -> if s == c 
			then Success () rest
			else Error (ErrorUnexpected s)
	 []	  -> Error (ErrorEOF)

pTest
 =   do	_	<- pChar 'a'
 	_	<- pChar 'b'
	return	()

 <|> do	_	<- pChar 'c'
 	return	()
 	

	
main ()
 = do	putStr	$ show test % "\n"
	result	= runParser pTest test
	
	putStr	$ show (isSuccess result) % "\n"

	()
	

