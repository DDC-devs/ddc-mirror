
import Data.Char
import Class.Monad

-- Parser -----------------------------------------------------------------------------------------

data Parser %r !e1 $c1 tok a 
	= Parser ([tok] -(!e1 $c1)> Reply tok a)

data Reply tok a
	= Success a [tok]
	| Error (ParserError tok)

-- Possible parser errors
data ParserError tok
	= ErrorUnexpected tok	-- ^ token was unexpected
	| ErrorEOF		-- ^ end of string was reached


-- Run a parser across a string of input tokens
runParser :: Parser %r !e $c tok a -> [tok] -> Reply tok a
runParser (Parser fun) str
	= fun str


instance Monad (Parser !e1 $c1 tok) where
	return	= parserReturn

	(>>=) 	= parserBind

parserReturn x
 = Parser (\str -> Success x str)

parserBind (Parser parse1) mkParser2
 = Parser parse
 where parse str
 	 = case parse1 str of
		Success result rest	-> runParser (mkParser2 result) rest
		Error err		-> Error err


-- Bits and pieces ---------------------------------------------------------------------------------
isSuccess rr
 = case rr of
	Success _ _	-> True
	_		-> False


-- Primitive Parsers -------------------------------------------------------------------------------
pChar :: Char -> Parser !e $c Char ()
pChar c
 = Parser $ \str -> 
 	case str of
 	 (s : rest) -> if s == c 
			then Success () rest
			else Error (ErrorUnexpected s)
	 []	  -> Error (ErrorEOF)


-- Combinators ------------------------------------------------------------------------------------

-- | If the first parser fails then try the second one.
(<|>) 	:: Parser %r1 !e1 $c1 tok a 
	-> Parser %r2 !e2 $c2 tok a
	-> Parser %r3 !e3 $c3 tok a
	
(<|>) (Parser parse1) parser2
 = Parser $ \str ->
 	case parse1 str of
	 result@(Success _ _)	-> result
	 _			-> runParser parser2 str


-- | Parse many strings in sequence
many :: Parser %r1 !e1 $c1 tok a -> Parser %r2 !e2 $c2 tok [a]
many parser
 =   do	x	<- parser
	rest	<- many parser
	return (x : rest)

 <|>	return []


-- | Parse at least one of these
many1 :: Parser %r1 !e1 $c1 tok a -> Parser %r2 !e2 $c2 tok [a]
many1 parser
 = do	x	<- parser
 	rest	<- many parser
	return	(x : rest)

-----
test	= ['b', 'a', 'a', 'a', 'a', 'b']

pTest
 =   do	_	<- many (pChar 'a')
 	_	<- pChar 'b'
	return	()

 <|> do	_	<- pChar 'z'
 	return	()
 	

	
main ()
 = do	putStr	$ show test % "\n"
	result	= runParser pTest test
	
	putStr	$ show (isSuccess result) % "\n"

	()
	

