-- A solution to the 2008 ICFP programming contest.
--	Needs a running the contest server to connect to.

import Message
import Control
import Update
import Plan
import Display

import System.Network
import System.Environment
import Util

debug_recv	= False

data Link 
	= Link { 
		socket	:: Int;		-- socket for this connection
		slack	:: [String]; 	-- extra tokens left over after reading last message
	}
	
-- Main --------------------------------------------------------------------------------------------
main ()
	| argCount < 2
	= putStr "usage: rover <hostname> <port>\n"
	
	| otherwise
	, SChunk fs_arg1	<- getArgValue 1
	= do
		sock	 = boxInt32 (connect 
					(fs_arg1 .danger_string)
					(unboxInt32 (read (getArgValue 2))))
		init (Link sock [])
   	

-- Receive the init message and initialise the rover
--	If the first message isn't an init then we're screwed.
init link
 = case recvServer link of
 	msg@MsgInit{}
	 -> do	rover 	:: Rover %r %i %s	
	 		:- Mutable %r, Const %i, Mutable %s
			
	 	rover	= Rover (msg.sensorMin)
				(msg.sensorMax)
				(msg.speedMax)
				(msg.turnSpeedMax)
				(msg.turnSpeedHardMax)
				
		control	:: Control %r %i
			:- Mutable %r, Const %i
		
		control	= Control
			
		coma link rover control

-- Main loop
--	Accept telemetry from server and send control messages back
--
coma :: Link -> Rover -> Control -> ()
coma link rover control
 = do	
	res	= try (pulse link rover control)
	          catch _ -> putStr "trouble\n"

	coma link rover control
	

-- | Pulse the world
pulse :: Link -> Rover -> Control -> ()
pulse link rover control
 = do	
 	-- receive a message from the server
	msg	= recvServer link
	
	-- update rover state
	updateRover rover msg	

	-- plan what to do
	planControl rover control

	-- move towards the desired control state
	cmd 	= controlTrack rover control

	-- send the command to the server
	sendCommand (link.socket) cmd

	-- update the window
	updateFrame rover 

	()



-- | Receive a message from the server
recvServer :: Link -> MsgServer
recvServer link
 = do	
	-- receive some data from the server
	buf	:: FlatString %r :- Mutable %r
	buf	= new&{FlatString} 4096
	msgLen	= recv 	(unboxInt32 link.socket) 
			(unsafe_castToVoidPtr (buf.danger_string)) 
			1024# 
			0#

	buf.setLengthU msgLen

	-- if the message len == 0 then assume the server has died
	when (boxInt32 msgLen == 0)
	 throw Exception "server has died."

	recvParse (SChunk buf)

recvParse str
 = do	
	-- parse the message
	msg	= try (parseMessage (copy str))
		  catch	_	-> MsgBad "trouble";

	msg

	
-- | Send a control message to the server
sendCommand :: Int -> MsgCommand -> ()

sendCommand sock (MsgCommand Nothing Nothing) 
	= ()

sendCommand sock cc
 | SChunk fs	<- (showMsgCommand cc) .flatten
 = do 	send 	(unboxInt32 sock)
		(unsafe_castToVoidPtr (fs.danger_string))
		(unboxInt32 (fs.length))
		0#
	()

