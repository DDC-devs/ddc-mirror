
import Actor

-- Config -----------------------------------------------------------------------------------------
-- How bouncy the beads are
--	at 0.2 and they look like melting plastic.
--	at 0.8 and they look like bouncy rubber balls.
--	at > 1 and they gain energy with each bounce and escape the box.
--
beadBeadLoss	= 0.9
beadWallLoss	= 0.8

-- | Move a bead which is in contact with a wall.
collideBeadWall
	:: Actor	-- ^ the bead 
	-> Actor	-- ^ the wall that bead is in contact with
	-> Actor	-- ^ the new bead

collideBeadWall
	bead@(Bead ix _ radius pBead vIn)
	wall@(Wall _ pWall1 pWall2)

 = let	-- Take the collision point as being the point on the wall which is 
 	-- closest to the bead's center.
	pCollision	= closestPointOnLine pWall1 pWall2 pBead
 
	-- then do a static, non energy transfering collision.
  in	collideBeadPoint_static 
		bead 
		pCollision
		beadWallLoss


-- | Move a bead which has collided with another bead.
collideBeadBead_static
	:: Actor -> Actor 
	-> Actor
	
collideBeadBead_static
	bead1@(Bead ix1 _ radius1 pBead1 _)
	bead2@(Bead ix2 _ radius2 pBead2 _)

 = do	-- Take the collision point as being between the center's of the two beads. 
	-- For beads which have the same radius the collision point is half way between
	-- their centers and u == 0.5
	u		= radius1 / (radius1 + radius2)
	pCollision	= pBead1 + (pBead2 - pBead1) .muls u
		
	collideBeadPoint_static
		bead1
		pCollision
		beadBeadLoss


-- | Move a bead which has collided with something.
collideBeadPoint_static
	:: Actor	-- ^ the bead which collided with something
	-> Vec2 Float	-- ^ the point of collision (should be near the bead's surface)
	-> Float	-- ^ velocity scaling factor (how much to slow the bead down after the collision)
	-> Actor

collideBeadPoint_static
	bead@(Bead ix mode radius pBead vIn)	
	pCollision
	velLoss
 = do
	-- take a normal vector from the wall to the bead.
	--	this vector is at a right angle to the wall.
	vNormal		= (pBead - pCollision) .normalised
	
	-- the bead at pBead is overlapping with what it collided with, but we don't want that.
	-- 	place the bead so it's surface is just next to the point of collision.
	pBead_new	= pCollision + vNormal .muls (radius + 0.001)

	-- work out the angle of incidence for the bounce.
	--	this is the angle between the surface normal and
	--	the direction of travel for the bead.
	aInc		= vNormal .angleVV (negate vIn)

	-- aInc2 is the angle between the wall /surface/ and
	--	the direction of travel.
	aInc2		= (pi / 2.0) - aInc

	-- take the determinant between the surface normal and the direction of travel.
	--	This will tell us what direction the bead hit the wall. 
	--	The diagram shows the sign of the determinant for the four possiblities.
	--
	--           \ +ve                                -ve /
	--            \                                      /
	--             \/                                  \/
	--   pWall1 ---------- pWall2           pWall1 ---------- pWall2
	--             /\                                  /\
	--            /                                      \
 	--           / -ve                                +ve \
	--
	determinant	= vIn.det vNormal

	-- Use the determinant to rotate the bead's velocity vector for the bounce.
	vOut
		= if  determinant > 0.0	
			then vIn .rotate (2.0 * aInc2)
			else vIn .rotate (negate (2.0 * aInc2))

	-- Slow down the bead when it hits the wall
	vSlow		= vOut .muls velLoss 

	Bead ix mode radius pBead_new vSlow

	

