
-- The variable capture example from Chapter 4 of Leroy's thesis.

-- Unification of 'f' with '(\z -> do { y; z;})' gives f the following type:
-- 	f :: b -(y : a)> b 

-- When generalising a the type 'id :: a -> a', 'a' is part of its type environment
--	through 'f', so its not generalisable, and the application 'id id' is ill-typed.

-- TODO: when generalising a function type (t1 -(_ : a)> t2) ignore a if it is not 
--	free in either t1 or t2.

-- CRASH when switch back to 'id'

fun f
 = do {	id y = do { either f (\z -> do { y; z; }); y; };
	id id;
 };
 
either x y 
 =	if True then x else y;
 
 
		
	
	
