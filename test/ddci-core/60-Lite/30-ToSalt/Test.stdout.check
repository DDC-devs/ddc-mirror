
ok
ok

-- Set the builder explicitly so we get consistent object layouts.
ok
ok

-- Unboxed literal patterns.
module Main with
letrec {
  foo : Word16# -> Word16#
    = \(x : Word16#).
      case x of {
        5w16#  
         -> 6w16#;
        7w16#  
         -> 8w16#;
        _ 
         -> 0w16#
      }
}


module Main with
letrec {
  foo : Word32# -> Word32#
    = \(x : Word32#).
      case x of {
        5w32#  
         -> 6w32#;
        7w32#  
         -> 8w32#;
        _ 
         -> 0w32#
      }
}

module Main with
letrec {
  foo : Word64# -> Word64#
    = \(x : Word64#).
      case x of {
        5w64#  
         -> 6w64#;
        7w64#  
         -> 8w64#;
        _ 
         -> 0w64#
      }
}


-- Unboxed Bool pattern.
module Main with
letrec {
  foo : Bool# -> Bool#
    = \(x : Bool#).
      case x of {
        True#  
         -> False#;
        False#  
         -> True#
      }
}


-- Integer boxing,
--      packs a RawSmall Object.
module Main with
letrec {
  boxInt : [r : %].Int# -> Ptr# r Obj
    = /\(r : %).
       \(i : Int#).
      let x0 : Ptr# r Obj = allocRawSmall [r] TAG0# 8# in
      let x1 : Addr# = payloadOfRawSmall [r] x0 in
      let _ : Void# = write# [Int#] x1 0# i in
      x0
}


-- Integer unboxing,
--      unpacks a RawSmall Object.
module Main with
letrec {
  unboxInt : [r : %].Ptr# r Obj -> Int#
    = /\(r : %).
       \(x : Ptr# r Obj).
      let x0 : Tag# = getTag [r] x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall [r] x in
            let i : Int# = read# [Int#] x1 0# in
            i;
        _ 
         -> fail# [Int#]
      }
}


-- Nested case-expressions.
module Main with
letrec {
  addInt : [r1 r2 r3 : %].Ptr# r1 Obj -> Ptr# r2 Obj -> Int#
    = /\(r1 r2 r3 : %).
       \(x : Ptr# r1 Obj).\(y : Ptr# r2 Obj).
      let x0 : Tag# = getTag [r1] x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall [r1] x in
            let i1 : Int# = read# [Int#] x1 0# in
            let x2 : Tag# = getTag [r2] y in
            case x2 of {
              TAG0#  
               -> let x3 : Addr# = payloadOfRawSmall [r2] y in
                  let i2 : Int# = read# [Int#] x3 0# in
                  add# [Int#] i1 i2;
              _ 
               -> fail# [Int#]
            };
        _ 
         -> fail# [Int#]
      }
}


-- Boxed addition
module Main with
letrec {
  addInt : [r1 r2 r3 : %].Ptr# r1 Obj -> Ptr# r2 Obj -> Ptr# r3 Obj
    = /\(r1 r2 r3 : %).
       \(x : Ptr# r1 Obj).\(y : Ptr# r2 Obj).
      let x0 : Tag# = getTag [r1] x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall [r1] x in
            let i1 : Int# = read# [Int#] x1 0# in
            let x2 : Tag# = getTag [r2] y in
            case x2 of {
              TAG0#  
               -> let x3 : Addr# = payloadOfRawSmall [r2] y in
                  let i2 : Int# = read# [Int#] x3 0# in
                  let x4 : Ptr# r3 Obj = allocRawSmall [r3] TAG0# 8# in
                  let x5 : Addr# = payloadOfRawSmall [r3] x4 in
                  let x6 : Int# = add# [Int#] i1 i2 in
                  let _ : Void# = write# [Int#] x5 0# x6 in
                  x4;
              _ 
               -> fail# [Ptr# r3 Obj]
            };
        _ 
         -> fail# [Ptr# r3 Obj]
      }
}


-- Take the head of an Int list,
--      unpacks a Boxed object.
module Main with
letrec {
  head : [r : %].Ptr# r Obj -> Ptr# r Obj -> Ptr# r Obj
    = /\(r : %).
       \(def xs : Ptr# r Obj).
      let x0 : Tag# = getTag [r] xs in
      case x0 of {
        TAG1#  
         -> let x : Ptr# r Obj = getFieldOfBoxed [r] xs 0# in
            let xs' : Ptr# r Obj = getFieldOfBoxed [r] xs 1# in
            x;
        _ 
         -> def
      }
}


-- Take the tail of an Int list
module Main with
letrec {
  tail : [r : %].Ptr# r Obj -> Ptr# r Obj -> Ptr# r Obj
    = /\(r : %).
       \(def xs : Ptr# r Obj).
      let x0 : Tag# = getTag [r] xs in
      case x0 of {
        TAG1#  
         -> let x : Ptr# r Obj = getFieldOfBoxed [r] xs 0# in
            let xs' : Ptr# r Obj = getFieldOfBoxed [r] xs 1# in
            xs;
        _ 
         -> def
      }
}


-- Take the head of a polymorphic list
-- BROKEN: need to handle polymorphic types better in lite -> salt conversion.
--:to-salt..
--module Main with letrec
--head    [r : %] [a : *] (def : a)
--        (xs : List r a) {Read r | DeepUse a}
--        : a
-- = case xs of
--        Cons x xs'      -> x
--        _               -> def;;


-- Construct a singleton list,
--      packs a Boxed objet.
ok
module Main with
letrec {
  singleton : [r1 r2 : %].Int r2 -(Alloc r1 | Use r1)> List r1 (Int r2)
    = /\(r1 r2 : %).
       \(x : Int r2).
      let x0 : List r1 (Int r2)
            = Nil [r1] [Int r2] () in
      Cons [r1] [Int r2] x x0
}


-- Construct a singleton list,
--      packs a Boxed object.
-- BROKEN: need to construct unit values.
--:to-salt..
--module Main with letrec
--singleton [r1 r2 : %] (x : Int r2) { Alloc r1 | Use r1 } 
--        : List r1 (Int r2)
-- = Cons [r1] [Int r2] x (Nil [r1] [Int r2] ());;


-- Full application.
module Main with
letrec {
  addInt : [r1 r2 r3 : %].Ptr# r1 Obj -> Ptr# r2 Obj -> Ptr# r3 Obj
    = /\(r1 r2 r3 : %).
       \(x : Ptr# r1 Obj).\(y : Ptr# r2 Obj).
      let x0 : Tag# = getTag [r1] x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall [r1] x in
            let i1 : Int# = read# [Int#] x1 0# in
            let x2 : Tag# = getTag [r2] y in
            case x2 of {
              TAG0#  
               -> let x3 : Addr# = payloadOfRawSmall [r2] y in
                  let i2 : Int# = read# [Int#] x3 0# in
                  let x4 : Ptr# r3 Obj = allocRawSmall [r3] TAG0# 8# in
                  let x5 : Addr# = payloadOfRawSmall [r3] x4 in
                  let x6 : Int# = add# [Int#] i1 i2 in
                  let _ : Void# = write# [Int#] x5 0# x6 in
                  x4;
              _ 
               -> fail# [Ptr# r3 Obj]
            };
        _ 
         -> fail# [Ptr# r3 Obj]
      };
  
  double : [r1 r2 : %].Ptr# r1 Obj -> Ptr# r2 Obj
    = /\(r1 r2 : %).
       \(x : Ptr# r1 Obj). addInt [r1] [r1] [r2] x x
}

