ok
ok
ok


-- Intransitive test: should generate two aliases for r2 and put them in different trees
%s.Obj = type <{i64}>
@DDC.Runtime.heapTop = external global  i64
declare external ccc i64 @malloc(i64 ) align 8
declare external ccc void @abort() align 8
declare external ccc %s.Obj* @allocBoxed(i32 , i64 ) align 8
declare external ccc %s.Obj* @allocRawSmall(i32 , i64 ) align 8
declare external ccc %s.Obj* @getFieldOfBoxed(%s.Obj* , i64 ) align 8
declare external ccc i32 @getTag(%s.Obj* ) align 8
declare external ccc %s.Obj* @payloadOfRawSmall(%s.Obj* ) align 8
declare external ccc void @setFieldOfBoxed(%s.Obj* , i64 , %s.Obj* ) align 8

define external ccc i64 @foo(%s.Obj*  %w1) align 8  
{
l7.entry:
        ret i64 42
}

define external ccc i64 @bar() align 8  
{
l15.entry:
        %x0          = call %s.Obj* @allocBoxed (i32 0, i64 0) 
        %_v16        = call i64 @foo (%s.Obj* %x0) 
        ret i64 %_v16
}



!4 = metadata !{!"foo_ROOT_4", null, i11}
!5 = metadata !{!"foo_r2", !4, i10}
!6 = metadata !{!"foo_r3", !4, i10}
!1 = metadata !{!"foo_ROOT_1", null, i11}
!2 = metadata !{!"foo_r1", !1, i10}
!3 = metadata !{!"foo_r2", !1, i10}
!12 = metadata !{!"bar_ROOT_12", null, i11}
!13 = metadata !{!"bar_reg2", !12, i10}
!14 = metadata !{!"bar_reg3", !12, i10}
!9 = metadata !{!"bar_ROOT_9", null, i11}
!10 = metadata !{!"bar_reg1", !9, i10}
!11 = metadata !{!"bar_reg2", !9, i10}

-- Bound name shadowing across the module should be ok
ok
%s.Obj = type <{i64}>
@DDC.Runtime.heapTop = external global  i64
declare external ccc i64 @malloc(i64 ) align 8
declare external ccc void @abort() align 8
declare external ccc %s.Obj* @allocBoxed(i32 , i64 ) align 8
declare external ccc %s.Obj* @allocRawSmall(i32 , i64 ) align 8
declare external ccc %s.Obj* @getFieldOfBoxed(%s.Obj* , i64 ) align 8
declare external ccc i32 @getTag(%s.Obj* ) align 8
declare external ccc %s.Obj* @payloadOfRawSmall(%s.Obj* ) align 8
declare external ccc void @setFieldOfBoxed(%s.Obj* , i64 , %s.Obj* ) align 8

define external ccc i64 @strange(%s.Obj*  %w) align 8  
{
l4.entry:
        ret i64 42
}

define external ccc %s.Obj* @strangeAdd(%s.Obj*  %w1, %s.Obj*  %w2) align 8  
{
l15.entry:
        %x3          = call %s.Obj* @allocBoxed (i32 0, i64 0) 
        %foo         = call i64 @strange (%s.Obj* %x3) 
        %x4          = call i32 @getTag (%s.Obj* %x) 
        switch i32 %x4, label %l23.default [ i32 0,label %l16.alt ]
l16.alt:
        %x5          = call %s.Obj* @payloadOfRawSmall (%s.Obj* %x) 
        %x6          = bitcast %s.Obj* %x5 to i64*
        %i1.addr1    = ptrtoint i64* %x6 to i64
        %i1.addr2    = add i64 %i1.addr1, 0
        %i1.ptr      = inttoptr i64 %i1.addr2 to i64*
        %i1          = load i64* %i1.ptr,    !tbaa !7
        %x7          = call i32 @getTag (%s.Obj* %y) 
        switch i32 %x7, label %l22.default [ i32 0,label %l17.alt ]
l17.alt:
        %x8          = call %s.Obj* @payloadOfRawSmall (%s.Obj* %y) 
        %x9          = bitcast %s.Obj* %x8 to i64*
        %i2.addr1    = ptrtoint i64* %x9 to i64
        %i2.addr2    = add i64 %i2.addr1, 0
        %i2.ptr      = inttoptr i64 %i2.addr2 to i64*
        %i2          = load i64* %i2.ptr,    !tbaa !10, !tbaa !8
        %x0          = add i64 %i1, %i2
        %x10         = call %s.Obj* @allocRawSmall (i32 0, i64 8) 
        %x11         = call %s.Obj* @payloadOfRawSmall (%s.Obj* %x10) 
        %x12         = bitcast %s.Obj* %x11 to i64*
        %_v18.addr1  = ptrtoint i64* %x12 to i64
        %_v19.addr2  = add i64 %_v18.addr1, 0
        %_v20.ptr    = inttoptr i64 %_v19.addr2 to i64*
        store i64 %x0, i64* %_v20.ptr,    !tbaa !11
        ret %s.Obj* %x10
l22.default:
        call void @abort () 
        unreachable
l23.default:
        call void @abort () 
        unreachable
}

define external ccc %s.Obj* @strangeMain() align 8  
{
l30.entry:
        %x13         = call %s.Obj* @allocRawSmall (i32 0, i64 8) 
        %x14         = call %s.Obj* @payloadOfRawSmall (%s.Obj* %x13) 
        %x15         = bitcast %s.Obj* %x14 to i64*
        %_v31.addr1  = ptrtoint i64* %x15 to i64
        %_v32.addr2  = add i64 %_v31.addr1, 0
        %_v33.ptr    = inttoptr i64 %_v32.addr2 to i64*
        store i64 5, i64* %_v33.ptr,    !tbaa !25
        %x16         = call %s.Obj* @allocRawSmall (i32 0, i64 8) 
        %x17         = call %s.Obj* @payloadOfRawSmall (%s.Obj* %x16) 
        %x18         = bitcast %s.Obj* %x17 to i64*
        %_v34.addr1  = ptrtoint i64* %x18 to i64
        %_v35.addr2  = add i64 %_v34.addr1, 0
        %_v36.ptr    = inttoptr i64 %_v35.addr2 to i64*
        store i64 3, i64* %_v36.ptr,    !tbaa !28, !tbaa !26
        %x           = call %s.Obj* @strangeAdd (%s.Obj* %x13, %s.Obj* %x16) 
        %_v37        = call %s.Obj* @allocBoxed (i32 0, i64 0) 
        ret %s.Obj* %_v37
}



!1 = metadata !{!"strange_ROOT_1", null, i11}
!2 = metadata !{!"strange_r1", !1, i10}
!3 = metadata !{!"strange_r2", !1, i10}
!12 = metadata !{!"strangeAdd_ROOT_12", null, i11}
!13 = metadata !{!"strangeAdd_r1", !12, i10}
!14 = metadata !{!"strangeAdd_r3", !12, i10}
!9 = metadata !{!"strangeAdd_ROOT_9", null, i11}
!10 = metadata !{!"strangeAdd_r2", !9, i10}
!11 = metadata !{!"strangeAdd_ret", !9, i10}
!6 = metadata !{!"strangeAdd_ROOT_6", null, i11}
!7 = metadata !{!"strangeAdd_r0", !6, i11}
!8 = metadata !{!"strangeAdd_r2", !6, i10}
!27 = metadata !{!"strangeMain_ROOT_27", null, i11}
!28 = metadata !{!"strangeMain_r2", !27, i10}
!29 = metadata !{!"strangeMain_r3", !27, i10}
!24 = metadata !{!"strangeMain_ROOT_24", null, i11}
!25 = metadata !{!"strangeMain_r1", !24, i11}
!26 = metadata !{!"strangeMain_r2", !24, i10}
