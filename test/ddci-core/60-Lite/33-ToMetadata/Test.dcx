:set lang Lite
:set +Indent +SuppressImports
:set builder x86_64-darwin


-- Intransitive test: should generate two aliases for r2 and put them in different trees
:to-llvm..
module Test with letrec
foo [r1 r2 r3 : %] <w1 : Distinct r1 r2> <w2 : Distinct r2 r3> (x : Unit) : Word64# = 42w64#

bar (_ : Unit) : Word64#
 = letregion reg1 in
   letregion reg2 with { wit1 : Distinct reg1 reg2 } in
   letregion reg3 with { wit2 : Distinct reg2 reg3 } in
   do   foo [:reg1 reg2 reg3:] <wit1> <wit2> ();;
   

-- Bound name shadowing across the module should be ok
--    should realise that the "distinct r1 r3" isn't referring to r1 and r3
--    in strangeMain
:set lang Lite
:to-llvm..
module Test with letrec
strange [r6 r7 : %] <w42 : Distinct r6 r7> (x : Unit) : Word64# = 42w64# 
 
strangeAdd [r0 r2 ret : %] 
           <w1 : Const r0>
           <w2 : Distinct r0 r2>
           <w3 : Distinct r2 ret>
           (x : Int r0) { !0 | Use ret } 
           (y : Int r2) { Read r0 + Read r2 + Alloc ret | Use r0 + Use ret}
            : Int ret
 =  letregion r1 in
    letregion r3 with {w : Distinct r1 r3} in
    do  foo = strange [:r1 r3:] <w> ()
        case x of { I# i1 
     -> case y of { I# i2 
     -> I# [ret] (add# [Int#] i1 i2) } }

strangeMain (_ : Unit) :  Unit
 = letregion r1 with { w1 : Const r1 } in
   letregion r2 with { w2 : Distinct r1 r2 } in
   letregion r3 with { w3 : Distinct r2 r3 } in
   do   x = strangeAdd [:r1 r2 r3:] <w1> <w2> <w3> (I# [r1] 5i#) (I# [r2] 3i#) 
        ();;