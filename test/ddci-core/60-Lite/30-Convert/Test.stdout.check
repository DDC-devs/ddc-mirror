
ok
ok


-- Integer boxing,
--      packs a RawSmall Object.
module Main with
letrec {
  boxInt : Int32# -> Ptr# Obj
    = \(i : Int32#).
      let x0 : Ptr# Obj = allocRawSmall TAG0# 4 in
      let x1 : Addr# = payloadOfRawSmall x0 in
      let _ : Void# = write# [Int32#] x1 0 i in
      x0
}


-- Integer unboxing,
--      unpacks a RawSmall Object.
module Main with
letrec {
  unboxInt : Ptr# Obj -> Int32#
    = \(x : Ptr# Obj).
      let x0 : Tag# = getTag x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall x in
            let i : Int32# = read# [Int32#] x1 0 in
            return# [Int32#] i;
        _ 
         -> fail# [Int32#]
      }
}


-- Nested case-expressions.
module Main with
letrec {
  addInt : Ptr# Obj -> Ptr# Obj -> Int32#
    = \(x y : Ptr# Obj).
      let x0 : Tag# = getTag x in
      case x0 of {
        TAG0#  
         -> let x1 : Addr# = payloadOfRawSmall x in
            let i1 : Int32# = read# [Int32#] x1 0 in
            let x2 : Tag# = getTag y in
            case x2 of {
              TAG0#  
               -> let x3 : Addr# = payloadOfRawSmall y in
                  let i2 : Int32# = read# [Int32#] x3 0 in
                  add# [Int32#] i1 i2;
              _ 
               -> fail# [Int32#]
            };
        _ 
         -> fail# [Int32#]
      }
}


-- Boxed addition
module Main with
letrec {
  addInt : Ptr# Obj -> Ptr# Obj -> Ptr# Obj
    = \(x y : Ptr# Obj).
      let x1 : Tag# = getTag x in
      case x1 of {
        TAG0#  
         -> let x2 : Addr# = payloadOfRawSmall x in
            let i1 : Int32# = read# [Int32#] x2 0 in
            let x3 : Tag# = getTag y in
            case x3 of {
              TAG0#  
               -> let x4 : Addr# = payloadOfRawSmall y in
                  let i2 : Int32# = read# [Int32#] x4 0 in
                  let x0 : Int32# = add# [Int32#] i1 i2 in
                  let x5 : Ptr# Obj = allocRawSmall TAG0# 4 in
                  let x6 : Addr# = payloadOfRawSmall x5 in
                  let _ : Void# = write# [Int32#] x6 0 x0 in
                  x5;
              _ 
               -> fail# [Ptr# Obj]
            };
        _ 
         -> fail# [Ptr# Obj]
      }
}


-- Construct a singleton list,
--      packs a Boxed objet.
module Main with
letrec {
  singleton : Ptr# Obj -> Ptr# Obj
    = \(x : Ptr# Obj).
      let x1 : Ptr# Obj = allocBoxed TAG0# 0 in
      let x2 : Ptr# Obj = allocBoxed TAG0# 8 in
      let x3 : Ptr# Obj = x2 in
      let x4 : Void# = setFieldOfBoxed x1 0 x3 in
      let x0 : Ptr# Obj = x2 in
      let x5 : Ptr# Obj = allocBoxed TAG1# 8 in
      let _ : Void# = setFieldOfBoxed x5 0 x in
      let _ : Void# = setFieldOfBoxed x5 1 x0 in
      x5
}


-- Take the head of an Int list,
--      unpacks a Boxed object.
module Main with
letrec {
  head : Ptr# Obj -> Ptr# Obj -> Ptr# Obj
    = \(def xs : Ptr# Obj).
      let x0 : Tag# = getTag xs in
      case x0 of {
        TAG1#  
         -> let x : Ptr# Obj = getFieldOfBoxed xs 0 in
            let xs' : Ptr# Obj = getFieldOfBoxed xs 1 in
            return# [Ptr# Obj] x;
        _ 
         -> return# [Ptr# Obj] def
      }
}


-- Take the tail of an Int list
module Main with
letrec {
  tail : Ptr# Obj -> Ptr# Obj -> Ptr# Obj
    = \(def xs : Ptr# Obj).
      let x0 : Tag# = getTag xs in
      case x0 of {
        TAG1#  
         -> let x : Ptr# Obj = getFieldOfBoxed xs 0 in
            let xs' : Ptr# Obj = getFieldOfBoxed xs 1 in
            return# [Ptr# Obj] xs;
        _ 
         -> return# [Ptr# Obj] def
      }
}


-- Take the head of a polymorphic list
module Main with
letrec {
  head : Ptr# Obj -> Ptr# Obj -> Ptr# Obj
    = \(def xs : Ptr# Obj).
      let x0 : Tag# = getTag xs in
      case x0 of {
        TAG1#  
         -> let x : Ptr# Obj = getFieldOfBoxed xs 0 in
            let xs' : Ptr# Obj = getFieldOfBoxed xs 1 in
            return# [Ptr# Obj] x;
        _ 
         -> return# [Ptr# Obj] def
      }
}


-- Boxed literal patterns.                              -- TODO: result isn't fully constructed
module Main with
letrec {
  foo : Ptr# Obj -> Ptr# Obj
    = \(x : Ptr# Obj).
      let x0 : Tag# = getTag x in
      case x0 of {
        TAG0#  
         -> let x1 : Ptr# Obj = allocRawSmall TAG0# 4 in
            let x2 : Addr# = payloadOfRawSmall x1 in
            x1;
        TAG1#  
         -> let x3 : Ptr# Obj = allocRawSmall TAG0# 4 in
            let x4 : Addr# = payloadOfRawSmall x3 in
            x3;
        TAG5#  
         -> let x5 : Ptr# Obj = allocRawSmall TAG0# 4 in
            let x6 : Addr# = payloadOfRawSmall x5 in
            x5;
        _ 
         -> let x7 : Ptr# Obj = allocRawSmall TAG0# 4 in
            let x8 : Addr# = payloadOfRawSmall x7 in
            x7
      }
}



-- Unboxed literal patterns
-- These don't work yet.

--:to-salt..
--module Main with letrec
--foo     (x : Bool#) : Bool#
-- = case x of
--        True#   -> False#
--        False#  -> True#;;


--:to-salt..
--module Main with letrec
--foo     (x : Word16#) : Word16#
-- = case x of
--        5w16#   -> 6w16#
--        7w16#   -> 8w16#
--        _       -> 0w16#;;


--:to-salt..
--module Main with letrec
--foo     (x : Int64#) : Int64#
-- = case x of
--        5i64#   -> 6i64#
--        7i64#   -> 8i64#
--        _       -> 0i64#;;


--:to-salt..
--module Main with letrec
--foo     (x : Int32#) : Int32#
-- = case x of
--        5i32#   -> 6i32#
--        7i32#   -> 8i32#
--        _       -> 0i32#;;

