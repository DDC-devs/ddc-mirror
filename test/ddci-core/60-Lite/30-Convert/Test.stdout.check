
ok
ok


-- Take the head of a list,
--      unpacks a Boxed object.
module Main with
letrec {
  head : Ptr# Obj -> Ptr# Obj -> Ptr# Obj
    = \(def xs : Ptr# Obj).
      case getTag xs of {
        TAG1#  
         -> let x : Ptr# Obj = fieldOfBoxed xs 0 in
            let xs' : Ptr# Obj = fieldOfBoxed xs 1 in
            return# [Ptr# Obj] def;
        _ 
         -> return# [Ptr# Obj] def
      }
}


-- Integer unboxing,
--      unpacks a RawSmall Object.
module Main with
letrec {
  unboxInt : Ptr# Obj -> Int32#
    = \(x : Ptr# Obj).
      case getTag x of {
        TAG0#  
         -> let x0 : Addr# = payloadOfRawSmall x in
            let i : Int32# = read# [Int32#] x0 0 in
            return# [Int32#] i;
        _ 
         -> fail# [Int32#]
      }
}


-- Nested case-expressions.
module Main with
letrec {
  addInt : Ptr# Obj -> Ptr# Obj -> Int32#
    = \(x y : Ptr# Obj).
      case getTag x of {
        TAG0#  
         -> let x0 : Addr# = payloadOfRawSmall x in
            let i1 : Int32# = read# [Int32#] x0 0 in
            case getTag y of {
              TAG0#  
               -> let x1 : Addr# = payloadOfRawSmall y in
                  let i2 : Int32# = read# [Int32#] x1 0 in
                  return# [Int32#] (add# [Int32#] i1 i2);
              _ 
               -> fail# [Int32#]
            };
        _ 
         -> fail# [Int32#]
      }
}


-- Boxed addition
-- TODO: this doesn't work yet.
--:to-salt..
--module Main with letrec
--addInt [r1 r2 r3 : %] 
--        (x : Int r1) { !0 | Use r3 } 
--        (y : Int r2) { Read r1 + Read r2 | Use r1 + Use r3}
--        : Int r3
-- =  case x of { I32# i1 
-- -> case y of { I32# i2 
-- -> I32# [r3] (add# [Int32#] i1 i2) } }
--;;
