
:set lang Lite
:set +Indent +SuppressImports


-- Integer boxing,
--      packs a RawSmall Object.
:to-salt..
module Main with letrec
boxInt [r : %] (i : Int32#) { Alloc r | Use r } : Int r
        = I32# [r] i;;


-- Integer unboxing,
--      unpacks a RawSmall Object.
:to-salt..
module Main with letrec
unboxInt [r : %] (x : Int r) { Read r | $0 } : Int32#
 = case x of 
        I32# i  -> i;;


-- Nested case-expressions.
:to-salt..
module Main with letrec
addInt [r1 r2 r3 : %] 
        (x : Int r1) { !0 | $0 } 
        (y : Int r2) { Read r1 + Read r2 | Use r1 }
        : Int32#
 =  case x of { I32# i1 
 -> case y of { I32# i2 
 -> add# [Int32#] i1 i2 } };;


-- Boxed addition
:to-salt..
module Main with letrec
addInt [r1 r2 r3 : %] 
        (x : Int r1) { !0 | Use r3 } 
        (y : Int r2) { Read r1 + Read r2 + Alloc r3 | Use r1 + Use r3}
        : Int r3
 =  case x of { I32# i1 
 -> case y of { I32# i2 
 -> I32# [r3] (add# [Int32#] i1 i2) } };;


-- Construct a singleton list,
--      packs a Boxed objet.
:to-salt..
module Main with letrec
singleton [r1 r2 : %] (x : Int r2) { Alloc r1 | Use r1 } 
        : List r1 (Int r2)
 = Cons [r1] [Int r2] x (Nil [r1] [Int r2] ());;


-- Take the head of an Int list,
--      unpacks a Boxed object.
:to-salt..
module Main with letrec
head    [r : %] (def : Int r) 
        (xs : List r (Int r))   { Read r | Use r } 
        : Int r
 = case xs of 
        Cons x xs'      -> x
        _               -> def;;


-- Take the tail of an Int list
:to-salt..
module Main with letrec
tail   [r : %] (def : List r (Int r))
       (xs : List r (Int r))   { Read r | Use r }
       : List r (Int r)
 = case xs of
        Cons x xs'      -> xs
        _               -> def;;


-- Take the head of a polymorphic list
:to-salt..
module Main with letrec
head    [r : %] [a : *] (def : a)
        (xs : List r a) {Read r | DeepUse a}
        : a
 = case xs of
        Cons x xs'      -> x
        _               -> def;;


-- Boxed literal patterns.                              -- TODO: result isn't fully constructed
:to-salt..
module Main with letrec
foo     [r : %] (x : Int r) {Read r + Alloc r | Use r}
        : Int r
 = case x of
        0       -> 1 [r] ()
        1       -> 2 [r] ()
        5       -> 5 [r] ()
        _       -> 3 [r] ();;



-- Unboxed literal patterns
-- These don't work yet.

--:to-salt..
--module Main with letrec
--foo     (x : Bool#) : Bool#
-- = case x of
--        True#   -> False#
--        False#  -> True#;;


--:to-salt..
--module Main with letrec
--foo     (x : Word16#) : Word16#
-- = case x of
--        5w16#   -> 6w16#
--        7w16#   -> 8w16#
--        _       -> 0w16#;;


--:to-salt..
--module Main with letrec
--foo     (x : Int64#) : Int64#
-- = case x of
--        5i64#   -> 6i64#
--        7i64#   -> 8i64#
--        _       -> 0i64#;;


--:to-salt..
--module Main with letrec
--foo     (x : Int32#) : Int32#
-- = case x of
--        5i32#   -> 6i32#
--        7i32#   -> 8i32#
--        _       -> 0i32#;;

