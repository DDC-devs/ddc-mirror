

ok


-- Literals
5
:*: [^ : %].Unit -(Alloc ^0 | $0)> Int ^0
:!: !0
:$: $0


-- Primitives
add#
:*: [^ : *].^0 -> ^0 -> ^0
:!: !0
:$: $0

Int :: % ~> *
Bool :: % ~> *


-- Boxing bools
/\(r : %). \(x : Bool#). B# [r] x
:*: [r : %].Bool# -(!0 | Use r)> Bool r
:!: !0
:$: $0


-- Unboxing bools.
/\(r : %). \(x : Bool r). case x of { B# (b : Bool#) -> b }
:*: [r : %].Bool r -(Read r | $0)> Bool#
:!: !0
:$: $0


-- Boxing ints
/\(r : %). \(x : Int32#). I32# [r] x
:*: [r : %].Int32# -(!0 | Use r)> Int r
:!: !0
:$: $0


-- Unboxing ints
/\(r : %). \(x : Int r). case x of { I32# (i : Int32#) -> i }
:*: [r : %].Int r -(Read r | $0)> Int32#
:!: !0
:$: $0


-- Boxed integer add
let unboxInt : [r : %].Int r -(Read r | $0)> Int32# = /\(r : %). \(x : Int r). case x of { I32# (i : Int32#) -> i } in let addInt : [r1 r2 r3 : %].Int r1 -(!0 | Use r3)> Int r2 -(Read r1 + Read r2 | Use r1 + Use r3)> Int r3 = /\(r1 r2 r3 : %). \(x : Int r1). \(y : Int r2). case x of { I32# (i1 : Int32#) -> case y of { I32# (i2 : Int32#) -> I32# [r3] (add# [Int32#] i1 i2) } } in letregion r1 in unboxInt [r1] (addInt [r1] [r1] [r1] (2 [r1] ()) (3 [r1] ()))
:*: Int32#
:!: !0
:$: $0
