-- Parse letregion with no witnesses
:check letregion r1 in ()


-- Parse letregion with one witness.
:check letregion r1 with { w1 : Const r1 } in ()


-- Parse letregion with multiple witnesses.
:check letregion r1 with { w1 : Const r1; w2 : Manifest r1 } in ()


-- Use the bound region in the body of the expression.
:check letregion r1 in addInt [:r1 r1 R2#:] (2 [r1] ()) (3 [r1] ())


-- As above, but with debruijn indices.
:check letregion ^  in addInt [:^0 ^0 R2#:] (2 [^0] ()) (3 [^0] ())


-- Error: withregion must contain a region variable or constructor.
:check (\(e:!). withregion e in ())


-- Error: cannot shadow region variables that are already in the
-- environment because the new witnesses may conflict with the old ones.
:check..
letregion r1 with {w1 : Const r1}   in
let x : Int r1 = 5 [r1] () in
letregion r1 with {w1 : Mutable r1} in
updateInt [:r1 r1:] <w1> x (0 [r1] ());;


-- Error: bound region variable is free in the type of the body of a letregion.
:check letregion r1 in 4 [r1] ()


-- Error: bound region is free in the effect of a returned function.
:check..
letregion r1 with {w1 : Const r1} in
\(x:Unit). (addInt [:r1 r1 R2#:] (2 [r1] ()) (3 [r1] ()));;
