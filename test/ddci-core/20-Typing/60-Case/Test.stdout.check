-- Error: types of alternatives are not identical.
Mismatch in alternative result types.
   Type of alternative: Int R0#
        does not match: Unit

with: case 5 [R0#] () of {
        0  
         -> 0 [R0#] ();
        _ 
         -> ()
      }


-- Error: discriminant type is not a data type.
Discriminant of case expression is not algebraic data.
     Discriminant type: Unit -> Unit

with: case \(x : Unit). x of {
        _ 
         -> ()
      }


-- Error: pattern binds more fields than provided by constructor.
Pattern has more binders than there are fields in the constructor.
     Contructor: Cons
            has: 2 fields
  but there are: 3 binders in the pattern

with: case xx of {
        Nil  
         -> ();
        Cons x xs ys 
         -> ()
      }


-- Error: annotation on pattern variable does not match field type
--        of constructor.
Annotation on pattern variable does not match type of field.
       Annotation type: Unit
            Field type: Int R0#

with: case xx of {
        Nil  
         -> ();
        Cons (x : Unit) xs 
         -> ()
      }


-- Error: alternatives are not exhaustive, for a Small type.
Case alternatives are non-exhaustive.
 Constructors not matched: Nil

with: case xx of {
        Cons _ _ 
         -> ()
      }


-- Error: alternatives are not exhaustive, for a Large type.
Case alternatives are non-exhaustive.

with: case xx of {
        0  
         -> ()
      }


-- Error: alternatives are overlapping due to multiple defaults.
Case alternatives are overlapping.

with: case xx of {
        _ 
         -> ();
        _ 
         -> ()
      }


-- Error: alternatives are overlapping because there is a default
--        earlier in the list.
Case alternatives are overlapping.

with: case xx of {
        5  
         -> ();
        _ 
         -> ();
        0  
         -> ()
      }


-- Error: alternatives are overlapping because the same constructor
--        appears multiple times.
Case alternatives are overlapping.

with: case xx of {
        0  
         -> ();
        0  
         -> ();
        _ 
         -> ()
      }


-- Error: pattern and discriminant types don't match.
Cannot instantiate constructor type with discriminant type args.
 Either the constructor has an invalid type,
 or the type of the discriminant does not match the type of the pattern.
      Constructor type: List R0# (Int R0#)
     Discriminant type: Unit

with: case xx1 of {
        ()  
         -> ()
      }


-- Error: pattern and discriminant types don't match.
Discriminant type does not match result of pattern type.
     Discriminant type: Int R0#
          Pattern type: [^ : *].Unit -(Alloc R0# | $0)> List R0# ^0

with: case xx of {
        Nil  
         -> ()
      }


-- Check that vars in alts are masked from closure
-- and effect includes the read of the discriminant.
let xx : List R0# (Int R0#) = Nil [R0#] [Int R0#] () in case xx of { Nil -> 0 [R0#] (); Cons (x : Int R0#) (xs : List R0# (Int R0#)) -> x }
:*: Int R0#
:!: Read R0# + Alloc R0#
:$: Use R0#


-- Check that the HeadRead effect is crushed out when
-- the read is on a type with no head region.
case () of { () -> () }
:*: Unit
:!: !0
:$: $0
