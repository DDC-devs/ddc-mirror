

-- Error: types of alternatives are not identical.
:check..
case 5 [R0#] () of {
        0 -> 0 [R0#] ();
        _ -> ();
};;


-- Error: discriminant type is not a data type.
:check..
case \(x : Unit). x of {
        _ -> ()
};;


-- Error: pattern and discriminant types don't match.
:check..
let xx0  = Nil  [R0#] [Int R0#] () in
let xx1  = Cons [R0#] [Int R0#] (5 [R0#] ()) xx0 in
case xx1 of {
        ()  -> ()
};;


-- Error: pattern binds more fields than provided by constructor.
:check..
let xx = Nil [R0#] [Int R0#] () in
case xx of {
        Nil          -> ();
        Cons x xs ys -> ();
};;


-- Error: annotation on pattern variable does not match field type
--        of constructor.
:check..
let xx = Nil [R0#] [Int R0#] () in
case xx of {
        Nil                  -> ();
        Cons (x:Unit) xs     -> ();
};;


-- Ok: check that vars in alts are masked from closure
:check..
let xx = Nil [R0#] [Int R0#] () in
case xx of {
        Nil       -> 0 [R0#] ();
        Cons x xs -> x;
};;


-- Error: alternatives are not exhaustive, for a Small type.
:check..
\(xx:List R0# (Int R1#)).
case xx of {
        Cons _ _        -> ()
};;


-- Error: alternatives are not exhaustive, for a Large type.
:check..
\(xx:Int R0#).
case xx of {
        0       -> ();
};;

