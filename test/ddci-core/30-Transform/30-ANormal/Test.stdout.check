ok
ok


-- Identity function
let ^
      = \(x : Unit). x in
^0 ()


-- Identify function with indices.
let ^
      = \(^ : Unit). ^0 in
^0 ()


-- Primitive
let ^ = 1 [R0#] () in
let ^ = 2 [R0#] () in
addInt [R0#] [R0#] [R0#] ^1 ^0
3


-- Nested applications
let ^ = 1 [R0#] () in
let ^ = 2 [R1#] () in
let ^ = 3 [R3#] () in
let ^ = 4 [R3#] () in
let ^ = addInt [R3#] [R3#] [R1#] ^1 ^0 in
let ^ = addInt [R1#] [R1#] [R1#] ^3 ^0 in
addInt [R0#] [R1#] [R2#] ^5 ^0
10


-- Lets in args (inner x must be anonymized)
let x : Int R1# = 2 [R1#] () in
let ^ : Unit = () in
let ^ : [^ : %].Unit -(Alloc ^0 | $0)> Int ^0 = 1 in
let ^ = ^0 [R0#] ^1 in
addInt [R0#] [R1#] [R2#] ^0 x
3


-- Type abstraction
let ^
      = /\(t : *).
         \(x : t). x in
let ^
      = Nil [R0#] [Int R0#] () in
^1 [List R0# (Int R0#)] ^0


-- Primitive in case exp
let ^
      = \(u : Unit).
        let ^ = 1 [R0#] u in
        case ^0 of {
          0  
           -> 1 [R0#] u;
          _ 
           -> let ^ = 2 [R0#] u in
              let ^ = 3 [R0#] u in
              addInt [R0#] [R0#] [R0#] ^1 ^0
        } in
^0 ()
5


-- Anonymous binders
let ^ : Int R0# = 5 [R0#] () in
let ^ = 3 [R0#] () in
addInt [R0#] [R0#] [R0#] ^1 ^0
8


-- Arity
let cmp : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let f' : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(x : Int R0#).
        let ^ = g x in
        f' ^0 in
let up : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(n : Int R0#).
        let ^ = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] n ^0 in
let ^ = 1 [R0#] () in
cmp up up ^0
3


-- Arity anon
let ^ : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(^ : Int R0#).
        let ^ = g ^0 in
        ^2 ^0 in
let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(^ : Int R0#).
        let ^ = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] ^1 ^0 in
let ^ = 1 [R0#] () in
^2 ^1 ^1 ^0
3


-- Letrec
letrec {
  fac : [r : %].Int r -(Read r + Alloc r | Use r)> Int r
    = /\(r : %).
       \(n : Int r).
      case n of {
        0  
         -> 1 [r] ();
        _ 
         -> let ^ = 1 [r] () in
            let ^ = subInt [r] [r] [r] n ^0 in
            let ^ = fac [r] ^0 in
            mulInt [r] [r] [r] n ^0
      }
} in
let ^ = 5 [R1#] () in
fac [R1#] ^0
120


-- Snip out discriminants of case expressions
let ^
      = \(x : Int R0#). x in
let ^ = 5 [R0#] () in
let ^ = ^1 ^0 in
case ^0 of {
  _ 
   -> ()
}

