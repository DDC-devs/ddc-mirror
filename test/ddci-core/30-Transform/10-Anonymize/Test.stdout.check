
ok

-- Anonymize lambdas and applications.
-- Broken: the Use closure term on the first function arrow is lost
/\(^ : %). \(^ ^ : Int ^0). addInt [^0] [^0] [^0] ^1 ^0


-- Single let
let ^ : Unit = () in ^0


-- Multiple lets
let ^ : Unit = () in let ^ : Int R1# = 5 [R1#] () in ^1


-- letregion
letregion ^ with {^ : Const ^0} in addInt [^0] [^0] [R0#] (2 [^0] ()) (2 [^0] ())


-- letregion and lets
letregion ^ with {^ : Const ^0} in let ^ : Int ^0 = 2 [^0] () in let ^ : Int ^0 = 3 [^0] () in addInt [^0] [^0] [R0#] ^1 ^0


-- case expressions
\(^ : List R0# (Int R1#)). case ^0 of { Nil -> ^0; Cons (^ : Int R1#) (^ : List R0# (Int R1#)) -> Cons [R0#] [Int R1#] ^1 ^2 }


-- letrec expressions
letrec { ^ : [^ : %]. [^ : *].List ^1 ^0 -(!0 | Use ^1)> List ^1 ^0 -(Read ^1 + Alloc ^1 | Use ^1 + DeepUse ^0)> List ^1 ^0 = /\(^ : %). /\(^ : *). \(^ ^ : List ^1 ^0). case ^1 of { Nil -> ^0; Cons (^ : ^0) (^ : List ^1 ^0) -> Cons [^1] [^0] ^1 (^4 [^1] [^0] ^0 ^2) } } in ()
