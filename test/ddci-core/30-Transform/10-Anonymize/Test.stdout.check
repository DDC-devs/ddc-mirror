
ok

-- Anonymize lambdas and applications.
/\(^ : %). \(^ ^ : Int ^0). addInt [^0] [^0] [^0] ^1 ^0


-- Anonymize lambdas and applications.
-- Spec and value binder have the same name.
/\(^ : %). \(^ : Int ^0). addInt [^0] [^0] [^0] ^0 ^0


-- Single let
let ^ : Unit = () in ^0


-- Multiple lets
let ^ : Unit = () in let ^ : Int R1# = 5 [R1#] () in ^1


-- letregion
letregion ^ with {^ : Const ^0} in addInt [^0] [^0] [R0#] (2 [^0] ()) (2 [^0] ())


-- letregion and lets
letregion ^ with {^ : Const ^0} in let ^ : Int ^0 = 2 [^0] () in let ^ : Int ^0 = 3 [^0] () in addInt [^0] [^0] [R0#] ^1 ^0


-- case expressions
\(^ : List R0# (Int R1#)). case ^0 of { Nil -> ^0; Cons (^ : Int R1#) (^ : List R0# (Int R1#)) -> Cons [R0#] [Int R1#] ^1 ^2 }


-- letrec expressions
letrec { ^ : [^ : %]. [^ : *].List ^1 ^0 -(!0 | Use ^1)> List ^1 ^0 -(Read ^1 + Alloc ^1 | Use ^1 + DeepUse ^0)> List ^1 ^0 = /\(^ : %). /\(^ : *). \(^ ^ : List ^1 ^0). case ^1 of { Nil -> ^0; Cons (^ : ^0) (^ : List ^1 ^0) -> Cons [^1] [^0] ^1 (^4 [^1] [^0] ^0 ^2) } } in ()


-- Mixed spec and value binders.
let ^ : [^ ^ : %].Unit -(Read ^1 + Alloc ^0 + Alloc ^1 | Use ^0 + Use ^1)> Pair ^1 (Int ^1) (Int ^0) = /\(^ ^ : %). \(^ : Unit). let ^ : Int ^1 = 5 [^1] () in let ^ : Int ^0 = letregion ^ in addInt [^2] [^0] [^1] ^0 (1 [^0] ()) in Pr [^1] [Int ^1] [Int ^0] ^1 ^0 in letregion ^ in letregion ^ in case ^0 [^1] [^0] () of { Pr (^ : Int ^1) (^ : Int ^0) -> copyInt [^0] [R0#] ^0 }


-- Mixed spec and value and witness binders, 
-- With spec binders interspersed with the others, and a non-binder.
let ^ : [^ : %].Const ^0 => Global ^0 => [^ : %].Const ^0 => Global ^0 => Lazy ^0 => Unit -(Alloc ^1 | Use ^1)> Pair ^1 (Int ^1) (Int ^0) = /\(^ : %). \(^ : Const ^0). \(^ : Global ^0). /\(^ : %). \(^ : Const ^0). \(^ : Global ^0). \(^ : Lazy ^0). \(^ : Unit). let ^ : Int ^1 = 5 [^1] () in let ^ : Int ^0 lazy <^2> = purify <read [^1] ^6 & alloc [^1] ^6 & alloc [^0] ^4> in forget <use [^1] ^5 & use [^0] ^3> in letregion ^ in addInt [^2] [^0] [^1] ^0 (1 [^0] ()) in Pr [^1] [Int ^1] [Int ^0] ^1 ^0 in letregion ^ with {^ : Const ^0; ^ : Global ^0} in letregion ^ with {^ : Const ^0; ^ : Global ^0; ^ : Lazy ^0} in case ^5 [^1] <^4> <^3> [^0] <^2> <^1> <^0> () of { Pr (^ : Int ^1) (^ : Int ^0) -> copyInt [^0] [R0#] ^0 }
