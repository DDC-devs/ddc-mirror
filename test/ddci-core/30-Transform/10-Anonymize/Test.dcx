
:set trans Anonymize

-- Anonymize lambdas and applications.
:trans..
/\(r:%).\(x : Int r) (y : Int r). addInt [:r r r:] x y;;


-- Single let
:trans..
let x = () in x;;


-- Multiple lets
:trans..
let x = () in let y = 5 [R1#] () in x;;


-- letregion
:trans..
letregion r with {w : Const r} in
addInt [:r r R0#:] (2 [r] ()) (2 [r] ());;


-- letregion and lets
:trans..
letregion r with {w : Const r} in
let x = 2 [r] () in
let y = 3 [r] () in
addInt [:r r R0#:] x y;;


-- case expressions
:trans..
\(xx : List R0# (Int R1#)).
case xx of {
        Nil             -> xx;
        Cons ^ ^        -> Cons [R0#] [Int R1#] ^1 xx;
};;


-- letrec expressions
:trans..
letrec {
 append  [r : %] [a : *]
         (xx : List r a) {!0               | Use r}
         (ys : List r a) {Read r + Alloc r | Use r + DeepUse a}
         : List r a
  = case xx of {
          Nil           -> ys;
          Cons x xs     -> Cons [:r a:] x (append [:r a:] xs ys);
    }
} in ();;


-- Mixed spec and value binders.
:trans..
let foo [r1 r2 : %] (_ : Unit)
     = let x = 5 [r1] () in
       let y = letregion r3 in
               addInt [:r1 r3 r2:] x (1 [r3] ()) in
       Pr [r1] [Int r1] [Int r2] x y

in  letregion r4 in
    letregion r5 in
    case foo [:r4 r5:] () of {
            Pr _ y -> copyInt [:r5 R0#:] y
    };;

