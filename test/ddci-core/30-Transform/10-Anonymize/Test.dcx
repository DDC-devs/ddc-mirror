
:set trans Anonymize

-- Anonymize lambdas and applications.
-- Broken: the Use closure term on the first function arrow is lost
:trans..
/\(r:%).\(x : Int r) (y : Int r). addInt [:r r r:] x y;;


-- Single let
:trans..
let x = () in x;;


-- Multiple lets
:trans..
let x = () in let y = 5 [R1#] () in x;;


-- letregion
:trans..
letregion r with {w : Const r} in
addInt [:r r R0#:] (2 [r] ()) (2 [r] ());;


-- letregion and lets
:trans..
letregion r with {w : Const r} in
let x = 2 [r] () in
let y = 3 [r] () in
addInt [:r r R0#:] x y;;


-- case expressions
:trans..
\(xx : List R0# (Int R1#)).
case xx of {
        Nil             -> xx;
        Cons ^ ^        -> Cons [R0#] [Int R1#] ^1 xx;
};;


-- letrec expressions
:trans..
letrec {
 append  [r : %] [a : *]
         (xx : List r a) {!0               | Use r}
         (ys : List r a) {Read r + Alloc r | Use r + DeepUse a}
         : List r a
  = case xx of {
          Nil           -> ys;
          Cons x xs     -> Cons [:r a:] x (append [:r a:] xs ys);
    }
} in ();;
