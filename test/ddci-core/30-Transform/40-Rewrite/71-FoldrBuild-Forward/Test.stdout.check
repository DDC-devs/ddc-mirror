ok
ok

ok
ok

ok, added foldrBuild

ok

-- define outside, otherwise beta reduction won't fire...
* TRANSFORM INFORMATION: 
    Inline: No information;
    fix 10:
        Beta reduction:
            Types:          0
            Witnesses:      0
            Values:         1
            Values letted:  1
            Values skipped: 0;
        Forward:
            Substitutions:  0
            Bindings:       0;
        Rules fired:
            Unfold:  foldrBuild
            Rewrite: foldrBuild;
        Beta reduction:
            Types:          0
            Witnesses:      0
            Values:         0
            Values letted:  0
            Values skipped: 0;
        Forward:
            Substitutions:  0
            Bindings:       0;
        Rules fired:
            Unfold:  foldrBuild

let num : Int R0# = 10 [R0#] () in
let ^ : [^ : *].[^ ^ ^ : !].[^ ^ ^ : $].(Int R0# -(^5 | ^2)> ^6 -(^4 | ^1)> ^6) -(!0 | Use R0#)> (Unit -(^3 | ^0)> ^6) -(Read R0# + Alloc R0# + ^3 + ^4 + ^5 | Use R0# + ^2)> ^6 = count' num in
let ^ : [^ : *].[^ ^ ^ : !].[^ ^ ^ : $].(Int R0# -(^5 | ^2)> ^6 -(^4 | ^1)> ^6) -(!0 | Use R0#)> (Unit -(^3 | ^0)> ^6) -(Read R0# + Alloc R0# + ^3 + ^4 + ^5 | Use R0# + ^2)> ^6 = ^0 in
let ^ : List R1# (Int R0#)
      = build [Int R0#] [R1#] [!0] [Read R0# + Alloc R0#] [Use R0#] [Use R0#] ^0 in
weakeff [Read R0# + Read R1# + Alloc R0# + Alloc R1#] in
weakclo {build; foldr; [Int R0#]; [Use R0#]; [Use R0#]; [!0]; [Read R0# + Alloc R0#]; [R1#]} in
^2 [Int R0#] [!0] [Read R0# + Alloc R0#] [Alloc R0#] [Use R0#] [Use R0#] [Use R0#] plus zero

ok

-- define outside, otherwise beta reduction won't fire...
* TRANSFORM INFORMATION: 
    fix 30:
        Forward:
            Substitutions:  4
            Bindings:       4;
        Beta reduction:
            Types:          0
            Witnesses:      0
            Values:         3
            Values letted:  0
            Values skipped: 3;
        Rules fired:
            ;
        Forward:
            Substitutions:  0
            Bindings:       0;
        Beta reduction:
            Types:          0
            Witnesses:      0
            Values:         0
            Values letted:  0
            Values skipped: 3;
        Rules fired:
            

let num : Int R0# = 10 [R0#] () in
(\(xs : List R1# (Int R0#)).
 foldr [Int R0#] [Int R0#] [R1#] [!0] [Read R0# + Alloc R0#] [Alloc R0#] [Use R0#] [Use R0#] [Use R0#] plus zero xs)
    ((\(xs : List R1# (Int R0#)).
      build [Int R0#] [R1#] [!0] [Read R0# + Read R1# + Alloc R0#] [Use R0# + Use R1#] [Use R0# + Use R1#]
          (/\(bF : *)./\(ec1F ec2F enF : !)./\(cc1F cc2F cnF : $).
            \(c : Int R0# -(ec1F | cc1F)> bF -(ec2F | cc2F)> bF).\(n : Unit -(enF | cnF)> bF).
           foldr [Int R0#] [bF] [R1#] [!0] [Read R0# + Alloc R0# + ec1F + ec2F] [enF] [Use R0# + cc1F] [Use R0# + cc1F] [cnF]
               (\(x : Int R0#).\(xs : bF).
                case even x of {
                  0  
                   -> c x xs;
                  _ 
                   -> xs
                }) n xs))
         ((\(xs : List R1# (Int R0#)).
           build [Int R0#] [R1#] [!0] [Read R0# + Read R1# + Alloc R0#] [Use R0# + Use R1#] [Use R0# + Use R1#]
               (/\(b : *)./\(ec1 ec2 en : !)./\(cc1 cc2 cn : $).
                 \(c : Int R0# -(ec1 | cc1)> b -(ec2 | cc2)> b).\(n : Unit -(en | cn)> b).
                foldr [Int R0#] [b] [R1#] [Read R0# + Alloc R0# + ec1] [ec2] [en] [Use R0# + cc1] [cc2] [cn]
                    (compose [Int R0#] [Int R0#] [b -(ec2 | cc2)> b] [ec1] [Read R0# + Alloc R0#] [cc1] [Use R0#] c double) n xs))
              (build [Int R0#] [R1#] [!0] [Read R0# + Alloc R0#] [Use R0#] [Use R0#] (count' num))))
