ok

-- add zero on right. make copy
ok, added add0r
ok, added add0l

-- should work with any regions
ok
weakeff [Read R0# + Alloc R0#] in
weakclo {[R0#]} in
copyInt [R0#] [R0#] (5 [R0#] ())

weakeff [Read R1# + Read R2# + Alloc R2# + Alloc R3#] in
weakclo {[R2#]} in
copyInt [R1#] [R3#] (5 [R1#] ())

-- addInt is strict & closure free so we can reduce any copies in its args
ok, added addCopy1

ok, added addCopy2


-- simplify some nested zeroes
ok
weakeff [Read R0# + Read R1# + Alloc R1# + Alloc R2#] in
weakclo {[R1#]} in
copyInt [R0#] [R2#]
    (weakeff [Read R0# + Alloc R0#] in
     weakclo {[R0#]} in
     copyInt [R0#] [R0#] (5 [R0#] ()))


-- we can simplify out a copy of a literal.
ok, added copyLit
-- and a copy of a copy
ok, added copyCopy

-- some more nested zeroes
ok
weakeff [Read R0# + Read R1# + Alloc R1# + Alloc R2#] in
weakclo {[R1#]} in
copyInt [R0#] [R2#]
    (weakeff [Read R0# + Alloc R0#] in
     weakclo {[R0#]} in
     weakeff [Read R0# + Alloc R0#] in
     weakclo {[R0#]} in
     5 [R0#] ())

-- add a let binding
let x : Int R9# = 5 [R9#] () in
weakeff [Read R1# + Read R7# + Alloc R1# + Alloc R2#] in
weakclo {[R1#]} in
copyInt [R7#] [R2#]
    (weakeff [Read R8# + Read R9# + Alloc R7# + Alloc R8#] in
     weakclo {[R8#]} in
     copyInt [R9#] [R7#] x)


-- nested inside a function: give the closures a workout
letrec {
  foo : [r1 r2 r3 : %].Int r1 -(Read r1 + Read r2 + Alloc r2 + Alloc r3 | Use r1 + Use r2 + Use r3)> Int r3
    = /\(r1 r2 r3 : %).
       \(x : Int r1).
      weakeff [Read r1 + Read r2 + Alloc r2 + Alloc r3] in
      weakclo {[r2]} in
      copyInt [r1] [r3] x
} in
foo [R0#] [R0#] [R0#] (5 [R0#] ())
