:set Indent

:set rule copyConst [r1:%] (x:Int r1). Const r1 => copyInt [:r1 r1:] x = x
:set trans Rewrite

:set rule

-- don't do for any region
:trans..
letregion r in
(\(x : Int r). ())
    (copyInt [:r r:] (23 [r] ()))
;;

-- do it for consts
:trans..
letregion r with {w : Const r} in
(\(x : Int r). ())
    (copyInt [:r r:] (23 [r] ()))
;;

-- letregionS only do first one
:trans..
letregions r1 r2 with {w : Const r1} in
(\(x : Int r1). ())
    (addInt [:r1 r2 r1:]
	(copyInt [:r1 r1:] (23 [r1] ()))
	(copyInt [:r2 r2:] (5 [r2] ())))
;;

-- do it
:trans..
letregion ^ with {w : Const ^0} in
(\(x : Int ^0). ())
	(copyInt [:^0 ^0:] (23 [^0] ()))
;;

-- lift de bruijns: don't do it
:trans..
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^0). ())
	(copyInt [:^0 ^0:] (23 [^0] ()))
;;

-- lift de bruijns: do it
:trans..
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^1). ())
	(copyInt [:^1 ^1:] (23 [^1] ()))
;;

-- and with witnesses as lambda arguments
:trans..
(\(w : Const R0#). \(u : Unit).
	(copyInt [:R0# R0#:] (23 [R0#] ())))
;;

-- don't: lambda arguments for a different region
:trans..
(\(w : Const R0#). \(u : Unit).
	(copyInt [:R1# R1#:] (23 [R1#] ())))
;;


-- a silly rule to test Distinct constraints
:set.. rule dumbDistinct [r1 r2:%] (x:Int r1) (y:Int r2).
    Distinct r1 r2 =>
    addInt [:r1 r2 r1:] x y
    = 0 [r1] ()
;;

:set trans Rewrite

-- don't: not distinct
:trans..
addInt [:R0# R0# R0#:] (5 [R0#] ()) (3 [R0#] ())
;;
-- don't: not known
:trans..
/\(r1 r2 : %). \(_ : Unit).
addInt [:r1 r2 r1:] (5 [r1] ()) (3 [r2] ())
;;
-- do: both concrete
:trans..
addInt [:R0# R1# R0#:] (5 [R0#] ()) (3 [R1#] ())
;;
-- do: both concrete
:trans..
letregion ^ in
addInt [:R0# ^0 R0#:] (5 [R0#] ()) (3 [^0] ())
;;
-- do: known from argument
:trans..
/\(r1 r2 : %). \(w : Distinct r1 r2). \(_ : Unit).
addInt [:r1 r2 r1:] (5 [r1] ()) (3 [r2] ())
;;
-- do: known from letregions
:trans..
letregions r1 r2 with { w : Distinct r1 r2 } in
copyInt [:r1 R0#:]
    (addInt [:r1 r2 r1:] (5 [r1] ()) (3 [r2] ()))
;;

-- do: subset of a Distinct3
-- this needs to be an argument because letregions are treated as 'concrete' & known to be distinct to other concretes as well.
:trans..
/\(r1 r2 r3 : %). \(w : Distinct3 r1 r2 r3). \(_ : Unit).
addInt [:r1 r2 r1:] (5 [r1] ()) (3 [r2] ())
;;
-- do: another subset (rot)
:trans..
/\(r1 r2 r3 : %). \(w : Distinct3 r2 r3 r1). \(_ : Unit).
addInt [:r1 r2 r1:] (5 [r1] ()) (3 [r2] ())
;;
-- TODO TODO TODO
