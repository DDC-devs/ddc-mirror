:set Indent

:set rule copyConst [r1:%] (x:Int r1). Const r1 => copyInt [:r1 r1:] x = x
:set trans Rewrite

:set rule

-- don't do for any region
:trans..
letregion r in
(\(x : Int r). ())
    (copyInt [:r r:] (23 [r] ()))
;;

-- do it for consts
:trans..
letregion r with {w : Const r} in
(\(x : Int r). ())
    (copyInt [:r r:] (23 [r] ()))
;;

-- letregionS only do first one
:trans..
letregions r1 r2 with {w : Const r1} in
(\(x : Int r1). ())
    (addInt [:r1 r2 r1:]
	(copyInt [:r1 r1:] (23 [r1] ()))
	(copyInt [:r2 r2:] (5 [r2] ())))
;;

-- do it
:trans..
letregion ^ with {w : Const ^0} in
(\(x : Int ^0). ())
	(copyInt [:^0 ^0:] (23 [^0] ()))
;;

-- lift de bruijns: don't do it
:trans..
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^0). ())
	(copyInt [:^0 ^0:] (23 [^0] ()))
;;

-- lift de bruijns: do it
:trans..
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^1). ())
	(copyInt [:^1 ^1:] (23 [^1] ()))
;;

-- and with witnesses as lambda arguments
:trans..
(\(w : Const R0#). \(u : Unit).
	(copyInt [:R0# R0#:] (23 [R0#] ())))
;;

-- don't: lambda arguments for a different region
:trans..
(\(w : Const R0#). \(u : Unit).
	(copyInt [:R1# R1#:] (23 [R1#] ())))
;;

