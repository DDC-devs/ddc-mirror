ok

ok, added copyConst
ok

copyConst [r1 : %] (x : Int r1) . Const r1 => copyInt [r1] [r1] x = x

-- don't do for any region
letregion r in
(\(x : Int r). ())
    (copyInt [r] [r] (23 [r] ()))

-- do it for consts
letregion r with {w : Const r} in
(\(x : Int r). ())
    (weakeff [Read r + Alloc r] in
     weakclo {copyInt; [r]} in
     23 [r] ())

-- letregionS only do first one
letregions r1 r2 with {w : Const r1} in
(\(x : Int r1). ())
    (addInt [r1] [r2] [r1]
         (weakeff [Read r1 + Alloc r1] in
          weakclo {copyInt; [r1]} in
          23 [r1] ())
         (copyInt [r2] [r2] (5 [r2] ())))

-- do it
letregion ^ with {w : Const ^0} in
(\(x : Int ^0). ())
    (weakeff [Read ^0 + Alloc ^0] in
     weakclo {copyInt; [^0]} in
     23 [^0] ())

-- lift de bruijns: don't do it
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^0). ())
    (copyInt [^0] [^0] (23 [^0] ()))

-- lift de bruijns: do it
letregion ^ with {w : Const ^0} in
letregion ^ in
(\(x : Int ^1). ())
    (weakeff [Read ^1 + Alloc ^1] in
     weakclo {copyInt; [^1]} in
     23 [^1] ())

-- and with witnesses as lambda arguments
\(w : Const R0#).\(u : Unit).
weakeff [Read R0# + Alloc R0#] in
weakclo {copyInt; [R0#]} in
23 [R0#] ()

-- don't: lambda arguments for a different region
\(w : Const R0#).\(u : Unit).
copyInt [R1#] [R1#] (23 [R1#] ())


-- a silly rule to test Distinct constraints
ok, added dumbDistinct

ok

-- don't: not distinct
addInt [R0#] [R0#] [R0#] (5 [R0#] ()) (3 [R0#] ())
-- don't: not known
/\(r1 r2 : %).
 \(_ : Unit).
addInt [r1] [r2] [r1] (5 [r1] ()) (3 [r2] ())
-- do: both concrete
let ^ : Int R1# = 3 [R1#] () in
let ^ : Int R0# = 5 [R0#] () in
weakeff [Read R0# + Read R1# + Alloc R0#] in
weakclo {^0; ^1; addInt; [R1#]} in
0 [R0#] ()
-- do: both concrete
letregion ^ in
let ^ : Int ^0 = 3 [^0] () in
let ^ : Int R0# = 5 [R0#] () in
weakeff [Read ^0 + Read R0# + Alloc R0#] in
weakclo {^0; ^1; addInt; [^0]} in
0 [R0#] ()
-- do: known from argument
/\(r1 r2 : %).
 \(w : Distinct2 r1 r2).\(_ : Unit).
let ^ : Int r2 = 3 [r2] () in
let ^ : Int r1 = 5 [r1] () in
weakeff [Read r1 + Read r2 + Alloc r1] in
weakclo {^0; ^1; addInt; [r2]} in
0 [r1] ()
-- do: known from letregions
letregions r1 r2 with {w : Distinct2 r1 r2} in
copyInt [r1] [R0#]
    (let ^ : Int r2 = 3 [r2] () in
     let ^ : Int r1 = 5 [r1] () in
     weakeff [Read r1 + Read r2 + Alloc r1] in
     weakclo {^0; ^1; addInt; [r2]} in
     0 [r1] ())

-- do: subset of a Distinct3
-- this needs to be an argument because letregions are treated as 'concrete' & known to be distinct to other concretes as well.
/\(r1 r2 r3 : %).
 \(w : Distinct3 r1 r2 r3).\(_ : Unit).
let ^ : Int r2 = 3 [r2] () in
let ^ : Int r1 = 5 [r1] () in
weakeff [Read r1 + Read r2 + Alloc r1] in
weakclo {^0; ^1; addInt; [r2]} in
0 [r1] ()
-- do: another subset (rot)
/\(r1 r2 r3 : %).
 \(w : Distinct3 r2 r3 r1).\(_ : Unit).
let ^ : Int r2 = 3 [r2] () in
let ^ : Int r1 = 5 [r1] () in
weakeff [Read r1 + Read r2 + Alloc r1] in
weakclo {^0; ^1; addInt; [r2]} in
0 [r1] ()
