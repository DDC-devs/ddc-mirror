:with test/ddci-core/30-Transform/40-Rewrite/70-FoldBuild/Module.dce

:set Indent
:set TraceTrans

:set.. rule foldrBuild
    [a b : *] [r : %]
    [ek1 ek2 ez eg1 eg2 : !]
    [ck1 ck2 cz cg1 cg2 : $]
    (k : a -(ek1|ck1)> b -(ek2|ck2)> b)
    (z : Unit -(ez|cz)> b)
    (g : [gb : *]. [ec1 ec2 en : !]. [cc1 cc2 cn : $].
	(a -(ec1|cc1)> gb -(ec2|cc2)> gb)
       -(eg1|cg1)>
	(Unit -(en|cn)> gb)
       -(eg2+ec1+ec2+en|cg2+cc1)>
	gb).
    Disjoint (ek1+ek2+ez) (eg1+eg2) =>
foldr [:a b r ek1 ek2 ez ck1 ck2 cz:]
    k z
    (build [:a r eg1 eg2 cg1 cg2:] g)
= g [:b ek1 ek2 ez ck1 ck2 cz:] k z
;;


-- TODO: the Fix simplifier isn't pushing this though,
--       So I've written the transform out explicitly.
:set trans rewriteSimp <> Beta <> Bubble <> Rewrite <> Beta <> Bubble <> Rewrite <> Beta <> Bubble


-- sum = foldr (+) 0 xs
-- count  m  = build (count' m)
-- count' m = \c n -> if m == 0
--			then n
--			else c m (count' (m-1) c n)
:trans..
foldr [:(Int R0#) (Int R0#) R1#
	!0 (Read R0# + Alloc R0#) (Alloc R0#)
	(Use R0#) (Use R0#) (Use R0#):]
	plus zero
    (build [:(Int R0#) R1# !0 (Read R0# + Alloc R0#) (Use R0#) (Use R0#):] (count' (10 [R0#] ())))
;;


-- map f xs = build (\c n -> foldr (c . f) n xs)

-- filter f xs = build (\c n -> foldr
--	(\x xs -> if f x
--		  then c x xs
--		  else xs) n xs)
:trans..

-- sum
foldr [:(Int R0#) (Int R0#) R1#
	!0 (Read R0# + Alloc R0#) (Alloc R0#)
	(Use R0#) (Use R0#) (Use R0#):]
	plus zero
    -- filter f xs
    (build [:(Int R0#) R1#
	!0 (Read R0# + Read R1# + Alloc R0# + Alloc R1#)
	-- (Read R0# + Alloc R0#) !0
	(Use R0# + Use R1#)
	(Use R0# + Use R1#)
	:]
	(/\(bF : *). /\(ec1F ec2F enF : !). /\(cc1F cc2F cnF : $).
	\(c : Int R0# -(ec1F|cc1F)> bF -(ec2F|cc2F)> bF).
	\(n : Unit -(enF|cnF)> bF).

	foldr [:(Int R0#) bF R1#
		!0 (Read R0# + Alloc R0# + ec1F + ec2F) enF
		(Use R0# + cc1F) (Use R0# + cc1F) cnF
		:] 
	    (\(x : Int R0#).
	     \(xs : bF).
	      case even x of {
		0 -> c x xs;
		_ -> xs
	      }
	     )
	    n
	    
	-- map *2
	    (build [:(Int R0#) R1# 
		     !0 (Read R0# + Read R1# + Alloc R0# + Alloc R1#)
		     (Use R0# + Use R1#) (Use R0# + Use R1#) :]
		    (/\(b : *). /\(ec1 ec2 en : !). /\(cc1 cc2 cn : $).
		    \(c : Int R0# -(ec1|cc1)> b -(ec2|cc2)> b).
		    \(n : Unit -(en|cn)> b).

		    foldr [:(Int R0#) b R1#
			    (Read R0# + Alloc R0# + ec1)
				ec2 en
			    (Use R0# + cc1) cc2 cn
			    :]

			(compose [:(Int R0#) (Int R0#) (b -(ec2|cc2)> b)
				   ec1 (Alloc R0# + Read R0#)
				   cc1 (Use R0#)
				 :] c double)
			n

			-- enum 100
			(build [:(Int R0#) R1# !0 (Read R0# + Alloc R0#) (Use R0#) (Use R0#):] (count' (100 [R0#] ())))
		    ))))

;;

-- { Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + cc2 + cn + Use R0# }
