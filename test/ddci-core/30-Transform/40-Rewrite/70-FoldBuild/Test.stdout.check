ok

ok

ok, added foldrBuild

ok


-- sum = foldr (+) 0 xs
-- count  m  = build (count' m)
-- count' m = \c n -> if m == 0
--			then n
--			else c m (count' (m-1) c n)
weakeff [Read R0# + Read R1# + Alloc R0# + Alloc R1#] in
weakclo {[Int R0#]; [Use R0#]; [Use R0#]; [!0]; [Read R0# + Alloc R0#]; [R1#]} in
count' (10 [R0#] ()) [Int R0#] [!0] [Read R0# + Alloc R0#] [Alloc R0#] [Use R0#] [Use R0#] [Use R0#] plus zero


-- map f xs = build (\c n -> foldr (c . f) n xs)

-- filter f xs = build (\c n -> foldr
--	(\x xs -> if f x
--		  then c x xs
--		  else xs) n xs)
-- sum
weakeff [Read R0# + Read R1# + Alloc R0# + Alloc R1#] in
weakclo {[Int R0#]; [Use R0# + Use R1#]; [Use R0# + Use R1#]; [!0]; [Read R0# + Read R1# + Alloc R0# + Alloc R1#]; [R1#]} in
weakeff [Read R0# + Read R1# + Alloc R0# + Alloc R1#] in
weakclo {[Int R0#]; [Use R0# + Use R1#]; [Use R0# + Use R1#]; [!0]; [Read R0# + Read R1# + Alloc R0# + Alloc R1#]; [R1#]} in
weakeff [Read R0# + Read R1# + Alloc R0# + Alloc R1#] in
weakclo {[Int R0#]; [Use R0#]; [Use R0#]; [!0]; [Read R0# + Alloc R0#]; [R1#]} in
count' (100 [R0#] ()) [Int R0#] [Read R0# + Alloc R0#] [Read R0# + Alloc R0#] [Alloc R0#] [Use R0#] [Use R0#] [Use R0#]
    (compose [Int R0#] [Int R0#] [Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#] [!0] [Read R0# + Alloc R0#] [Use R0#] [Use R0#]
         (\(^ ^ : Int R0#).
          case even ^1 of {
            0  
             -> plus ^1 ^0;
            _ 
             -> ^0
          }) double) zero

-- { Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + cc2 + cn + Use R0# }
