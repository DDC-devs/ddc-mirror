:with test/ddci-core/30-Transform/40-Rewrite/60-Disjoint/Module.dce
:set.. rule mapMap [a b c : *] [r1 r2 r3 : %]
	[ef eg : !] [cf cg : $]
	(f : b -(ef|cf)> c) (g : a -(eg|cg)> b)
	(xs : List r3 a).
    Disjoint ef eg =>
	map [:r2 r1 b c ef cf:] f
		(map [:r3 r2 a b eg cg:] g xs) 
	= map [:r3 r1 a c (ef+eg) (cf+cg):]
	    (compose [:a b c ef eg cf cg:] f g) xs
;;

:set Indent
:set trans Rewrite

-- should rewrite, just reading
:trans..
map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Alloc R0#) (Use R0#):]
    (\(y : Int R0#). addInt [:R0# R0# R0#:] y (1 [R0#] ()))

    (map [:R0# R0# (Int R0#) (Int R0#) (Alloc R0# + Read R0#) (Use R0#):]
	(\(z : Int R0#). addInt [:R0# R0# R0#:] z (1 [R0#] ()))
	(Cons [:R0# (Int R0#):] (1 [R0#] ())
	    (Cons [:R0# (Int R0#):] (2 [R0#] ())
		(Nil [:R0# (Int R0#):] ()))))
;;

-- a write and a read from same region, no rewrite.
:trans..
letregion rMut with { wMut : Mutable rMut } in
let mutabl = 5 [rMut] () in

map [:R0# R0# (Int R0#) (Int R0#) (Read rMut + Alloc R0#) (Use R0# + Use rMut):]
    (\(y : Int R0#). copyInt [:rMut R0#:] mutabl)

    (map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Write rMut) (Use R0# + Use rMut):]
	(\(z : Int R0#).
	    let _ = updateInt [:rMut R0#:] <wMut> mutabl z
	    in	    z
	)
	(Cons [:R0# (Int R0#):] (1 [R0#] ())
	    (Cons [:R0# (Int R0#):] (2 [R0#] ())
		(Nil [:R0# (Int R0#):] ()))))
;;

-- a write and a read from different regions - do rewrite
:trans..
letregion rMut with { wMut : Mutable rMut } in
let mutabl = 5 [rMut] () in

map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Alloc R0#) (Use R0#):]
    (\(y : Int R0#). addInt [:R0# R0# R0#:] y (1 [R0#] ()))

    (map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Write rMut) (Use R0# + Use rMut):]
	(\(z : Int R0#).
	    let _ = updateInt [:rMut R0#:] <wMut> mutabl z
	    in	    z
	)
	(Cons [:R0# (Int R0#):] (1 [R0#] ())
	    (Cons [:R0# (Int R0#):] (2 [R0#] ())
		(Nil [:R0# (Int R0#):] ()))))
;;

-- a write and a read from different regions, but lambda-bound - don't rewrite
:trans..
/\(rMut : %). \(wMut : Mutable rMut). \(dummy : Int R0#).
let mutabl = 5 [rMut] () in

map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Alloc R0#) (Use R0#):]
    (\(y : Int R0#). addInt [:R0# R0# R0#:] y (1 [R0#] ()))

    (map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Write rMut) (Use R0# + Use rMut):]
	(\(z : Int R0#).
	    let _ = updateInt [:rMut R0#:] <wMut> mutabl z
	    in	    z
	)
	(Cons [:R0# (Int R0#):] (1 [R0#] ())
	    (Cons [:R0# (Int R0#):] (2 [R0#] ())
		(Nil [:R0# (Int R0#):] ()))))
;;

-- lambda-bound different regions, but with a Distinctness witness. do rewrite.
:trans..
/\(rMut : %). \(wMut : Mutable rMut). \(wDistinct : Distinct R0# rMut). \(dummy : Int R0#).
let mutabl = 5 [rMut] () in

map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Alloc R0#) (Use R0#):]
    (\(y : Int R0#). addInt [:R0# R0# R0#:] y (1 [R0#] ()))

    (map [:R0# R0# (Int R0#) (Int R0#) (Read R0# + Write rMut) (Use R0# + Use rMut):]
	(\(z : Int R0#).
	    let _ = updateInt [:rMut R0#:] <wMut> mutabl z
	    in	    z
	)
	(Cons [:R0# (Int R0#):] (1 [R0#] ())
	    (Cons [:R0# (Int R0#):] (2 [R0#] ())
		(Nil [:R0# (Int R0#):] ()))))
;;

