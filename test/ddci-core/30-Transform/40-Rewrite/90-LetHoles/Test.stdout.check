ok

ok

-- don't look past lets normally
ok, added unbox_box
ok

-- don't rewrite non-locals
let x : Int R0#
      = box (5 [R0#] ()) in
let y : Int R0# = unbox x in
let z : Int R0# = unbox x in
weakclo {box; unbox} in
addInt [R0#] [R0#] [R0#] y z

-- the {{ }} brackets indicate that the argument is cheap enough to be split across places
ok, added unbox_box
ok

-- rewrite y and z
let ^ : Int R0# = 5 [R0#] () in
let x : Int R0# = box ^0 in
let y : Int R0#
      = weakclo {box; unbox} in
        ^0 in
let z : Int R0#
      = weakclo {box; unbox} in
        ^0 in
addInt [R0#] [R0#] [R0#] y z

-- shadowing, don't rewrite
let ^ : Int R0# = 5 [R0#] () in
let x : Int R0# = box ^0 in
let x : Int R0# = 2 [R0#] () in
unbox x

-- some de bruijns. do rewrite
let ^ : Int R0# = 5 [R0#] () in
let ^ : Int R0# = box ^0 in
let ^ : Int R0# = 2 [R0#] () in
let b : Int R0#
      = weakclo {box; unbox} in
        ^2 in
let ^ : Int R0# = 3 [R0#] () in
let c : Int R0#
      = weakclo {box; unbox} in
        ^3 in
()

-- some surrounding de bruijns
let ^ : Int R0# = 2 [R0#] () in
let ^ : Int R0# = 5 [R0#] () in
let ^ : Int R0# = box ^0 in
let ^ : Int R0# = ^2 in
let c : Int R0#
      = weakclo {box; unbox} in
        ^2 in
()

-- some lambda-y de bruijns
let ^ : Int R0# = 2 [R0#] () in
let ^ : Int R0# = 5 [R0#] () in
let ^ : Int R0# = box ^0 in
\(a ^ : Unit).
let ^ : Int R0# = ^3 in
let c : Int R0#
      = weakclo {box; unbox} in
        ^3 in
()



-- now with a Const contraint and regions
ok, added unbox_box
ok

-- don't do it: not const
unbox_ [R0#]
    (box_ [R0#] (5 [R0#] ()))

-- do it: const
letregion r with {w : Const r} in
let x : Int r
      = weakclo {box_; unbox_; [r]} in
        5 [r] () in
()

-- separated
letregion r with {w : Const r} in
let ^ : Int r = 5 [r] () in
let x : Int r = box_ [r] ^0 in
let y : Int r
      = weakclo {box_; unbox_; [r]} in
        ^0 in
()
