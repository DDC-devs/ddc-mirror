
:set trans Beta

-- Identity function
:trans (\(x : Unit). x) ()


-- Identify function with indices.
:trans (\(^ : Unit). ^0) ()


-- Avoid capture of type var by type lambda in value subst.
:trans..
/\(a : *).
let f [b : *] = () in
(\(y : Unit). /\(a : *). y) (f [a]);;


-- TODO: check avoid capture by letregion binder in value subst.


-- Avoid capture of value var by value lambda in value subst.
:trans..
let x = () in 
(\(y : Unit). \(x : Unit). y) x;;


-- Don't substitute past binder with the same name.
:trans..
let u = () in
(\(x : Unit). \(x : Unit). x) u;;


-- Avoid capture of value var by let binding in value subst.
:trans..
let x = () in 
(\(y : Unit). 
        let x = 2 [R0#] x 
        in addInt [:R0# R0# R0#:] x (3 [R0#] y)) x;;


-- Don't substitute past binder with the same name.
:trans..
let u = () in 
(\(x : Unit). 
        let x = 2 [R0#] u 
        in addInt [:R0# R0# R0#:] x (3 [R0#] u)) u;;


-- Avoid capture of value var by letrec binding in value subst.
:trans..
let x = () in 
(\(y : Unit). 
        letrec { x (z : Int R0#) : Int R0# = z } 
        in addInt [:R0# R0# R0#:] (x (2 [R0#] y)) (3 [R0#] y)) 
        x;;


-- Avoid capture of value var by match bining in value subst.
:trans..
let x = () in
(\(y : Unit).
       case Nil [R0#] [Int R0#] () of {
        Nil            -> 0 [R0#] ();
        Cons x xs      -> addInt [:R0# R0# R0#:]
                                 (3 [R0#] y)
                                 x
       })
       x;;


-- Should be ok.
:trans..
letregion r0 with { wc : Const r0; wg : Global r0 } in
let x = 5 [r0] () in
addInt [:r0 r0 R0#:]
        ((\(wc' : Const r0) (wg' : Global r0). \(_ : Unit).
                letregion r1 with { wl : Lazy r1 ; w1 : Const r1; w2 : Global r1 } in
                let x lazy <wl> = purify <read [r0] wc' & alloc [r1] w1> in
                                  forget <use  [r0] wg' & use   [r1] w2> in
                                  addInt [:r0 r0 r1:] x x
                in  addInt [:r1 r1 r0:] x x)
                <:wc wg:> ())
        (5 [r0] ());;


-- Avoid capture of witness var by witness lambda in witness subst.
:trans..
letregion r0 with { wc : Const r0; wg : Global r0 } in
let x = 5 [r0] () in
addInt [:r0 r0 R0#:]
        ((\(wc' : Const r0) (wc : Global r0). \(_ : Unit).
                letregion r1 with { wl : Lazy r1 ; w1 : Const r1; w2 : Global r1 } in
                let x lazy <wl> = purify <read [r0] wc' & alloc [r1] w1> in
                                  forget <use  [r0] wc  & use   [r1] w2> in
                                  addInt [:r0 r0 r1:] x x
                in  addInt [:r1 r1 r0:] x x)
                <:wc wg:> ())
        (5 [r0] ());;


-- Avoid capture of witness var by witness binding in witness subst.
:trans..
letregion r0 with { wc : Const r0; wg : Global r0 } in
let x = 5 [r0] () in
addInt [:r0 r0 R0#:]
        ((\(wc' : Const r0) (wg : Global r0). \(_ : Unit).
                letregion r1 with { wc : Lazy r1 ; w1 : Const r1; w2 : Global r1 } in
                let x lazy <wc> = purify <read [r0] wc' & alloc [r1] w1> in
                                  forget <use  [r0] wg  & use   [r1] w2> in
                                  addInt [:r0 r0 r1:] x x
                in  addInt [:r1 r1 r0:] x x)
                <:wc wg:> ())
        (5 [r0] ());;

--
:trans..
(/\(r : %). \(x : Int r). /\(r : %). \(_ : Unit). 2 [r] ()) [R1#] (5 [R1#] ()) [R2#];;




