
ok

-- Identity function
()


-- Identify function with indices.
()


-- Avoid capture of type var by type lambda in value subst.
/\(a : *).let f : [b : *].Unit = /\(b : *).() in /\(^ : *).f [a]


-- TODO: check avoid capture by letregion binder in value subst.


-- Avoid capture of value var by value lambda in value subst.
let x : Unit = () in \(^ : Unit).x


-- Don't substitute past binder with the same name.
let u : Unit = () in \(x : Unit).x


-- Avoid capture of value var by let binding in value subst.
let x : Unit = () in let ^ : Int R0# = 2 [R0#] x in addInt [R0#] [R0#] [R0#] ^0 (3 [R0#] x)


-- Don't substitute past binder with the same name.
let u : Unit = () in let x : Int R0# = 2 [R0#] u in addInt [R0#] [R0#] [R0#] x (3 [R0#] u)


-- Avoid capture of value var by letrec binding in value subst.
let x : Unit = () in letrec {^ : Int R0# -> Int R0# = \(z : Int R0#).z} in addInt [R0#] [R0#] [R0#] (^0 (2 [R0#] x)) (3 [R0#] x)


-- Avoid capture of value var by match bining in value subst.
let x : Unit = () in case Nil [R0#] [Int R0#] () of {Nil  -> 0 [R0#] (); Cons (^ : Int R0#) (xs : List R0# (Int R0#)) -> addInt [R0#] [R0#] [R0#] (3 [R0#] x) ^0}


-- Avoid capture of witness var by lambda in witness subst.
-- TODO: this is wrong. inner wc binder doesn't get anonymised, but
--       we don't get a type error.
--:trans..
--letregion r0 with { wc : Const r0; wg : Global r0 } in
--let x = 5 [r0] () in
--addInt [:r0 r0 R0#:]
--        ((\(wc' : Const r0) (wg' : Global r0). \(_ : Unit).
--                letregion r1 with { wc : Lazy r1 ; w1 : Const r1; w2 : Global r1 } in
--                let x lazy <wc> = purify <read [r0] wc' & alloc [r1] w1> in
--                                  forget <use  [r0] wg' & use   [r1] w2> in
--                                  addInt [:r0 r0 r1:] x x
--                in  addInt [:r1 r1 r0:] x x)
--                <:wc wg:> ())
--        (5 [r0] ());;

