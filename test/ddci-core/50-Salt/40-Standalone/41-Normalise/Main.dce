
module Main
imports {
        showInt   :: Int# -> Ptr# String#;
        putStrLn  :: Ptr# String# -> Void#;
}
with letrec {

allocRaw (tag : Tag#) (bytesPayload : Nat#) : Ptr# Obj
 = do { bytesObj        = add# [Nat#] 8# bytesPayload;
        addr            = alloc# bytesObj;

        format          = 42w32#;
        tag32           = promote# [Word32#] [Tag#] tag;
        tagShift        = shl# [Word32#] tag32 8w32#;
        header          = bor# [Word32#] tagShift format;
        write# [Word32#] addr 0# header;

        bytesObj32      = truncate# [Word32#] [Nat#] bytesObj;
        write# [Word32#] addr 4# bytesObj32;

        return# [Ptr# Obj] (makePtr# [Obj] addr);
     };


boxWord32 (x : Word32#) : Ptr# Obj
 = do { obj     = allocRaw TAG0# 4#;
        addr    = takePtr# [Obj] obj;
        write#  [Word32#] addr 8# x;
        return# [Ptr# Obj] obj;
      };


unboxWord32 (obj : Ptr# Obj) : Word32#
 = do { addr    = takePtr# [Obj] obj;
        x       = read#   [Word32#] addr 8#;
        return# [Word32#] x;
      };


addWord32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = return# [Ptr# Obj] (boxWord32 (add# [Word32#] (unboxWord32 x) (unboxWord32 y)));


subWord32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = return# [Ptr# Obj] (boxWord32 (sub# [Word32#] (unboxWord32 x) (unboxWord32 y)));


mulWord32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = return# [Ptr# Obj] (boxWord32 (mul# [Word32#] (unboxWord32 x) (unboxWord32 y)));


fac (x: Ptr# Obj) : Ptr# Obj
 = do { cc      = eq# [Word32#] (unboxWord32 x) 0w32#;
        case cc of {
         True#  -> return# [Ptr# Obj] (boxWord32 1w32#);
         False# -> return# [Ptr# Obj] (mulWord32 x (fac (subWord32 x (boxWord32 1w32#))));
        };
      };


main (argc : Nat#) (argv : Ptr# String#) : Int#
 = do { x       = boxWord32 10w32#;
        str     = showInt (truncate# [Int#] [Word32#] (unboxWord32 (fac x)));
        putStrLn str;

        return# [Int#] 0i#;
      };
}
