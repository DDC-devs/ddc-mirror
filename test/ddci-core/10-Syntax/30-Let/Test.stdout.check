-- Non-binding let.
let _ : Unit = () in ()
::  Unit
:!: !0
:$: $0

-- Binding let.
let x : Unit = () in x
::  Unit
:!: !0
:$: $0

-- Let-bound function with full signature.
let f : Unit -> Unit = \(x : Unit).x in ()
::  Unit
:!: !0
:$: $0

-- Let using function syntax with a return type.
let f : Unit -> Unit = \(x : Unit).x in f ()
::  Unit
:!: !0
:$: $0

-- Let using function syntax without a return type.
let f = \(x : Unit).x in f ()
::  Unit
:!: !0
:$: $0

-- Multiple lets.
let x : Unit = () in let y : Unit = () in y
::  Unit
:!: !0
:$: $0

-- Simple letregion.
letregion r in let x : Int r = 4 [r] () in addInt [r] [r] [R1#] x x
::  Int R1#
:!: Alloc R1#
:$: Use R1#

-- Letregion with explicitly empty witness set.
letregion r in let x : Int r = 4 [r] () in addInt [r] [r] [R1#] x x
::  Int R1#
:!: Alloc R1#
:$: Use R1#

-- Simple letregion with letrec using explicit type annotation
letregion r in letrec {f : Unit -(Alloc r | Use r)> Int r = \(x : Unit).4 [r] ()} in addInt [r] [r] [R1#] (f ()) (f ())
::  Int R1#
:!: Alloc R1#
:$: Use R1#

-- Simple letregion with letrec using function syntax.
letregion r in letrec {f : Unit -(Alloc r | Use r)> Int r = \(x : Unit).4 [r] ()} in addInt [r] [r] [R1#] (f ()) (f ())
::  Int R1#
:!: Alloc R1#
:$: Use R1#

-- Multiple lets and letregion. 
letregion r1 in letregion r2 in let x1 : Int r1 = 2 [r1] () in let x2 : Int r2 = 3 [r2] () in addInt [r1] [r2] [R1#] x1 x2
::  Int R1#
:!: Alloc R1#
:$: Use R1#

-- As above, but no annots on binders.
letregion r1 in letregion r2 in let x1 = 2 [r1] () in let x2 = 3 [r2] () in addInt [r1] [r2] [R1#] x1 x2
::  Int R1#
:!: Alloc R1#
:$: Use R1#

