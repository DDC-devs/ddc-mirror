
module Main with letrec {
addInt32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = do { z       = allocRaw# TAG0# 4;
        gx      = tag# x;
        TAG0#  <- gx else fail# [Ptr# Obj];
        TAG0#  <- tag# y else fail# [Ptr# Obj];
        r   = add# [Int32#] 
                       (read# [Int32#] (fieldRaw# [Int32#] 0 x))
                       (read# [Int32#] (fieldRaw# [Int32#] 0 y));
        write# [Int32#] (fieldRaw# [Int32#] 0 z) r;
        return# [Ptr# Obj] z;
      };


subInt32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = do { z   = allocRaw# TAG0# 4;
        TAG0#  <- tag# x else fail# [Ptr# Obj];
        TAG0#  <- tag# y else fail# [Ptr# Obj];
        r   = sub# [Int32#] 
                        (read# [Int32#] (fieldRaw# [Int32#] 0 x))
                        (read# [Int32#] (fieldRaw# [Int32#] 0 y));
        write# [Int32#] (fieldRaw# [Int32#] 0 z) r;
        return# [Ptr# Obj] z;
      };


mulInt32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 = do { z       = allocRaw# TAG0# 4;

        gx      = tag# x;
        TAG0#  <- gx else fail# [Ptr# Obj];

        gy      = tag# y;
        TAG0#  <- gy else fail# [Ptr# Obj];

        fx      = fieldRaw# [Int32#] 0 x;
        nx      = read# [Int32#] fx;

        fy      = fieldRaw# [Int32#] 0 y;
        ny      = read# [Int32#] fy;

        r       = mul# [Int32#] nx ny;

        fx      = fieldRaw# [Int32#] 0 z;
        write# [Int32#] fx r;
        return# [Ptr# Obj] z;
      };


boxInt32 (x : Int32#) : Ptr# Obj
 = do { z       = allocRaw# TAG0# 4;
        fz      = fieldRaw# [Int32#] 0 z;
        write#  [Int32#] fz x;
        return# [Ptr# Obj] z;
      };



unboxInt32 (x : Ptr# Obj) : Int32#
 = do { p       = fieldRaw# [Int32#] 0 x;
        r       = read# [Int32#] p;
        return# [Int32#] r;
      };


fac (x: Ptr# Obj) : Ptr# Obj
 = do { x2      = unboxInt32 x;
        n0      = i32# 0;
        cc      = eq# [Int32#] x2 n0;
        case cc of {
         True# -> do {
                n       = i32# 1;
                r       = boxInt32 n;
                return# [Ptr# Obj] r;
         };

         False# -> do {
                n       = i32# 1;
                n2      = boxInt32 n;
                n3      = subInt32 x n2;
                n4      = mulInt32 x n3;
                return# [Ptr# Obj] n4;
         };
        }
      };

main (argc : Nat#) (argv : Ptr# String#) : Int32#
 = do { i       = i32# 10;
        x       = boxInt32 i;
        x2      = fac x;
        x2'     = unboxInt32 x2;
        str     = showInt32# x2';
        putStrLn# str;

        i0      = i32# 0;
        return# [Int32#] i0;
      };
}
