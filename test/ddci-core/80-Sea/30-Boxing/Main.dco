
module Main
letrec {
addInt32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 =      let z   = allocRaw# TAG0# 4 in
        match TAG0#  <- tag# x else fail# [Ptr# Obj] in
        match TAG0#  <- tag# y else fail# [Ptr# Obj] in
        let r   = add# [Int32#] 
                       (read# [Int32#] (fieldRaw# [Int32#] 0 x))
                       (read# [Int32#] (fieldRaw# [Int32#] 0 y)) in
        let _   = write# [Int32#] (fieldRaw# [Int32#] 0 z) r in
        return# [Ptr# Obj] z;


mulInt32 (x : Ptr# Obj) (y : Ptr# Obj) : Ptr# Obj
 =      let z   = allocRaw# TAG0# 4 in
        match TAG0#  <- tag# x else fail# [Ptr# Obj] in
        match TAG0#  <- tag# y else fail# [Ptr# Obj] in
        let r   = mul# [Int32#] 
                       (read# [Int32#] (fieldRaw# [Int32#] 0 x))
                       (read# [Int32#] (fieldRaw# [Int32#] 0 y)) in
        let _   = write# [Int32#] (fieldRaw# [Int32#] 0 z) r in
        return# [Ptr# Obj] z;


boxInt32 (x : Int32#) : Ptr# Obj
 =      let z   = allocRaw# TAG0# 4 in
        let _   = write# [Int32#] (fieldRaw# [Int32#] 0 z) x in
        return# [Ptr# Obj] z;


unboxInt32 (x : Ptr# Obj) : Int32#
 =      return# [Int32#] (read# [Int32#] (fieldRaw# [Int32#] 0 x));


fac (x: Ptr# Obj) : Ptr# Obj
 =      let x'  = unboxInt32 x in
        case eq# [Int32#] x' (i32# 0) of {
         1  -> boxInt32 (i32 1);
         0  -> mulInt32 x (fac (subInt32 x (i32 1)));
        };


main (argc : Nat#) (argv : Ptr# String#) : Int32#
 =      let x   = boxInt32 (i32# 5) in
        let x2  = addInt32 x x in
        let str = showInt32# (unboxInt32 x2) in
        let _   = putStrLn# str in
        return# [Int32#] (i32# 0);
}
