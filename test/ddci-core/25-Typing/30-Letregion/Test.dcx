-- Parse letregion with no witnesses
:check letregion r1 in ()


-- Parse letregion with one witness.
:check letregion r1 with { w1 : Const r1 } in ()


-- Parse letregion with witness for distinctness
:check..
letregion r1                             in
letregion r2 with { w1: Distinct r1 r2 } in ();;


-- Parse letregion with multiple witnesses.
:check letregion r1 with { w1 : Const r1; w2 : Manifest r1 } in ()


-- Use the bound region in the body of the expression.
:check letregion r1 in addInt [:r1 r1 R2#:] (2 [r1] ()) (3 [r1] ())


-- As above, but with debruijn indices.
:check letregion ^  in addInt [:^0 ^0 R2#:] (2 [^0] ()) (3 [^0] ())


-- Error: withregion must contain a region variable or constructor.
:check (\(e:!). withregion e in ())


-- Error: letregion cannot shadow region variables that are already in the
-- environment because the new witnesses may conflict with the old ones.
:check..
letregion r1 with {w1 : Const r1}   in
let x : Int r1 = 5 [r1] () in
letregion r1 with {w1 : Mutable r1} in
updateInt [:r1 r1:] <w1> x (0 [r1] ());;


-- Error: letregion can't shadow region variables that are already in the
-- environment.
:check..
/\(r : %). 
 \(x : Int r).
 letregion r with {w1 : Mutable r} in
 updateInt [:r r:] <w1> x (0 [r] ());;


-- Error: bound region variable is free in the type of the body of a letregion.
:check letregion r1 in 4 [r1] ()


-- Error: bound region is free in the effect of a returned function.
:check..
letregion r1 with {w1 : Const r1} in
\(x:Unit). (addInt [:r1 r1 R2#:] (2 [r1] ()) (3 [r1] ()));;


-- Error: region variable appears in closure term
:check..
letregion r1 in
let z  = 5 [r1] () in
\(x : Unit).
 let xs = Cons [R0#] [Int r1] z (Nil [R0#] [Int r1] ()) in
 case xs of {
        Nil      -> 1 [R0#] ();
        Cons _ _ -> 2 [R0#] ();
 };;


-- Error: witness types with a letregion must use explicit type constructors.
:check..
/\(c : % ~> @).
letregion r1 with { w : c r1 } in
();;

