-- The inner function uses a value in region R0#.
let x : Int R0# = 5 [R0#] () in \(z : Unit). addInt [R0#] [R0#] [R1#] x x
:*: Unit -(Read R0# + Alloc R1# | Use R0# + Use R1#)> Int R1#
:!: Alloc R0#
:$: Use R0# + Use R1#


-- The inner function uses a value in region R0#.
let x : Int R0# = 5 [R0#] () in \(z : Unit). addInt [R0#] [R0#] [R1#] x x
:*: Unit -(Read R0# + Alloc R1# | Use R0# + Use R1#)> Int R1#
:!: Alloc R0#
:$: Use R0# + Use R1#


-- Inner function uses the bound value, but it is not free in the closure.
\(x : Int R0#). addInt [R0#] [R0#] [R1#] x x
:*: Int R0# -(Read R0# + Alloc R1# | Use R0# + Use R1#)> Int R1#
:!: !0
:$: Use R0# + Use R1#


-- Inner function uses the bound value, and it is free in the closure.
\(x : Int R0#). \(y : Int R1#). addInt [R0#] [R1#] [R2#] x y
:*: Int R0# -(!0 | Use R0# + Use R1# + Use R2#)> Int R1# -(Read R0# + Read R1# + Alloc R2# | Use R0# + Use R1# + Use R2#)> Int R2#
:!: !0
:$: Use R0# + Use R1# + Use R2#


-- Multiple levels of binding.
\(x : Int R0#). \(y : Int R1#). \(z : Int R2#). addInt [R3#] [R0#] [R4#] (addInt [R1#] [R2#] [R3#] y z) x
:*: Int R0# -(!0 | Use R0# + Use R1# + Use R2# + Use R3# + Use R4#)> Int R1# -(!0 | Use R0# + Use R1# + Use R2# + Use R3# + Use R4#)> Int R2# -(Read R0# + Read R1# + Read R2# + Read R3# + Alloc R3# + Alloc R4# | Use R0# + Use R1# + Use R2# + Use R3# + Use R4#)> Int R4#
:!: !0
:$: Use R0# + Use R1# + Use R2# + Use R3# + Use R4#


-- Inner function has a value in the closure whose type contains
-- a higher kinded type variable.
/\(a : % ~> *). \(x : a R1#). \(f : a R1# -> a R1#). f x
:*: [a : % ~> *].a R1# -> (a R1# -> a R1#) -(!0 | DeepUse (a R1#))> a R1#
:!: !0
:$: $0


-- Inner funtion has a value in the clousre whose type contains
-- a closure variable.
/\(e : !). /\(c : $). \(f : Unit -(e | c)> Unit). \(x : Unit). f x
:*: [e : !]. [c : $].(Unit -(e | c)> Unit) -> Unit -(e | c)> Unit
:!: !0
:$: $0


-- Like above, and we've also instantiated the variable with a
-- pre-trimmed closure.
(/\(e : !). /\(c : $). \(f : Unit -(e | c)> Unit). \(x : Unit). f x) [Read R0#] [Use R1#]
:*: (Unit -(Read R0# | Use R1#)> Unit) -> Unit -(Read R0# | Use R1#)> Unit
:!: !0
:$: $0


-- Like above, and we've also instantiated the variable with a closure that
-- could be trimmed, but because it's explicit in the term we don't do so. 
(/\(e : !). /\(c : $). \(f : Unit -(e | c)> Unit). \(x : Unit). f x) [Read R0#] [DeepUse (Int R1#)]
:*: (Unit -(Read R0# | DeepUse (Int R1#))> Unit) -> Unit -(Read R0# | DeepUse (Int R1#))> Unit
:!: !0
:$: $0


-- Region handle in the type argument should show up in the overall closure.
(/\(a : *). \(f : a -> a). \(x : a). f x) [Int R1#]
:*: (Int R1# -> Int R1#) -> Int R1# -> Int R1#
:!: !0
:$: $0


-- Local region should not appear in the closure of the overall term.
letregion r1 with {w1 : Const r1} in purify <read [r1] w1> in addInt [r1] [R0#] [R0#] (5 [r1] ()) (5 [R0#] ())
:*: Int R0#
:!: Read R0# + Alloc R0#
:$: Use R0#


-- Error: region is visible in the closure of the returned function.
-- We've purified the read and alloc effects, but we can still see
-- that the function uses the region due to the Use term in the
-- function's closure.
When checking expression.
  Region variable escapes scope of letregion.
         The region variable: r1 : %
    is free in the body type: Unit -(Read R0# + Alloc R0# | Use r1 + Use R0#)> Int R0#
  
  with: letregion r1 with {w1 : Const r1} in
        \(x : Unit).
        purify <read [r1] w1 & alloc [r1] w1> in
        addInt [r1] [R0#] [R0#] (2 [r1] ()) (3 [R0#] ())
