-- Tail recursive factorial.
-- Using an explicit typesig.
:eval..
letrec {
 fac : [r : %]. Int r -(!0 | Use r)> Int r -(Read r + Alloc r | Use r)> Int r
  = /\(r : %). \(acc n : Int r)
  . case n of {
        0     -> acc;
        1     -> acc;
        _     -> fac [r] (mulInt [:r r r:] acc n)
                         (subInt [:r r r:] n (1 [r] ()))
  }
} in fac [R0#] (1 [R0#] ()) (10 [R0#] ());;


-- Tail recursive factorial.
-- Using function binding syntax.
:eval..
letrec {
 fac    [r:%] 
        (acc : Int r) {!0 | Use r}
        (n   : Int r) {Read r + Alloc r | Use r} : Int r
  = case n of {
        0       -> acc;
        1       -> acc;
        _       -> fac [r] (mulInt [:r r r:] acc n)
                           (subInt [:r r r:] n (1 [r] ()))
    }
} in fac [R0#] (1 [R0#] ()) (10 [R0#] ());;


-- Tail recursive factorial.
-- Using destructive update.
:eval..
let fac  [r1:%] 
         (n   : Int r1) {Read r1 + Alloc r1 | Use r1} : Int r1
     = letregion r2 with { w : Mutable r2 } in
       let acc = 1 [r2] () in
       let one = 1 [r2] () in
       letrec { 
        loop (i : Int r1) { Read r1 + Read r2 + Write r2 + Alloc r1 + Alloc r2
                          | Use  r1 + Use r2 } : Int r1
         = case i of {
            0  -> copyInt [:r2 r1:] acc;
            1  -> copyInt [:r2 r1:] acc;
            _  -> let _ = updateInt [:r2 r2:] <w> acc 
                                    (mulInt [:r2 r1 r2:] acc i)
                  in  loop (subInt [:r1 r2 r1:] i one);
         }
       } in loop n
in fac [R0#] (10 [R0#] ());;


-- Tail recursive factorial.
-- With argument and return values in different regions.
:eval..
let fac  [r1:%] [r3:%]
         (n   : Int r1) {Read r1 + Alloc r1 + Alloc r3 | Use r1 + Use r3} : Int r3
     = letregion r2 with { w : Mutable r2 } in
       let acc = 1 [r2] () in
       let one = 1 [r2] () in
       letrec { 
        loop (i : Int r1) { Read r1 + Read r2 + Write r2 + Alloc r1 + Alloc r2 + Alloc r3
                          | Use  r1 + Use r2  + Use r3 } : Int r3
         = case i of {
            0  -> copyInt [:r2 r3:] acc;
            1  -> copyInt [:r2 r3:] acc;
            _  -> let _ = updateInt [:r2 r2:] <w> acc 
                                    (mulInt [:r2 r1 r2:] acc i)
                  in  loop (subInt [:r1 r2 r1:] i one);
         }
       } in loop n
in fac [R1#] [R2#] (10 [R1#] ());;


-- Tail recursive factorial.
-- With argument and return regions holding only the
-- argument and return values.
:eval..
let fac  [r1:%] [r3:%]
         (n   : Int r1) {Read r1 + Alloc r1 + Alloc r3 | Use r1 + Use r3} : Int r3
     = letregion r2 with { w : Mutable r2 } in
       let acc = 1 [r2] () in
       let one = 1 [r2] () in
       letrec { 
        loop (i : Int r2) { Read r1 + Read r2 + Write r2 + Alloc r1 + Alloc r2 + Alloc r3
                          | Use  r1 + Use r2  + Use r3 } : Int r3
         = case i of {
            0  -> copyInt [:r2 r3:] acc;
            1  -> copyInt [:r2 r3:] acc;
            _  -> let _ = updateInt [:r2 r2:] <w> acc 
                                    (mulInt [:r2 r2 r2:] acc i)
                  in  loop (subInt [:r2 r2 r2:] i one);
         }
       } in loop (copyInt [:r1 r2:] n)
in fac [R1#] [R2#] (10 [R1#] ());;


-- Tail recursive factorial.
-- Without copying out.
:eval..
let fac  [r1:%] [r3:%]
         (n   : Int r1) { Read r1 + Alloc r3 
                        | Use r1  + Use r3} : Int r3
     = letregion r2 with { w : Mutable r2 } in
       letrec { 
        loop0 (i : Int r1) { Read r1 + Read r2 + Write r2 + Alloc r2 + Alloc r3
                           | Use r1  + Use r2  + Use r3 } : Int r3
         = case i of {
                0 -> 1 [r3] ();
                1 -> 1 [r3] ();
                _ -> let acc = 1 [r2] () in
                     letrec {
                        loop1 (j : Int r2) { Read r1 + Read r2 + Write r2 + Alloc r2 + Alloc r3
                                           | Use r1  + Use r2  + Use r3 } : Int r3
                         = case j of {
                                0 -> 0 [r3] ();
                                1 -> 0 [r3] ();
                                2 -> mulInt [:r2 r2 r3:] j acc;
                                _ -> let _ = updateInt [:r2 r2:] <w> acc 
                                                       (mulInt [:r2 r2 r2:] acc j)
                                     in loop1 (subInt [:r2 r2 r2:] j (1 [r2] ()));
                         }
                     } in loop1 (copyInt [:r1 r2:] i);
           }
       } in loop0 n
in fac [R1#] [R2#] (10 [R1#] ());;
