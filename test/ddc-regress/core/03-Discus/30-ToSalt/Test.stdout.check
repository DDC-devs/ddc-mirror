ok
ok

-- Set the builder explicitly so we get consistent object layouts.
ok


-------------------------------------------------------------------------------
-- Unboxed literal patterns.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word16#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word16#
                = peek# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        0x0005w16#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0x0006w16# in
            ^1;
        0x0007w16#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0x0008w16# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0x0000w16# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 0x0001w16# 0x0000w16# "DDC"# "foo"# 0xb61cf2154a4c4512w64# 0x4960337e2d277ef5w64# 0x3e5de514ca64496aw64# 0x0b321c2538b0efa6w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word32#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word32#
                = peek# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        0x00000005w32#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 0x00000006w32# in
            ^1;
        0x00000007w32#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 0x00000008w32# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 0x00000000w32# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 0x0001w16# 0x0000w16# "DDC"# "foo"# 0x0fa87949987f8732w64# 0xc277b7f6bee161c5w64# 0x26157718f325c710w64# 0x5b61b5d9a7510ad1w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word64#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word64#
                = peek# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        0x0000000000000005w64#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 0x0000000000000006w64# in
            ^1;
        0x0000000000000007w64#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 0x0000000000000008w64# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 0x0000000000000000w64# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 0x0001w16# 0x0000w16# "DDC"# "foo"# 0xc4315c67072918aaw64# 0x347f53e48d51103aw64# 0x431bfe09c4e4a3c4w64# 0xd6f27449dff20da4w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Unboxed Bool pattern.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Bool#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Bool#
                = peek# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        True#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Bool"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) False# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Bool"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) True# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 0x0001w16# 0x0000w16# "DDC"# "foo"# 0xae4d5f5520489357w64# 0x457f4eee6b665ed4w64# 0x581d0edd7571cec4w64# 0x02eb5e02175a44e5w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Compile nested function via lambda lifting.
Error in transformed module.
  in stage CoreLoad
  in pipe  PipeCoreCheck/Check
  <batch>:53:12
  Cannot apply non-function
                of type: [a: Data].a -> a


-- Compile application of anonymous function.
module Test with
letrec {
  app: [a$r b$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r b$r: Region).
      λ(f x: Ptr# rT Obj). ddcApply1 [rT] [rT] [rT] f x;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx4: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx4 in
            ^1 in
      let xx5: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx6: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx5 0x0002w16# 0x0000w16# "DDC"# "app"# 0x4c16bee6dc8ae70fw64# 0xb9eb36625f0718bew64# 0x07dc5093c29b6e07w64# 0x4a9e5baf50eed09aw64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.app"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx6 in
            ^1 in
      let xx7: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx7 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Construct a lists of units.
-- The head field of the Cons cells has no primary region.
module Test with
letrec {
  singleton: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx0: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcBoxedAlloc [rT] TAG0#
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0#) 0# in
            ^0 in
      let ^: Ptr# rT Obj
          = ddcBoxedAlloc [rT] TAG1#
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0#) 2# in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 0# x in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 1# xx0 in
      ^0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx9: Addr#
          = ddcInfoFrameNew 2# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx10 0x0000w16# 0x0000w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx13: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx12 0x0001w16# 0x0002w16# "Test"# "Cons"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
            ^1 in
      let xx14: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx14 in
      let xx15: Addr#
          = ddcInfoFrameNew 1# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx15 in
            ^1 in
      let xx16: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx17: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx16 0x0001w16# 0x0000w16# "DDC"# "singleton"# 0x38ceae81e60a17a6w64# 0x5ebad46465046ecfw64# 0x464bf62458cf4ef6w64# 0x56ec6c666afb5af7w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.singleton"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
            ^1 in
      let xx18: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx18 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Destruct a list of units.
-- The head field of the Cons cell has no primary region.
module Test with
letrec {
  headUnit: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG1#  
         -> let x: Ptr# rT Obj
                = ddcBoxedGetField [rT] [rT] xx 0# in
            let xx0: Ptr# rT Obj
                = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        TAG0#  
         -> ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#;
        _ 
         -> fail# [Ptr# rT Obj]
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx9: Addr#
          = ddcInfoFrameNew 2# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx10 0x0000w16# 0x0000w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx13: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx12 0x0001w16# 0x0002w16# "Test"# "Cons"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
            ^1 in
      let xx14: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx14 in
      let xx15: Addr#
          = ddcInfoFrameNew 1# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx15 in
            ^1 in
      let xx16: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx17: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx16 0x0001w16# 0x0000w16# "DDC"# "headUnit"# 0xb42ca849feab4aedw64# 0xdadb8390d283e501w64# 0x6d8f8b5cd3b58386w64# 0x211e9b3a4d94ba62w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.headUnit"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
            ^1 in
      let xx18: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx18 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Keep witnesses arguments
Fragment violation when converting Discus module to Salt module.
  Cannot convert expression.
    Cannot convert function abstraction in this context.
    The program must be lambda-lifted before conversion.
  
    with: λ(w: Mutable r).λ(x: Unit). convert# [U# Word64#] [Word64#] 42w64##


-------------------------------------------------------------------------------
-- Trigger errors about unsupported features in the Tetra to Salt conversion.
ok

-- OK: Anonymous binders are namified on the way into the conversion.
module Test with
letrec {
  id: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). xx0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 0x0001w16# 0x0000w16# "DDC"# "id"# 0x926aee8bd515fcffw64# 0x3374523b57163c8bw64# 0xfb04843086478cbew64# 0x04e4e5b4ec5af785w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.id"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx4: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Error: partial application of primitive data constructors is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: partial application if user defined data constructors is now supported.
module Test with
letrec {
  thing$l$L$2: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(l$0$0 l$1$1: Ptr# rT Obj).
      let ^: Ptr# rT Obj
          = ddcBoxedAlloc [rT] TAG0#
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Thing"#) 0#) 2# in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 0# l$0$0 in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 1# l$1$1 in
      ^0;
  
  thing: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
          = ddcThunkAlloc [rT] (convert# [Addr#] [Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj] thing$l$L$2)
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.super.DDC.thing$l$L$2"#) 0#) 2# 0# 0# 0# in
      let xx10: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      let ^: Ptr# rT Obj
          = ddcThunkExtend [rT] [rT] xx1 1# in
      let ^: Nat# 
          = ddcThunkArgs [rT] xx1 in
      let _: Void#
          = ddcThunkSetField [rT] [rT] ^1 ^0 0# xx10 in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx11: Addr#
          = ddcInfoFrameNew 1# in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx13: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx12 0x0000w16# 0x0002w16# "Test"# "Thing"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Thing"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
            ^1 in
      let xx14: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx14 in
      let xx15: Addr#
          = ddcInfoFrameNew 2# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx15 in
            ^1 in
      let xx16: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx17: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx16 0x0002w16# 0x0000w16# "DDC"# "thingZdllZdlLZdl2"# 0x555611f9227860e9w64# 0x25d8407f6d97bcd7w64# 0x97abc2fb819820eew64# 0x0b5b76737d072456w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.thing$l$L$2"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
            ^1 in
      let xx18: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx19: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx18 0x0001w16# 0x0000w16# "DDC"# "thing"# 0xac8e3c4ea183f527w64# 0xa04f50bd3bb03b17w64# 0xab7c619b70ec5e3bw64# 0x28c28ff9305672fbw64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.thing"#) 0# ^0 in
            ^0 in
      let xx8: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx19 in
            ^1 in
      let xx20: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx9: Ptr# rT Obj
          = ddcInfoFramePush xx20 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Error: partial application of primitive operators is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: let expressions in nested contexts are normalized on the way in to
-- the conversion.
module Test with
letrec {
  id: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      id [rT] xx1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx7: Addr#
          = ddcInfoFrameNew 2# in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx9: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx8 0x0001w16# 0x0000w16# "DDC"# "id"# 0xbf30c3fb775f7c9ew64# 0x393e2a7682d2db40w64# 0x2d7def4dce474545w64# 0x5374cde5ac1a6053w64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.id"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx10 0x0001w16# 0x0000w16# "DDC"# "foo"# 0x873ae533b8a5f84bw64# 0xab5c797da603781bw64# 0x275593de131cc166w64# 0x81b66a470f9316aew64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx6: Ptr# rT Obj
          = ddcInfoFramePush xx12 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-- Error: higher kinded type arguments are not yet supported.
module Test with
letrec {
  nothin: [b$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(b$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx9: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      nothin [rT] xx9;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx10: Addr#
          = ddcInfoFrameNew 1# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx10 in
            ^1 in
      let xx11: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx12: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx11 0x0000w16# 0x0001w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx12 in
            ^1 in
      let xx13: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx4: Ptr# rT Obj
          = ddcInfoFramePush xx13 in
      let xx14: Addr#
          = ddcInfoFrameNew 2# in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx14 in
            ^1 in
      let xx15: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx16: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx15 0x0001w16# 0x0000w16# "DDC"# "nothin"# 0x68a23cf44b275a3aw64# 0x3a5126e6c17401d6w64# 0x354f5b7a010a2a82w64# 0xf22ea40f91664d0bw64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.nothin"#) 0# ^0 in
            ^0 in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx16 in
            ^1 in
      let xx17: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx18: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx17 0x0001w16# 0x0000w16# "DDC"# "foo"# 0x86704f87d3ca2b0aw64# 0xfce8820cea78b999w64# 0x8761da2143c748bcw64# 0xff53dce0a2929defw64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.foo"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx18 in
            ^1 in
      let xx19: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx19 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


-------------------------------------------------------------------------------
-- Ok: we should be able to convert the Alloc, Read, Write caps,
-- even though conversion for the Ref primops isn't implemented yet.
module Test with
letrec {
  blerk: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let ^: Ptr# rT Obj
          = ddcSmallAlloc [rT]
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
      let ^: Ptr# rT Word8#
          = ddcSmallPayload [rT] ^0 in
      let _: Void#
          = poke# [rT] [Nat#]
                (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx4: Ptr# rT Obj).
      let xx8: Addr#
          = ddcInfoFrameNew 1# in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx8 in
            ^1 in
      let xx9: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx10: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx9 0x0001w16# 0x0000w16# "DDC"# "blerk"# 0x6813ca3f70f66dccw64# 0x64cfcd22872889dew64# 0x5c205c32724aba56w64# 0xef383067e9f2682dw64# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.DDC.blerk"#) 0# ^0 in
            ^0 in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx10 in
            ^1 in
      let xx11: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Ptr# rT Obj
          = ddcInfoFramePush xx11 in
      ddcBoxedAlloc [rT] TAG0# 0x00000001w32# 0#
}


