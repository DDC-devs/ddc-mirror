ok
ok

-- Set the builder explicitly so we get consistent object layouts.
ok


-------------------------------------------------------------------------------
-- Unboxed literal patterns.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1: Word16#
            = let ^: Ptr# rT Obj
                    = x in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        5w16#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word16#]
                        (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 6w16# in
            ^1;
        7w16#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word16#]
                        (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 8w16# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word16#]
                        (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1: Word32#
            = let ^: Ptr# rT Obj
                    = x in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word32#
                    = peek# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        5w32#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word32#]
                        (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 6w32# in
            ^1;
        7w32#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word32#]
                        (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 8w32# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word32#]
                        (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 0w32# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1: Word64#
            = let ^: Ptr# rT Obj
                    = x in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word64#
                    = peek# [rT] [Word64#]
                          (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        5w64#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word64#]
                        (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 6w64# in
            ^1;
        7w64#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word64#]
                        (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 8w64# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Word64#]
                        (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 0w64# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Unboxed Bool pattern.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1: Bool#
            = let ^: Ptr# rT Obj
                    = x in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Bool#
                    = peek# [rT] [Bool#]
                          (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        True#  
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) False# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^: Ptr# rT Word8#
                  = ddcSmallPayload [rT] ^0 in
            let _: Void#
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) True# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Compile nested function via lambda lifting.
Error in transformed module.
  in stage CoreLoad
  in pipe  PipeCoreCheck/Check
  <batch>:53:12
  Cannot apply non-function
                of type: [a: Data].a -> a


-- Compile application of anonymous function.
module Test with
letrec {
  app: [a$r b$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r b$r: Region).
      λ(f x: Ptr# rT Obj). ddcApply1 [rT] [rT] [rT] f x;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Construct a lists of units.
-- The head field of the Cons cells has no primary region.
module Test with
letrec {
  singleton: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx0: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcBoxedAlloc [rT] TAG0# 0# in
              ^0 in
      let ^: Ptr# rT Obj
            = ddcBoxedAlloc [rT] TAG1# 2# in
      let _: Void#
            = ddcBoxedSetField [rT] [rT] ^0 0# x in
      let _: Void#
            = ddcBoxedSetField [rT] [rT] ^0 1# xx0 in
      ^0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx6: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 2# in
              ^1 in
      let xx7: Nat#
            = let ^: Ptr# rT Obj
                    = xx6 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Nat#
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx8: Addr#
            = ddcInfoFrameNew xx7 in
      let xx2: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx8 in
              ^1 in
      let xx9: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx10: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx11: Word16#
            = let ^: Ptr# rT Obj
                    = xx10 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx12: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx13: Word16#
            = let ^: Ptr# rT Obj
                    = xx12 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx14: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx15: TextLit#
            = let ^: Ptr# rT Obj
                    = xx14 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx16: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Nil"# in
              ^1 in
      let xx17: TextLit#
            = let ^: Ptr# rT Obj
                    = xx16 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx18: Word32#
            = ddcInfoFrameAddData xx9 xx11 xx13 xx15 xx17 in
      let xx3: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx18 in
              ^1 in
      let xx19: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx20: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 1w16# in
              ^1 in
      let xx21: Word16#
            = let ^: Ptr# rT Obj
                    = xx20 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx22: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 2w16# in
              ^1 in
      let xx23: Word16#
            = let ^: Ptr# rT Obj
                    = xx22 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx24: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx25: TextLit#
            = let ^: Ptr# rT Obj
                    = xx24 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx26: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Cons"# in
              ^1 in
      let xx27: TextLit#
            = let ^: Ptr# rT Obj
                    = xx26 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx28: Word32#
            = ddcInfoFrameAddData xx19 xx21 xx23 xx25 xx27 in
      let xx4: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx28 in
              ^1 in
      let xx29: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx5: Ptr# rT Obj
            = ddcInfoFramePush xx29 in
      ddcBoxedAlloc [rT] TAG0# 0#
}


-- Destruct a list of units.
-- The head field of the Cons cell has no primary region.
module Test with
letrec {
  headUnit: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG1#  
         -> let x: Ptr# rT Obj
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let xx0: Ptr# rT Obj
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        TAG0#  
         -> ddcBoxedAlloc [rT] TAG0# 0#;
        _ 
         -> fail# [Ptr# rT Obj]
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx6: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 2# in
              ^1 in
      let xx7: Nat#
            = let ^: Ptr# rT Obj
                    = xx6 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Nat#
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx8: Addr#
            = ddcInfoFrameNew xx7 in
      let xx2: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx8 in
              ^1 in
      let xx9: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx10: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx11: Word16#
            = let ^: Ptr# rT Obj
                    = xx10 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx12: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx13: Word16#
            = let ^: Ptr# rT Obj
                    = xx12 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx14: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx15: TextLit#
            = let ^: Ptr# rT Obj
                    = xx14 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx16: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Nil"# in
              ^1 in
      let xx17: TextLit#
            = let ^: Ptr# rT Obj
                    = xx16 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx18: Word32#
            = ddcInfoFrameAddData xx9 xx11 xx13 xx15 xx17 in
      let xx3: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx18 in
              ^1 in
      let xx19: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx20: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 1w16# in
              ^1 in
      let xx21: Word16#
            = let ^: Ptr# rT Obj
                    = xx20 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx22: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 2w16# in
              ^1 in
      let xx23: Word16#
            = let ^: Ptr# rT Obj
                    = xx22 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx24: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx25: TextLit#
            = let ^: Ptr# rT Obj
                    = xx24 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx26: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Cons"# in
              ^1 in
      let xx27: TextLit#
            = let ^: Ptr# rT Obj
                    = xx26 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx28: Word32#
            = ddcInfoFrameAddData xx19 xx21 xx23 xx25 xx27 in
      let xx4: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx28 in
              ^1 in
      let xx29: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx5: Ptr# rT Obj
            = ddcInfoFramePush xx29 in
      ddcBoxedAlloc [rT] TAG0# 0#
}


-- Keep witnesses arguments
Fragment violation when converting Discus module to Salt module.
  Cannot convert expression.
    Cannot convert function abstraction in this context.
    The program must be lambda-lifted before conversion.
  
    with: λ(w: Mutable r).λ(x: Unit). convert# [U# Word64#] [Word64#] 42w64##


-------------------------------------------------------------------------------
-- Trigger errors about unsupported features in the Tetra to Salt conversion.
ok

-- OK: Anonymous binders are namified on the way into the conversion.
module Test with
letrec {
  id: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). xx0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Error: partial application of primitive data constructors is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: partial application if user defined data constructors is now supported.
module Test with
letrec {
  thing$l$L$2: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(l$0$0 l$1$1: Ptr# rT Obj).
      let ^: Ptr# rT Obj
            = ddcBoxedAlloc [rT] TAG0# 2# in
      let _: Void#
            = ddcBoxedSetField [rT] [rT] ^0 0# l$0$0 in
      let _: Void#
            = ddcBoxedSetField [rT] [rT] ^0 1# l$1$1 in
      ^0;
  
  thing: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
            = ddcThunkAlloc [rT] (convert# [Addr#] [Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj] thing$l$L$2) 2# 0# 0# 0# in
      let xx6: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
              ^1 in
      let ^: Ptr# rT Obj
            = ddcThunkExtend [rT] [rT] xx1 1# in
      let ^: Nat#
            = ddcThunkArgs [rT] xx1 in
      let _: Void#
            = ddcThunkSetField [rT] [rT] ^1 ^0 0# xx6 in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx7: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
              ^1 in
      let xx8: Nat#
            = let ^: Ptr# rT Obj
                    = xx7 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Nat#
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx9: Addr#
            = ddcInfoFrameNew xx8 in
      let xx3: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
              ^1 in
      let xx10: Addr#
            = let ^: Ptr# rT Obj
                    = xx3 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx11: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx12: Word16#
            = let ^: Ptr# rT Obj
                    = xx11 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx13: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 2w16# in
              ^1 in
      let xx14: Word16#
            = let ^: Ptr# rT Obj
                    = xx13 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx15: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx16: TextLit#
            = let ^: Ptr# rT Obj
                    = xx15 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx17: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Thing"# in
              ^1 in
      let xx18: TextLit#
            = let ^: Ptr# rT Obj
                    = xx17 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx19: Word32#
            = ddcInfoFrameAddData xx10 xx12 xx14 xx16 xx18 in
      let xx4: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx19 in
              ^1 in
      let xx20: Addr#
            = let ^: Ptr# rT Obj
                    = xx3 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx5: Ptr# rT Obj
            = ddcInfoFramePush xx20 in
      ddcBoxedAlloc [rT] TAG0# 0#
}


-- Error: partial application of primitive operators is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: let expressions in nested contexts are normalized on the way in to
-- the conversion.
module Test with
letrec {
  id: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
              ^1 in
      id [rT] xx1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Error: higher kinded type arguments are not yet supported.
module Test with
letrec {
  nothin: [b$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(b$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
              ^1 in
      nothin [rT] xx5;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx6: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
              ^1 in
      let xx7: Nat#
            = let ^: Ptr# rT Obj
                    = xx6 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Nat#
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx8: Addr#
            = ddcInfoFrameNew xx7 in
      let xx2: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx8 in
              ^1 in
      let xx9: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx10: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
              ^1 in
      let xx11: Word16#
            = let ^: Ptr# rT Obj
                    = xx10 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx12: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 1w16# in
              ^1 in
      let xx13: Word16#
            = let ^: Ptr# rT Obj
                    = xx12 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Word16#
                    = peek# [rT] [Word16#]
                          (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
              ^0 in
      let xx14: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Test"# in
              ^1 in
      let xx15: TextLit#
            = let ^: Ptr# rT Obj
                    = xx14 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx16: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) "Nil"# in
              ^1 in
      let xx17: TextLit#
            = let ^: Ptr# rT Obj
                    = xx16 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: TextLit#
                    = peek# [rT] [TextLit#]
                          (plusPtr# [rT] [TextLit#] (castPtr# [rT] [TextLit#] [Word8#] ^0) 0#) in
              ^0 in
      let xx18: Word32#
            = ddcInfoFrameAddData xx9 xx11 xx13 xx15 xx17 in
      let xx3: Ptr# rT Obj
            = let ^: Ptr# rT Obj
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let _: Void#
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx18 in
              ^1 in
      let xx19: Addr#
            = let ^: Ptr# rT Obj
                    = xx2 in
              let ^: Ptr# rT Word8#
                    = ddcSmallPayload [rT] ^0 in
              let ^: Addr#
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx4: Ptr# rT Obj
            = ddcInfoFramePush xx19 in
      ddcBoxedAlloc [rT] TAG0# 0#
}


-------------------------------------------------------------------------------
-- Ok: we should be able to convert the Alloc, Read, Write caps,
-- even though conversion for the Ref primops isn't implemented yet.
module Test with
letrec {
  blerk: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let ^: Ptr# rT Obj
            = ddcSmallAlloc [rT] TAG0# 1# in
      let ^: Ptr# rT Word8#
            = ddcSmallPayload [rT] ^0 in
      let _: Void#
            = poke# [rT] [Nat#]
                  (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx4: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


