ok
ok

-- Set the builder explicitly so we get consistent object layouts.
ok


-------------------------------------------------------------------------------
-- Unboxed literal patterns.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word16#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word16#
                = peek# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        5w16#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 6w16# in
            ^1;
        7w16#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 8w16# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word16"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word16#]
                      (plusPtr# [rT] [Word16#] (castPtr# [rT] [Word16#] [Word8#] ^0) 0#) 0w16# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word32#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word32#
                = peek# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        5w32#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 6w32# in
            ^1;
        7w32#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 8w32# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) 0w32# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Word64#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Word64#
                = peek# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        5w64#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 6w64# in
            ^1;
        7w64#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 8w64# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word64"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word64#]
                      (plusPtr# [rT] [Word64#] (castPtr# [rT] [Word64#] [Word8#] ^0) 0#) 0w64# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Unboxed Bool pattern.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4: Bool#
          = let ^: Ptr# rT Obj
                = x in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Bool#
                = peek# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) in
            ^0 in
      case xx4 of {
        True#  
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Bool"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) False# in
            ^1;
        _ 
         -> let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Bool"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Bool#]
                      (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) True# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Compile nested function via lambda lifting.
Error in transformed module.
  in stage CoreLoad
  in pipe  PipeCoreCheck/Check
  <batch>:53:12
  Cannot apply non-function
                of type: [a: Data].a -> a


-- Compile application of anonymous function.
module Test with
letrec {
  app: [a$r b$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r b$r: Region).
      λ(f x: Ptr# rT Obj). ddcApply1 [rT] [rT] [rT] f x;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx4: Addr#
          = ddcInfoFrameNew 1# in
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx4 in
            ^1 in
      let xx5: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx6: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx5 2w16# 0w16# "Test"# "app"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.app"#) 0# ^0 in
            ^0 in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx6 in
            ^1 in
      let xx7: Addr#
          = let ^: Ptr# rT Obj
                = xx1 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx3: Ptr# rT Obj
          = ddcInfoFramePush xx7 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Construct a lists of units.
-- The head field of the Cons cells has no primary region.
module Test with
letrec {
  singleton: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx0: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcBoxedAlloc [rT] TAG0#
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0#) 0# in
            ^0 in
      let ^: Ptr# rT Obj
          = ddcBoxedAlloc [rT] TAG1#
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0#) 2# in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 0# x in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 1# xx0 in
      ^0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx9: Addr#
          = ddcInfoFrameNew 2# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx10 0w16# 0w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx13: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx12 1w16# 2w16# "Test"# "Cons"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
            ^1 in
      let xx14: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx14 in
      let xx15: Addr#
          = ddcInfoFrameNew 1# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx15 in
            ^1 in
      let xx16: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx17: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx16 1w16# 0w16# "Test"# "singleton"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.singleton"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
            ^1 in
      let xx18: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx18 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Destruct a list of units.
-- The head field of the Cons cell has no primary region.
module Test with
letrec {
  headUnit: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG1#  
         -> let x: Ptr# rT Obj
                = ddcBoxedGetField [rT] [rT] xx 0# in
            let xx0: Ptr# rT Obj
                = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        TAG0#  
         -> ddcBoxedAlloc [rT] TAG0# 1w32# 0#;
        _ 
         -> fail# [Ptr# rT Obj]
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx9: Addr#
          = ddcInfoFrameNew 2# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx10 0w16# 0w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx13: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx12 1w16# 2w16# "Test"# "Cons"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Cons"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
            ^1 in
      let xx14: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx14 in
      let xx15: Addr#
          = ddcInfoFrameNew 1# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx15 in
            ^1 in
      let xx16: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx17: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx16 1w16# 0w16# "Test"# "headUnit"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.headUnit"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
            ^1 in
      let xx18: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx18 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Keep witnesses arguments
Fragment violation when converting Discus module to Salt module.
  Cannot convert expression.
    Cannot convert function abstraction in this context.
    The program must be lambda-lifted before conversion.
  
    with: λ(w: Mutable r).λ(x: Unit). convert# [U# Word64#] [Word64#] 42w64##


-------------------------------------------------------------------------------
-- Trigger errors about unsupported features in the Tetra to Salt conversion.
ok

-- OK: Anonymous binders are namified on the way into the conversion.
module Test with
letrec {
  id: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). xx0;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx5: Addr#
          = ddcInfoFrameNew 1# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
            ^1 in
      let xx6: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx6 1w16# 0w16# "Test"# "id"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.id"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx4: Ptr# rT Obj
          = ddcInfoFramePush xx8 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Error: partial application of primitive data constructors is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: partial application if user defined data constructors is now supported.
module Test with
letrec {
  thing$l$L$2: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(l$0$0 l$1$1: Ptr# rT Obj).
      let ^: Ptr# rT Obj
          = ddcBoxedAlloc [rT] TAG0#
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Test.Thing"#) 0#) 2# in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 0# l$0$0 in
      let _: Void#
          = ddcBoxedSetField [rT] [rT] ^0 1# l$1$1 in
      ^0;
  
  thing: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
          = ddcThunkAlloc [rT] (convert# [Addr#] [Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj] thing$l$L$2) 2# 0# 0# 0# in
      let xx9: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      let ^: Ptr# rT Obj
          = ddcThunkExtend [rT] [rT] xx1 1# in
      let ^: Nat# 
          = ddcThunkArgs [rT] xx1 in
      let _: Void#
          = ddcThunkSetField [rT] [rT] ^1 ^0 0# xx9 in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx10: Addr#
          = ddcInfoFrameNew 1# in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx10 in
            ^1 in
      let xx11: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx12: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx11 0w16# 2w16# "Test"# "Thing"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Thing"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx12 in
            ^1 in
      let xx13: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx5: Ptr# rT Obj
          = ddcInfoFramePush xx13 in
      let xx14: Addr#
          = ddcInfoFrameNew 1# in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx14 in
            ^1 in
      let xx15: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx16: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx15 1w16# 0w16# "Test"# "thing"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.thing"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx16 in
            ^1 in
      let xx17: Addr#
          = let ^: Ptr# rT Obj
                = xx6 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx17 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Error: partial application of primitive operators is not supported.
Error in transformed module.
  in stage DiscusToSalt/toSalt
  in pipe  PipeCoreCheck/Check
  ()
  Type mismatch.
    inferred type: U# Nat#
    expected type: U# Nat# -> U# Nat#


-- OK: let expressions in nested contexts are normalized on the way in to
-- the conversion.
module Test with
letrec {
  id: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx1: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      id [rT] xx1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx7: Addr#
          = ddcInfoFrameNew 2# in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx7 in
            ^1 in
      let xx8: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx9: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx8 1w16# 0w16# "Test"# "id"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.id"#) 0# ^0 in
            ^0 in
      let xx4: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx9 in
            ^1 in
      let xx10: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx11: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx10 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
            ^1 in
      let xx12: Addr#
          = let ^: Ptr# rT Obj
                = xx3 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx6: Ptr# rT Obj
          = ddcInfoFramePush xx12 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-- Error: higher kinded type arguments are not yet supported.
module Test with
letrec {
  nothin: [b$r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(b$r: Region).
      λ(x: Ptr# rT Obj). x;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx9: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Nat#]
                      (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
            ^1 in
      nothin [rT] xx9;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj).
      let xx10: Addr#
          = ddcInfoFrameNew 1# in
      let xx2: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx10 in
            ^1 in
      let xx11: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx12: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddData xx11 0w16# 1w16# "Test"# "Nil"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.data.Test.Nil"#) 0# ^0 in
            ^0 in
      let xx3: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx12 in
            ^1 in
      let xx13: Addr#
          = let ^: Ptr# rT Obj
                = xx2 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx4: Ptr# rT Obj
          = ddcInfoFramePush xx13 in
      let xx14: Addr#
          = ddcInfoFrameNew 2# in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx14 in
            ^1 in
      let xx15: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx16: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx15 1w16# 0w16# "Test"# "nothin"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.nothin"#) 0# ^0 in
            ^0 in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx16 in
            ^1 in
      let xx17: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx18: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx17 1w16# 0w16# "Test"# "foo"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.foo"#) 0# ^0 in
            ^0 in
      let xx7: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx18 in
            ^1 in
      let xx19: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx8: Ptr# rT Obj
          = ddcInfoFramePush xx19 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


-------------------------------------------------------------------------------
-- Ok: we should be able to convert the Alloc, Read, Write caps,
-- even though conversion for the Ref primops isn't implemented yet.
module Test with
letrec {
  blerk: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let ^: Ptr# rT Obj
          = ddcSmallAlloc [rT]
                (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Nat"#) 0#) 1# in
      let ^: Ptr# rT Word8#
          = ddcSmallPayload [rT] ^0 in
      let _: Void#
          = poke# [rT] [Nat#]
                (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx4: Ptr# rT Obj).
      let xx8: Addr#
          = ddcInfoFrameNew 1# in
      let xx5: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Addr"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx8 in
            ^1 in
      let xx9: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx10: Word32#
          = let ^: Word32#
                = ddcInfoFrameAddSuper xx9 1w16# 0w16# "Test"# "blerk"# in
            let _: Void#
                = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.super.Test.blerk"#) 0# ^0 in
            ^0 in
      let xx6: Ptr# rT Obj
          = let ^: Ptr# rT Obj
                = ddcSmallAlloc [rT]
                      (read# [Word32#] (global# [Word32#] "ddcInfoIndex.data.Base.Word32"#) 0#) 1# in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let _: Void#
                = poke# [rT] [Word32#]
                      (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx10 in
            ^1 in
      let xx11: Addr#
          = let ^: Ptr# rT Obj
                = xx5 in
            let ^: Ptr# rT Word8#
                = ddcSmallPayload [rT] ^0 in
            let ^: Addr#
                = peek# [rT] [Addr#]
                      (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
            ^0 in
      let xx7: Ptr# rT Obj
          = ddcInfoFramePush xx11 in
      ddcBoxedAlloc [rT] TAG0# 1w32# 0#
}


