ok
ok
ok

-- Simple Functions.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx2    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 3# in
              ^1 in
      let xx3    
            = let ^      
                    = xx2 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx4    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx5    
            = add# [Nat#] xx3 xx4 in
      let xx0    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx5 in
              ^1 in
      let xx6    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 2# in
              ^1 in
      let xx7    
            = let ^      
                    = xx6 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx8    
            = let ^      
                    = xx0 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx9    
            = add# [Nat#] xx7 xx8 in
      let ^      
            = ddcSmallAlloc [rT] TAG0# 1# in
      let ^      
            = ddcSmallPayload [rT] ^0 in
      let _      
            = poke# [rT] [Nat#]
                  (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx9 in
      ^1;
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Match aginst literal Bools.
module Test with
letrec {
  neg: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Bool#]
                          (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        True#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) False# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) True# in
            ^1
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Match against literal Nat.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        5#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 6# in
            ^1;
        6#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 7# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Nested case expression.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(x y: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        0#  
         -> let xx2    
                  = let ^      
                          = y in
                    let ^      
                          = ddcSmallPayload [rT] ^0 in
                    let ^      
                          = peek# [rT] [Nat#]
                                (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
                    ^0 in
            case xx2 of {
              0#  
               -> let ^      
                        = ddcSmallAlloc [rT] TAG0# 1# in
                  let ^      
                        = ddcSmallPayload [rT] ^0 in
                  let _      
                        = poke# [rT] [Nat#]
                              (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
                  ^1;
              _ 
               -> let ^      
                        = ddcSmallAlloc [rT] TAG0# 1# in
                  let ^      
                        = ddcSmallPayload [rT] ^0 in
                  let _      
                        = poke# [rT] [Nat#]
                              (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
                  ^1
            };
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Full application of top-level function.
module Test with
letrec {
  add: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(x y: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx2    
            = let ^      
                    = y in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx3    
            = add# [Nat#] xx1 xx2 in
      let ^      
            = ddcSmallAlloc [rT] TAG0# 1# in
      let ^      
            = ddcSmallPayload [rT] ^0 in
      let _      
            = poke# [rT] [Nat#]
                  (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx3 in
      ^1;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
              ^1 in
      add x xx4;
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Flip an enumerated value.
module Test with
letrec {
  flipit: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      case ddcBoxedTag [rT] x of {
        TAG0#  
         -> let ^      
                  = ddcBoxedAlloc [rT] TAG1# 0# in
            ^0;
        TAG1#  
         -> let ^      
                  = ddcBoxedAlloc [rT] TAG0# 0# in
            ^0;
        _ 
         -> fail# [Ptr# rT Obj]
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Function to take the head of a monomorphic list.
module Test with
letrec {
  head: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Function to take the head of a polymorphic list.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Case expressions on literals.
-- Need to unbox scrutinee.
module Test with
letrec {
  swap: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        0#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Polymorphically take the head of a list, where the element
-- is in the top-level region. In the Salt code the head function
-- is passed the top level region as the location of the element.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x$Sx101: Ptr# rT Obj).
      let xx0    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1# 0# in
              ^0 in
      let xx3    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
              ^1 in
      let xx1    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0# 2# in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 0# xx3 in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 1# xx0 in
              ^0 in
      let xx4    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
              ^1 in
      head [rT] xx4 xx1;
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}


-- Polymorphically take the head of a list, where the element
-- has its own primary region annotation. In the Salt code the head
-- function is passed the top level region as the location of the element.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  foo: [r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(r: Region).
      λ(x$Sx101: Ptr# rT Obj).
      let xx0    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0# 0# in
              ^0 in
      let xx1    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1# 0# in
              ^0 in
      let xx2    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1# 0# in
              ^0 in
      let xx3    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0# 2# in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 0# xx1 in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 1# xx2 in
              ^0 in
      head [rT] xx0 xx3;
  
  init_Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx4: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0#
}

