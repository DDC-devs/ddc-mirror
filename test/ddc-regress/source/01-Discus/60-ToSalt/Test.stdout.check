ok
ok
ok

-- Simple Functions.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx2    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx3    
            = add# [Nat#] 3# xx2 in
      let xx0    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx3 in
              ^1 in
      let xx4    
            = let ^      
                    = xx0 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx5    
            = add# [Nat#] 2# xx4 in
      let ^      
            = ddcSmallAlloc [rT] TAG0# 1# in
      let ^      
            = ddcSmallPayload [rT] ^0 in
      let _      
            = poke# [rT] [Nat#]
                  (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx5 in
      ^1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx1: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Match aginst literal Bools.
module Test with
letrec {
  neg: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Bool#]
                          (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        True#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) False# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Bool#]
                        (plusPtr# [rT] [Bool#] (castPtr# [rT] [Bool#] [Word8#] ^0) 0#) True# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Match against literal Nat.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        5#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 6# in
            ^1;
        6#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 7# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Nested case expression.
module Test with
letrec {
  foo: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(x y: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        0#  
         -> let xx2    
                  = let ^      
                          = y in
                    let ^      
                          = ddcSmallPayload [rT] ^0 in
                    let ^      
                          = peek# [rT] [Nat#]
                                (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
                    ^0 in
            case xx2 of {
              0#  
               -> let ^      
                        = ddcSmallAlloc [rT] TAG0# 1# in
                  let ^      
                        = ddcSmallPayload [rT] ^0 in
                  let _      
                        = poke# [rT] [Nat#]
                              (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
                  ^1;
              _ 
               -> let ^      
                        = ddcSmallAlloc [rT] TAG0# 1# in
                  let ^      
                        = ddcSmallPayload [rT] ^0 in
                  let _      
                        = poke# [rT] [Nat#]
                              (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
                  ^1
            };
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Full application of top-level function.
module Test with
letrec {
  add: Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = λ(x y: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx2    
            = let ^      
                    = y in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      let xx3    
            = add# [Nat#] xx1 xx2 in
      let ^      
            = ddcSmallAlloc [rT] TAG0# 1# in
      let ^      
            = ddcSmallPayload [rT] ^0 in
      let _      
            = poke# [rT] [Nat#]
                  (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) xx3 in
      ^1;
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx4    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 5# in
              ^1 in
      add x xx4;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Flip an enumerated value.
module Test with
letrec {
  flipit: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      case ddcBoxedTag [rT] x of {
        TAG0#  
         -> let ^      
                  = ddcBoxedAlloc [rT] TAG1#
                        (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Cold"#) 0#) 0# in
            ^0;
        TAG1#  
         -> let ^      
                  = ddcBoxedAlloc [rT] TAG0#
                        (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Hot"#) 0#) 0# in
            ^0;
        _ 
         -> fail# [Ptr# rT Obj]
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5    
            = ddcInfoFrameNew 2# in
      let xx1    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
              ^1 in
      let xx6    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx7    
            = let ^      
                    = ddcInfoFrameAddData xx6 0w16# 0w16# "Test"# "Hot"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Hot"#) 0# ^0 in
              ^0 in
      let xx2    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
              ^1 in
      let xx8    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx9    
            = let ^      
                    = ddcInfoFrameAddData xx8 1w16# 0w16# "Test"# "Cold"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cold"#) 0# ^0 in
              ^0 in
      let xx3    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx9 in
              ^1 in
      let xx10   
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx4    
            = ddcInfoFramePush xx10 in
      ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Function to take the head of a monomorphic list.
module Test with
letrec {
  head: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5    
            = ddcInfoFrameNew 2# in
      let xx1    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
              ^1 in
      let xx6    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx7    
            = let ^      
                    = ddcInfoFrameAddData xx6 0w16# 2w16# "Test"# "Cons"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cons"#) 0# ^0 in
              ^0 in
      let xx2    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
              ^1 in
      let xx8    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx9    
            = let ^      
                    = ddcInfoFrameAddData xx8 1w16# 0w16# "Test"# "Nil"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Nil"#) 0# ^0 in
              ^0 in
      let xx3    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx9 in
              ^1 in
      let xx10   
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx4    
            = ddcInfoFramePush xx10 in
      ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Function to take the head of a polymorphic list.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj).
      let xx5    
            = ddcInfoFrameNew 2# in
      let xx1    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx5 in
              ^1 in
      let xx6    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx7    
            = let ^      
                    = ddcInfoFrameAddData xx6 0w16# 2w16# "Test"# "Cons"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cons"#) 0# ^0 in
              ^0 in
      let xx2    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx7 in
              ^1 in
      let xx8    
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx9    
            = let ^      
                    = ddcInfoFrameAddData xx8 1w16# 0w16# "Test"# "Nil"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Nil"#) 0# ^0 in
              ^0 in
      let xx3    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx9 in
              ^1 in
      let xx10   
            = let ^      
                    = xx1 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx4    
            = ddcInfoFramePush xx10 in
      ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Case expressions on literals.
-- Need to unbox scrutinee.
module Test with
letrec {
  swap: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x: Ptr# rT Obj).
      let xx1    
            = let ^      
                    = x in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) in
              ^0 in
      case xx1 of {
        0#  
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
            ^1;
        _ 
         -> let ^      
                  = ddcSmallAlloc [rT] TAG0# 1# in
            let ^      
                  = ddcSmallPayload [rT] ^0 in
            let _      
                  = poke# [rT] [Nat#]
                        (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
            ^1
      };
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx0: Ptr# rT Obj). ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Polymorphically take the head of a list, where the element
-- is in the top-level region. In the Salt code the head function
-- is passed the top level region as the location of the element.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  foo: Ptr# rT Obj -> Ptr# rT Obj
    = λ(x$Sx101: Ptr# rT Obj).
      let xx0    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Nil"#) 0#) 0# in
              ^0 in
      let xx7    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 1# in
              ^1 in
      let xx1    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Cons"#) 0#) 2# in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 0# xx7 in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 1# xx0 in
              ^0 in
      let xx8    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Nat#]
                          (plusPtr# [rT] [Nat#] (castPtr# [rT] [Nat#] [Word8#] ^0) 0#) 0# in
              ^1 in
      head [rT] xx8 xx1;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx2: Ptr# rT Obj).
      let xx9    
            = ddcInfoFrameNew 2# in
      let xx3    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx9 in
              ^1 in
      let xx10   
            = let ^      
                    = xx3 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx11   
            = let ^      
                    = ddcInfoFrameAddData xx10 0w16# 2w16# "Test"# "Cons"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cons"#) 0# ^0 in
              ^0 in
      let xx4    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx11 in
              ^1 in
      let xx12   
            = let ^      
                    = xx3 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx13   
            = let ^      
                    = ddcInfoFrameAddData xx12 1w16# 0w16# "Test"# "Nil"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Nil"#) 0# ^0 in
              ^0 in
      let xx5    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx13 in
              ^1 in
      let xx14   
            = let ^      
                    = xx3 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx6    
            = ddcInfoFramePush xx14 in
      ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}


-- Polymorphically take the head of a list, where the element
-- has its own primary region annotation. In the Salt code the head
-- function is passed the top level region as the location of the element.
module Test with
letrec {
  head: [a$r: Region].Ptr# rT Obj -> Ptr# rT Obj -> Ptr# rT Obj
    = Λ(a$r: Region).
      λ(def xx: Ptr# rT Obj).
      case ddcBoxedTag [rT] xx of {
        TAG0#  
         -> let x      
                  = ddcBoxedGetField [rT] [rT] xx 0# in
            let x$Sx100
                  = ddcBoxedGetField [rT] [rT] xx 1# in
            x;
        _ 
         -> def
      };
  
  foo: [r: Region].Ptr# rT Obj -> Ptr# rT Obj
    = Λ(r: Region).
      λ(x$Sx101: Ptr# rT Obj).
      let xx0    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Hot"#) 0#) 0# in
              ^0 in
      let xx1    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Cold"#) 0#) 0# in
              ^0 in
      let xx2    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG1#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Nil"#) 0#) 0# in
              ^0 in
      let xx3    
            = let ^      
                    = ddcBoxedAlloc [rT] TAG0#
                          (read# [Word32#] (global# [Word32#] "ddcInfoIndex.Test.Cons"#) 0#) 2# in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 0# xx1 in
              let _      
                    = ddcBoxedSetField [rT] [rT] ^0 1# xx2 in
              ^0 in
      head [rT] xx0 xx3;
  
  _init$Test: Ptr# rT Obj -> Ptr# rT Obj
    = λ(xx4: Ptr# rT Obj).
      let xx13   
            = ddcInfoFrameNew 2# in
      let xx5    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx13 in
              ^1 in
      let xx14   
            = let ^      
                    = xx5 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx15   
            = let ^      
                    = ddcInfoFrameAddData xx14 0w16# 2w16# "Test"# "Cons"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cons"#) 0# ^0 in
              ^0 in
      let xx6    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx15 in
              ^1 in
      let xx16   
            = let ^      
                    = xx5 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx17   
            = let ^      
                    = ddcInfoFrameAddData xx16 1w16# 0w16# "Test"# "Nil"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Nil"#) 0# ^0 in
              ^0 in
      let xx7    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx17 in
              ^1 in
      let xx18   
            = let ^      
                    = xx5 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx8    
            = ddcInfoFramePush xx18 in
      let xx19   
            = ddcInfoFrameNew 2# in
      let xx9    
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) xx19 in
              ^1 in
      let xx20   
            = let ^      
                    = xx9 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx21   
            = let ^      
                    = ddcInfoFrameAddData xx20 0w16# 0w16# "Test"# "Hot"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Hot"#) 0# ^0 in
              ^0 in
      let xx10   
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx21 in
              ^1 in
      let xx22   
            = let ^      
                    = xx9 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx23   
            = let ^      
                    = ddcInfoFrameAddData xx22 1w16# 0w16# "Test"# "Cold"# in
              let _      
                    = write# [Word32#] (globali# [Word32#] "ddcInfoIndex.Test.Cold"#) 0# ^0 in
              ^0 in
      let xx11   
            = let ^      
                    = ddcSmallAlloc [rT] TAG0# 1# in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let _      
                    = poke# [rT] [Word32#]
                          (plusPtr# [rT] [Word32#] (castPtr# [rT] [Word32#] [Word8#] ^0) 0#) xx23 in
              ^1 in
      let xx24   
            = let ^      
                    = xx9 in
              let ^      
                    = ddcSmallPayload [rT] ^0 in
              let ^      
                    = peek# [rT] [Addr#]
                          (plusPtr# [rT] [Addr#] (castPtr# [rT] [Addr#] [Word8#] ^0) 0#) in
              ^0 in
      let xx12   
            = ddcInfoFramePush xx24 in
      ddcBoxedAlloc [rT] TAG0# 0w32# 0#
}

