

-- Insert [?] holes for type applications of variables with explicit signatures.
-- We only reconstruct type applications for vars with signatures because we
-- can do it without proper constraint solving.
-- Convert source to core that includes holes, then fill holes at core level.
module Test where
data List ((a,{<batch>:3:16}@Data)) where {
        Nil : {<batch>:4:24}@{<batch>:4:19}@List {<batch>:4:24}@a;
        Cons : {<batch>:5:19}@a -> {<batch>:5:29}@{<batch>:5:24}@List {<batch>:5:29}@a -> {<batch>:5:39}@{<batch>:5:34}@List {<batch>:5:39}@a;
}
map 
  = /\a./\b.
     \f.
    \xx.
    case xs of {
      Nil 
        -> Nil;
      Cons x xs
        -> Cons (f x) (map f xs)
    }


-- Function application already has some explicit type arguments.
module Test where
data List ((a,{<batch>:3:16}@Data)) where {
        Nil : {<batch>:4:24}@{<batch>:4:19}@List {<batch>:4:24}@a;
        Cons : {<batch>:5:19}@a -> {<batch>:5:29}@{<batch>:5:24}@List {<batch>:5:29}@a -> {<batch>:5:39}@{<batch>:5:34}@List {<batch>:5:39}@a;
}
map 
  = /\a./\b.
     \f.
    \xx.
    case xs of {
      Nil 
        -> Nil;
      Cons x xs
        -> Cons [{<batch>:10:28}@a] (f x) (map [{<batch>:10:43}@a] f xs)
    }


-- If any type variables are not in scope in a top-level signature,
-- then insert quantifiers for these.
module Test where
data List ((a,{<batch>:3:16}@Data)) where {
        Nil : {<batch>:4:24}@{<batch>:4:19}@List {<batch>:4:24}@a;
        Cons : {<batch>:5:19}@a -> {<batch>:5:29}@{<batch>:5:24}@List {<batch>:5:29}@a -> {<batch>:5:39}@{<batch>:5:34}@List {<batch>:5:39}@a;
}
map 
  = \f.
    \xx.
    case xs of {
      Nil 
        -> Nil;
      Cons x xs
        -> Cons (f x) (map f xs)
    }


-- The expanded type for 'add' should be used when expanding the body
-- of 'length'.
module Test where
data List ((a,{<batch>:3:16}@Data)) where {
        Nil : {<batch>:4:24}@{<batch>:4:19}@List {<batch>:4:24}@a;
        Cons : {<batch>:5:19}@a -> {<batch>:5:29}@{<batch>:5:24}@List {<batch>:5:29}@a -> {<batch>:5:39}@{<batch>:5:34}@List {<batch>:5:39}@a;
}
add 
  = \x.
    \y.
    add# [{<batch>:8:17}@a] x y
length 
  = \xx.
    case xx of {
      Nil 
        -> 0;
      Cons x xs
        -> add 1 (length xs)
    }


-- Data type used in function signature has a region variable.
-- During elaboration we add a region parameter to the front of flipit.
module Test where
data Blerk ((r,{<batch>:3:17}@Region)) where {
        Hot : {<batch>:4:25}@{<batch>:4:19}@Blerk {<batch>:4:25}@r;
        Cold : {<batch>:5:25}@{<batch>:5:19}@Blerk {<batch>:5:25}@r;
}
flipit 
  = \x.
    case x of {
      Hot 
        -> Cold;
      Cold 
        -> Hot
    }

