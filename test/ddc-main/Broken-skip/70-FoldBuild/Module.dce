module Module
exports {

foldr   :: [a b : *]. [r : %].
        [ek1 ek2 ez : !]. [ck1 ck2 cz : $].
        (a -(ek1|ck1)> b -(ek2|ck2)> b) -(!0 | Use r)> 
        (Unit -(ez|cz)> b)              -(!0 | Use r + ck1)>
        (List r a)                      -(Read r + ek1 + ek2 + ez | ck1 + cz + Use r)>
        b;


build :: [a : *]. [r : %]. [eg1 eg2 : !]. [cg1 cg2 : $].
    ([b : *]. [ec1 ec2 en : !]. [cc1 cc2 cn : $].
	 (a -(ec1|cc1)> b -(ec2|cc2)> b)
	-(eg1|cg1)>
	 (Unit -(en|cn)> b)
	-(eg2+ec1+ec2+en|cg2+cc1)>
	 b)
    -(eg1+eg2 + Alloc r | Use r)> List r a;

-- TODO implement
foldrAndBuild ::
    [a b : *]. [r : %].
    [ek1 ek2 ez : !]. [ck1 ck2 cz : $].
    [eg1 eg2 : !]. [cg1 cg2 : $].

	(a -(ek1|ck1)> b -(ek2|ck2)> b)
    ->	(Unit -(ez|cz)> b)

-- TODO very strange issue here: if use names 'ec1' instead of 'ec1FB' they parse as anonymous & then references get mixed up
    ->  ([bFB : *]. [ec1FB ec2FB enFB : !]. [cc1FB cc2FB cnFB : $].
	     (a -(ec1FB|cc1FB)> bFB -(ec2FB|cc2FB)> bFB)
	    -(eg1|cg1)>
	     (Unit -(enFB|cnFB)> bFB)
	    -(eg2+ec1FB+ec2FB+enFB|cg2+cc1FB)>
	     bFB)
    -(Read r + ek1 + ek2 + ez + eg1 + eg2 + Alloc r | ck1 + ck2 + cz + Use r)>
    b;

compose :: [a b c : *]. [ef eg : !]. [cf cg : $].
       (b -(ef|cf)> c)
    -> (a -(eg|cg)> b)
    -(!0      | cf)>
	a
    -(ef + eg | cf + cg)>
	c;

plus ::
    Int R0#
    -( !0 | Use R0#)>
    Int R0#
    -(Read R0# + Alloc R0# | Use R0#)>
    Int R0#;

zero ::
    Unit
    -(Alloc R0# | Use R0#)>
    Int R0#;

pred ::
    Int R0#
    -(Read R0# + Alloc R0# | Use R0#)>
    Int R0#;

countZ ::
    Int R0#
    -(!0 | Use R0#)>
    ([b : *].
    [ec1 ec2 en : !].
    [cc1 cc2 cn : $].
    (Int R0# -(ec1|cc1)> b -(ec2|cc2)> b)
    -(!0 | Use R0#)>
    (Unit -(en|cn)> b)
    -(Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + Use R0#)>
    b);

double ::
    Int R0#
    -(Alloc R0# + Read R0# | Use R0#)>
    Int R0#;

even ::
    Int R0#
    -(Alloc R0# + Read R0# | Use R0# )>
    Int R0#;

-- TODO double
}
with letrec

foldr  [a b : *] [r : %]
    [ek1 ek2 ez : !] [ck1 ck2 cz : $]
    (k : a -(ek1|ck1)> b -(ek2|ck2)> b)
    { !0 | Use r }
    (z : Unit -(ez|cz)> b)
    { !0 | Use r + ck1 }
    (xs: List r a)
    { Read r + ek1 + ek2 + ez | ck1 + cz + Use r }
    : b
    = case xs of {
	Nil -> z ();
	Cons x xs' ->
	    k x (foldr [:a b r ek1 ek2 ez ck1 ck2 cz:] k z xs')
    }

build [a : *] [r : %] [eg1 eg2 : !] [cg1 cg2 : $]
    (g : [b : *]. [ec1 ec2 en : !]. [cc1 cc2 cn : $].
	 (a -(ec1|cc1)> b -(ec2|cc2)> b)
	-(eg1|cg1)>
	 (Unit -(en|cn)> b)
	-(eg2+ec1+ec2+en|cg2+cc1)>
	 b)
    { eg1+eg2 + Alloc r | Use r }
    : List r a
    = g [List r a] [!0] [Alloc r] [Alloc r] [:$0 (DeepUse a) $0:]
	(Cons [:r a:]) (Nil [:r a:])

compose [a b c : *] [ef eg : !] [cf cg : $]
    (f : b -(ef|cf)> c) (g : a -(eg|cg)> b)
	    { !0      | cf }
    (x : a) { ef + eg | cf + cg }
	    : c
 = f (g x)


plus
    (a : Int R0#)
    { !0 | Use R0# }
    (b : Int R0#)
    { Read R0# + Alloc R0# | Use R0# }
    : Int R0#
    = addInt [:R0# R0# R0#:] a b

zero
    (u : Unit)
    { Alloc R0# | Use R0# }
    : Int R0# = 0 [R0#] ()

pred
    (a : Int R0#)
    { Read R0# + Alloc R0# | Use R0# }
    : Int R0# = subInt [:R0# R0# R0#:] a (1 [R0#] ())

countZ (m : Int R0#)
       { !0 | Use R0# }
       [b : *]
       [ec1 ec2 en : !]
       [cc1 cc2 cn : $]
       (k : Int R0# -(ec1|cc1)> b -(ec2|cc2)> b)
       { !0 | Use R0# }
       (z : Unit -(en|cn)> b)
       { Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + Use R0# }
       : b
    = case m of {
	0	-> z ();
	_	-> k m (countZ (pred m) [:b ec1 ec2 en cc1 cc2 cn:] k z)
	}


double (c : Int R0#)
    {Alloc R0# + Read R0# | Use R0# }
    : Int R0#
    = mulInt [:R0# R0# R0#:] c (2 [R0#] ())

even (c : Int R0#)
    {Alloc R0# + Read R0# | Use R0# }
    : Int R0#
    = weakeff [Read R0#]
      in
      0 [R0#] ()

