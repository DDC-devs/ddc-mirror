ok
ok

-- Simple fold over a vector
module Test with
letrec {
  x3$runproc$process : Ref# rT Int# -> Nat# -> Ptr# rT Int# -> S (Read rT + Write rT + Alloc rT) Unit
    = \(x0 : Ref# rT Int#).\(x2 : Nat#).\(x3 : Ptr# rT Int#).
      box
      let x0$init : Int#
            = run readRef# [rT] [Int#] x0 in
      let x0$acc$0 : Int# = x0$init in
      let loop$length : Nat# = x2 in
      letrec {
        loop : Nat# -> Int# -> S (Read rT + Write rT + Alloc rT) Int#
          = \(x1 : Nat#).\(x0$acc$1 : Int#).
            box
            case sub# [Nat#] loop$length x1 of {
              0#  
               -> x0$acc$1;
              _ 
               -> let x3$elem : Int#
                        = run readPtr# [rT] [Int#] [Nat#] x3 x1 in
                  let x0$val : Int# = x0$acc$1 in
                  let x4 : Int# = add# [Int#] x0$val x3$elem in
                  let x0$acc$2 : Int# = x4 in
                  run loop (add# [Nat#] x1 1#) x0$acc$2
            }
      } in
      let x0$acc$2 : Int#
            = run loop 0# x0$acc$0 in
      let x0$res : Int# = x0$acc$2 in
      let _ : Unit
            = run writeRef# [rT] [Int#] x0 x0$res in
      ();
  
  test : Tuple2# (Ptr# rT Int#) (Ref# rT Nat#) -> S (Read rT + Write rT + Alloc rT) Int#
    = \(x9 : Tuple2# (Ptr# rT Int#) (Ref# rT Nat#)).
      box
      let x10 : Ref# rT Int#
            = run allocRef# [rT] [Int#] 0i# in
      let x15 : Bool#
            = let _ : Unit
                    = run (\(x12 : Nat#).\(x13 : Ptr# rT Int#).
                       box
                       run x3$runproc$process x10 x12 x13)
                          (run readRef# [rT] [Nat#]
                               (proj2_2# [Ptr# rT Int#] [Ref# rT Nat#] x9))
                          (proj2_1# [Ptr# rT Int#] [Ref# rT Nat#] x9) in
              True# in
      let x17 : Int#
            = run readRef# [rT] [Int#] x10 in
      x17
}

