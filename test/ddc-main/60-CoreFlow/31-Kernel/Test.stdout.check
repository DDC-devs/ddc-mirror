-- Lowering to produce vectorised kernels.
ok
ok


-- Multiply two series.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Vector# Float32# -> Series# (Down8# t0) Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Vector# Float32#).\(x3 x4 : Series# (Down8# t0) Float32#).
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x3$elem = next$8# [Float32#] [t0] x3 x0 in
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x8$elem = vmul$8# [Float32#] x3$elem x4$elem in
                   let _ = vwrite$8# [Float32#] x2 x0 x8$elem in
                   ()) in
      ()
}


-- Multiply by constant, lifting replicates constant.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Vector# Float32# -> Series# (Down8# t0) Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Vector# Float32#).\(x3 x4 : Series# (Down8# t0) Float32#).
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x3$elem = next$8# [Float32#] [t0] x3 x0 in
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x8$elem = vmul$8# [Float32#] x3$elem x4$elem in
                   let x5 = vrep$8# [Float32#] 2.0f32# in
                   let x12$elem = vadd$8# [Float32#] x5 x8$elem in
                   let _ = vwrite$8# [Float32#] x2 x0 x12$elem in
                   ()) in
      ()
}


-- Gather from vector.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Vector# Float32# -> Vector# Float32# -> Series# (Down8# t0) Nat# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 x3 : Vector# Float32#).\(x4 : Series# (Down8# t0) Nat#).
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x4$elem = next$8# [Nat#] [t0] x4 x0 in
                   let x5$elem = vgather$8# [Float32#] x2 x4$elem in
                   let x5 = vrep$8# [Float32#] 2.0f32# in
                   let x8$elem = vadd$8# [Float32#] x5 x5$elem in
                   let _ = vwrite$8# [Float32#] x3 x0 x8$elem in
                   ()) in
      ()
}


-- Scatter into vector.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Vector# Float32# -> Series# (Down8# t0) Nat# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Vector# Float32#).\(x3 : Series# (Down8# t0) Nat#).\(x4 : Series# (Down8# t0) Float32#).
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x3$elem = next$8# [Nat#] [t0] x3 x0 in
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x5 = vrep$8# [Float32#] 2.0f32# in
                   let x7$elem = vadd$8# [Float32#] x5 x4$elem in
                   let _ = vscatter$8# [Float32#] x2 x3$elem x7$elem in
                   ()) in
      ()
}


-- Sum the elements of a vector.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Ref# Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Ref# Float32#).\(x3 : Series# (Down8# t0) Float32#).
      let x4 = vrep$8# [Float32#] 0.0f32# in
      let x2$vec
            = new# [Vec8# Float32#] x4 in
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x3$elem = next$8# [Float32#] [t0] x3 x0 in
                   let x2$val
                         = read# [Vec8# Float32#] x2$vec in
                   let x6 = vadd$8# [Float32#] x2$val x3$elem in
                   let _
                         = write# [Vec8# Float32#] x2$vec x6 in
                   ()) in
      let x2$res
            = read# [Vec8# Float32#] x2$vec in
      let x2$init = read# [Float32#] x2 in
      let x8 = vproj$8$0# [Float32#] x2$res in
      let x2$res$0 = add# [Float32#] x2$init x8 in
      let x10 = vproj$8$1# [Float32#] x2$res in
      let x2$res$1 = add# [Float32#] x2$res$0 x10 in
      let x12 = vproj$8$2# [Float32#] x2$res in
      let x2$res$2 = add# [Float32#] x2$res$1 x12 in
      let x14 = vproj$8$3# [Float32#] x2$res in
      let x2$res$3 = add# [Float32#] x2$res$2 x14 in
      let x16 = vproj$8$4# [Float32#] x2$res in
      let x2$res$4 = add# [Float32#] x2$res$3 x16 in
      let x18 = vproj$8$5# [Float32#] x2$res in
      let x2$res$5 = add# [Float32#] x2$res$4 x18 in
      let x20 = vproj$8$6# [Float32#] x2$res in
      let x2$res$6 = add# [Float32#] x2$res$5 x20 in
      let x22 = vproj$8$7# [Float32#] x2$res in
      let x2$res$7 = add# [Float32#] x2$res$6 x22 in
      let _ = write# [Float32#] x2 x2$res$7 in
      ()
}


-- Fuse gather, map and reduce in one.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Ref# Float32# -> Vector# Float32# -> Series# (Down8# t0) Nat# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Ref# Float32#).\(x3 : Vector# Float32#).\(x4 : Series# (Down8# t0) Nat#).
      let x5 = vrep$8# [Float32#] 0.0f32# in
      let x2$vec
            = new# [Vec8# Float32#] x5 in
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x4$elem = next$8# [Nat#] [t0] x4 x0 in
                   let x5$elem = vgather$8# [Float32#] x3 x4$elem in
                   let x6 = vrep$8# [Float32#] 2.0f32# in
                   let x8$elem = vmul$8# [Float32#] x6 x5$elem in
                   let x2$val
                         = read# [Vec8# Float32#] x2$vec in
                   let x7 = vadd$8# [Float32#] x2$val x8$elem in
                   let _
                         = write# [Vec8# Float32#] x2$vec x7 in
                   ()) in
      let x2$res
            = read# [Vec8# Float32#] x2$vec in
      let x2$init = read# [Float32#] x2 in
      let x9 = vproj$8$0# [Float32#] x2$res in
      let x2$res$0 = add# [Float32#] x2$init x9 in
      let x12 = vproj$8$1# [Float32#] x2$res in
      let x2$res$1 = add# [Float32#] x2$res$0 x12 in
      let x14 = vproj$8$2# [Float32#] x2$res in
      let x2$res$2 = add# [Float32#] x2$res$1 x14 in
      let x16 = vproj$8$3# [Float32#] x2$res in
      let x2$res$3 = add# [Float32#] x2$res$2 x16 in
      let x18 = vproj$8$4# [Float32#] x2$res in
      let x2$res$4 = add# [Float32#] x2$res$3 x18 in
      let x20 = vproj$8$5# [Float32#] x2$res in
      let x2$res$5 = add# [Float32#] x2$res$4 x20 in
      let x22 = vproj$8$6# [Float32#] x2$res in
      let x2$res$6 = add# [Float32#] x2$res$5 x22 in
      let x24 = vproj$8$7# [Float32#] x2$res in
      let x2$res$7 = add# [Float32#] x2$res$6 x24 in
      let _ = write# [Float32#] x2 x2$res$7 in
      ()
}


-- Dot product.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Ref# Float32# -> Series# (Down8# t0) Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 : Ref# Float32#).\(x3 x4 : Series# (Down8# t0) Float32#).
      let x5 = vrep$8# [Float32#] 0.0f32# in
      let x2$vec
            = new# [Vec8# Float32#] x5 in
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x3$elem = next$8# [Float32#] [t0] x3 x0 in
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x8$elem = vmul$8# [Float32#] x3$elem x4$elem in
                   let x2$val
                         = read# [Vec8# Float32#] x2$vec in
                   let x6 = vadd$8# [Float32#] x2$val x8$elem in
                   let _
                         = write# [Vec8# Float32#] x2$vec x6 in
                   ()) in
      let x2$res
            = read# [Vec8# Float32#] x2$vec in
      let x2$init = read# [Float32#] x2 in
      let x8 = vproj$8$0# [Float32#] x2$res in
      let x2$res$0 = add# [Float32#] x2$init x8 in
      let x10 = vproj$8$1# [Float32#] x2$res in
      let x2$res$1 = add# [Float32#] x2$res$0 x10 in
      let x13 = vproj$8$2# [Float32#] x2$res in
      let x2$res$2 = add# [Float32#] x2$res$1 x13 in
      let x15 = vproj$8$3# [Float32#] x2$res in
      let x2$res$3 = add# [Float32#] x2$res$2 x15 in
      let x17 = vproj$8$4# [Float32#] x2$res in
      let x2$res$4 = add# [Float32#] x2$res$3 x17 in
      let x19 = vproj$8$5# [Float32#] x2$res in
      let x2$res$5 = add# [Float32#] x2$res$4 x19 in
      let x21 = vproj$8$6# [Float32#] x2$res in
      let x2$res$6 = add# [Float32#] x2$res$5 x21 in
      let x23 = vproj$8$7# [Float32#] x2$res in
      let x2$res$7 = add# [Float32#] x2$res$6 x23 in
      let _ = write# [Float32#] x2 x2$res$7 in
      ()
}


-- Fuse sum and product.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Ref# Float32# -> Ref# Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 x3 : Ref# Float32#).\(x4 : Series# (Down8# t0) Float32#).
      let x5 = vrep$8# [Float32#] 0.0f32# in
      let x2$vec
            = new# [Vec8# Float32#] x5 in
      let x7 = vrep$8# [Float32#] 1.0f32# in
      let x3$vec
            = new# [Vec8# Float32#] x7 in
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x2$val
                         = read# [Vec8# Float32#] x2$vec in
                   let x8 = vadd$8# [Float32#] x2$val x4$elem in
                   let _
                         = write# [Vec8# Float32#] x2$vec x8 in
                   let x3$val
                         = read# [Vec8# Float32#] x3$vec in
                   let x9 = vmul$8# [Float32#] x3$val x4$elem in
                   let _
                         = write# [Vec8# Float32#] x3$vec x9 in
                   ()) in
      let x2$res
            = read# [Vec8# Float32#] x2$vec in
      let x2$init = read# [Float32#] x2 in
      let x12 = vproj$8$0# [Float32#] x2$res in
      let x2$res$0 = add# [Float32#] x2$init x12 in
      let x14 = vproj$8$1# [Float32#] x2$res in
      let x2$res$1 = add# [Float32#] x2$res$0 x14 in
      let x16 = vproj$8$2# [Float32#] x2$res in
      let x2$res$2 = add# [Float32#] x2$res$1 x16 in
      let x18 = vproj$8$3# [Float32#] x2$res in
      let x2$res$3 = add# [Float32#] x2$res$2 x18 in
      let x20 = vproj$8$4# [Float32#] x2$res in
      let x2$res$4 = add# [Float32#] x2$res$3 x20 in
      let x22 = vproj$8$5# [Float32#] x2$res in
      let x2$res$5 = add# [Float32#] x2$res$4 x22 in
      let x24 = vproj$8$6# [Float32#] x2$res in
      let x2$res$6 = add# [Float32#] x2$res$5 x24 in
      let x26 = vproj$8$7# [Float32#] x2$res in
      let x2$res$7 = add# [Float32#] x2$res$6 x26 in
      let _ = write# [Float32#] x2 x2$res$7 in
      let x3$res
            = read# [Vec8# Float32#] x3$vec in
      let x3$init = read# [Float32#] x3 in
      let x28 = vproj$8$0# [Float32#] x3$res in
      let x3$res$0 = mul# [Float32#] x3$init x28 in
      let x30 = vproj$8$1# [Float32#] x3$res in
      let x3$res$1 = mul# [Float32#] x3$res$0 x30 in
      let x32 = vproj$8$2# [Float32#] x3$res in
      let x3$res$2 = mul# [Float32#] x3$res$1 x32 in
      let x34 = vproj$8$3# [Float32#] x3$res in
      let x3$res$3 = mul# [Float32#] x3$res$2 x34 in
      let x36 = vproj$8$4# [Float32#] x3$res in
      let x3$res$4 = mul# [Float32#] x3$res$3 x36 in
      let x38 = vproj$8$5# [Float32#] x3$res in
      let x3$res$5 = mul# [Float32#] x3$res$4 x38 in
      let x40 = vproj$8$6# [Float32#] x3$res in
      let x3$res$6 = mul# [Float32#] x3$res$5 x40 in
      let x42 = vproj$8$7# [Float32#] x3$res in
      let x3$res$7 = mul# [Float32#] x3$res$6 x42 in
      let _ = write# [Float32#] x3 x3$res$7 in
      ()
}


-- Fuse sum and dot product.
module Test with
letrec {
  test : [t0 : Rate].RateNat# t0 -> Ref# Float32# -> Ref# Float32# -> Series# (Down8# t0) Float32# -> Series# (Down8# t0) Float32# -> Unit
    = /\(t0 : Rate).
       \(x1 : RateNat# t0).\(x2 x3 : Ref# Float32#).\(x4 x5 : Series# (Down8# t0) Float32#).
      let x6 = vrep$8# [Float32#] 0.0f32# in
      let x2$vec
            = new# [Vec8# Float32#] x6 in
      let x7 = vrep$8# [Float32#] 0.0f32# in
      let x3$vec
            = new# [Vec8# Float32#] x7 in
      let _
            = loop# [Down8# t0]
                  (\(x0 : Nat#).
                   let x4$elem = next$8# [Float32#] [t0] x4 x0 in
                   let x5$elem = next$8# [Float32#] [t0] x5 x0 in
                   let x9$elem = vmul$8# [Float32#] x4$elem x5$elem in
                   let x2$val
                         = read# [Vec8# Float32#] x2$vec in
                   let x8 = vadd$8# [Float32#] x2$val x9$elem in
                   let _
                         = write# [Vec8# Float32#] x2$vec x8 in
                   let x3$val
                         = read# [Vec8# Float32#] x3$vec in
                   let x9 = vadd$8# [Float32#] x3$val x4$elem in
                   let _
                         = write# [Vec8# Float32#] x3$vec x9 in
                   ()) in
      let x2$res
            = read# [Vec8# Float32#] x2$vec in
      let x2$init = read# [Float32#] x2 in
      let x11 = vproj$8$0# [Float32#] x2$res in
      let x2$res$0 = add# [Float32#] x2$init x11 in
      let x14 = vproj$8$1# [Float32#] x2$res in
      let x2$res$1 = add# [Float32#] x2$res$0 x14 in
      let x16 = vproj$8$2# [Float32#] x2$res in
      let x2$res$2 = add# [Float32#] x2$res$1 x16 in
      let x19 = vproj$8$3# [Float32#] x2$res in
      let x2$res$3 = add# [Float32#] x2$res$2 x19 in
      let x21 = vproj$8$4# [Float32#] x2$res in
      let x2$res$4 = add# [Float32#] x2$res$3 x21 in
      let x23 = vproj$8$5# [Float32#] x2$res in
      let x2$res$5 = add# [Float32#] x2$res$4 x23 in
      let x25 = vproj$8$6# [Float32#] x2$res in
      let x2$res$6 = add# [Float32#] x2$res$5 x25 in
      let x27 = vproj$8$7# [Float32#] x2$res in
      let x2$res$7 = add# [Float32#] x2$res$6 x27 in
      let _ = write# [Float32#] x2 x2$res$7 in
      let x3$res
            = read# [Vec8# Float32#] x3$vec in
      let x3$init = read# [Float32#] x3 in
      let x29 = vproj$8$0# [Float32#] x3$res in
      let x3$res$0 = add# [Float32#] x3$init x29 in
      let x31 = vproj$8$1# [Float32#] x3$res in
      let x3$res$1 = add# [Float32#] x3$res$0 x31 in
      let x33 = vproj$8$2# [Float32#] x3$res in
      let x3$res$2 = add# [Float32#] x3$res$1 x33 in
      let x35 = vproj$8$3# [Float32#] x3$res in
      let x3$res$3 = add# [Float32#] x3$res$2 x35 in
      let x37 = vproj$8$4# [Float32#] x3$res in
      let x3$res$4 = add# [Float32#] x3$res$3 x37 in
      let x39 = vproj$8$5# [Float32#] x3$res in
      let x3$res$5 = add# [Float32#] x3$res$4 x39 in
      let x41 = vproj$8$6# [Float32#] x3$res in
      let x3$res$6 = add# [Float32#] x3$res$5 x41 in
      let x43 = vproj$8$7# [Float32#] x3$res in
      let x3$res$7 = add# [Float32#] x3$res$6 x43 in
      let _ = write# [Float32#] x3 x3$res$7 in
      ()
}

