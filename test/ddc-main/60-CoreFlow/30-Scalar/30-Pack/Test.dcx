:set SuppressLetTypes


-- Pack with an existing series of flags.
:flow-lower..
module Test with letrec
packMe  [k0 : Rate] [a : Data]
        (s  : Series# k0 a) 
        (v  : Vector# a)
        (flags : Series# k0 Bool#)
        : Process#

 =      smkSel1# [k0] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let s2       = spack# [k0] [k1] [a] sel s
          in  sfill# [k1] [a] v s2)
;;


-- Filter, producing our own flags.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#) 
        (v  : Vector# a)
        (s  : Series# k0 a)
        : Process#
 = do   
        flags   = smap# [k0] [a] [Bool#] f s

        smkSel1# [k0] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let  s2      =  spack# [k0] [k1] [a] sel s
          in   sfill# [k1] [a] v s2)
;;


-- Filter, and also materialize the input in a new selector context.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#) 
        (v1 v2 : Vector# a)
        (s : Series# k0 a)
        : Process#
 = do   
        flags   = smap# [k0] [a] [Bool#] f s

        pjoin#  (sfill# [k0] [a] v1 s)
                (smkSel1# [k0] flags
                 (/\(k1 : Rate). \(sel : Sel1# k0 k1).
                  let  s2  = spack# [k0] [k1] [a] sel s
                  in   sfill# [k1] [a] v1 s2))
;;


-- Nested filter.
-- Ensure we can handle nested selector contexts.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#)  (g : a -> Bool#)
        (v  : Vector# a)
        (s0 : Series# k0 a)
        : Process#
 = do   
        flags1  = smap# [k0] [a] [Bool#] (\(x : a). f x) s0

        smkSel1# [k0] flags1
         (/\(k1 : Rate). \(sel1 : Sel1# k0 k1).
          let  s1      = spack# [k0] [k1] [a] sel1 s0 in
          let  flags2  = smap#  [k1] [a]  [Bool#] g s1 
          in   smkSel1# [k1] flags2
                 (/\(k2 : Rate). \(sel2 : Sel1# k1 k2).
                  let   s2 = spack# [k1] [k2] [a] sel2 s1
                  in    sfill# [k2] [a] v s2 ))
;;


-- Sequential filter.
-- Ensure we can handle two selector contexts on the same input.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#)  (g : a -> Bool#)
        (v1 v2 : Vector# a) 
        (s0 : Series# k0 a)
        : Process#
 = do   
        flags1  = smap# [k0] [a] [Bool#] f s0
        flags2  = smap# [k0] [a] [Bool#] f s0

        pjoin#  (smkSel# [k0] flags1
                 (/\(k1 : Rate). \(sel1 : Sel1# k0 k1).
                  let  s1      = spack# [k0] [k1] [a] sel1 s0 
                  in   sfill# [k1] [a] v1 s1))

                (smkSel# [k0] flags2
                 (/\(k2 : Rate). \(sel2 : Sel1# k0 k2).
                  let   s2      = spack# [k0] [k2] [a] sel2 s0
                  in    sfill# [k2] [a] v2 s2))
;;

