ok
ok


-- Single reduction of input series.
module Test with
letrec {
  fold : [t0 : Rate].Ref# Int# -> Series# t0 Int# -> Unit
    = /\(t0 : Rate).
       \(x1 : Ref# Int#).\(x2 : Series# t0 Int#).
      let x1$init = read# [Int#] x1 in
      let x1$acc = new# [Int#] x1$init in
      let _
            = loop# [t0]
                  (\(x0 : Nat#).
                   let x2$elem = next# [Int#] [t0] x2 x0 in
                   let x1$val = read# [Int#] x1$acc in
                   let x3 = add# [Int#] x1$val x2$elem in
                   let _ = write# [Int#] x1$acc x3 in
                   ()) in
      let x1$res = read# [Int#] x1$acc in
      let _ = write# [Int#] x1 x1$res in
      ()
}


-- Two reductions over the same input series.
module Test with
letrec {
  ffold : [t0 : Rate].Ref# Int# -> Ref# Int# -> Series# t0 Int# -> Unit
    = /\(t0 : Rate).
       \(x1 x2 : Ref# Int#).\(x3 : Series# t0 Int#).
      let x1$init = read# [Int#] x1 in
      let x1$acc = new# [Int#] x1$init in
      let x2$init = read# [Int#] x2 in
      let x2$acc = new# [Int#] x2$init in
      let _
            = loop# [t0]
                  (\(x0 : Nat#).
                   let x3$elem = next# [Int#] [t0] x3 x0 in
                   let x1$val = read# [Int#] x1$acc in
                   let x4 = add# [Int#] x1$val x3$elem in
                   let _ = write# [Int#] x1$acc x4 in
                   let x2$val = read# [Int#] x2$acc in
                   let x5 = mul# [Int#] x2$val x3$elem in
                   let _ = write# [Int#] x2$acc x5 in
                   ()) in
      let x1$res = read# [Int#] x1$acc in
      let _ = write# [Int#] x1 x1$res in
      let x2$res = read# [Int#] x2$acc in
      let _ = write# [Int#] x2 x2$res in
      ()
}


-- Three reductions over the same input series
module Test with
letrec {
  fffold : [t0 : Rate].Ref# Int# -> Ref# Int# -> Ref# Int# -> Series# t0 Int# -> Unit
    = /\(t0 : Rate).
       \(x1 x2 x3 : Ref# Int#).\(x4 : Series# t0 Int#).
      let x1$init = read# [Int#] x1 in
      let x1$acc = new# [Int#] x1$init in
      let x2$init = read# [Int#] x2 in
      let x2$acc = new# [Int#] x2$init in
      let x3$init = read# [Int#] x3 in
      let x3$acc = new# [Int#] x3$init in
      let _
            = loop# [t0]
                  (\(x0 : Nat#).
                   let x4$elem = next# [Int#] [t0] x4 x0 in
                   let x1$val = read# [Int#] x1$acc in
                   let x5 = add# [Int#] x1$val x4$elem in
                   let _ = write# [Int#] x1$acc x5 in
                   let x2$val = read# [Int#] x2$acc in
                   let x6 = mul# [Int#] x2$val x4$elem in
                   let _ = write# [Int#] x2$acc x6 in
                   let x3$val = read# [Int#] x3$acc in
                   let x7 = mul# [Int#] x3$val x4$elem in
                   let _ = write# [Int#] x3$acc x7 in
                   ()) in
      let x1$res = read# [Int#] x1$acc in
      let _ = write# [Int#] x1 x1$res in
      let x2$res = read# [Int#] x2$acc in
      let _ = write# [Int#] x2 x2$res in
      let x3$res = read# [Int#] x3$acc in
      let _ = write# [Int#] x3 x3$res in
      ()
}

