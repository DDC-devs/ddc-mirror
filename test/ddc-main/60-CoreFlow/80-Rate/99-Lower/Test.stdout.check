ok
ok


-- Simple fold over a vector
module Test with
letrec {
  x3$runproc$process : [u1$k : Rate].Ref# Int# -> RateNat# u1$k -> Series# u1$k Int# -> Unit
    = /\(u1$k : Rate).
       \(x3$ref : Ref# Int#).\(u1$k$r : RateNat# u1$k).\(u1$s : Series# u1$k Int#).
      let x3$ref$init : Int# = read# [Int#] x3$ref in
      let x3$ref$acc : Ref# Int# = new# [Int#] x3$ref$init in
      let _ : Unit
            = loop# [u1$k]
                  (\(x4 : Nat#).
                   let u1$s$elem : Int# = next# [Int#] [u1$k] u1$s x4 in
                   let x3$ref$val : Int# = read# [Int#] x3$ref$acc in
                   let x5 : Int# = add# [Int#] x3$ref$val u1$s$elem in
                   let _ : Unit = write# [Int#] x3$ref$acc x5 in
                   ()) in
      let x3$ref$res : Int# = read# [Int#] x3$ref$acc in
      let _ : Unit = write# [Int#] x3$ref x3$ref$res in
      ();
  
  test : Vector# Int# -> Int#
    = \(u1 : Vector# Int#).
      let x3$ref : Ref# Int# = new# [Int#] 0i# in
      let x3$runproc : Bool#
            = runKernel# [Int#] u1
                  (/\(t1 : Rate).
                    \(x2 : RateNat# t1).\(x3 : Series# t1 Int#). x3$runproc$process [t1] x3$ref x2 x3) in
      let x3 : Int# = read# [Int#] x3$ref in
      x3
}


-- Something like a normalise
module Test with
letrec {
  n$runproc$process : [x4$'$k : Rate].Ref# Int# -> RateNat# x4$'$k -> Series# x4$'$k Int# -> Unit
    = /\(x4$'$k : Rate).
       \(n$ref : Ref# Int#).\(x4$'$k$r : RateNat# x4$'$k).\(us$s : Series# x4$'$k Int#).
      let n$ref$init : Int# = read# [Int#] n$ref in
      let n$ref$acc : Ref# Int# = new# [Int#] n$ref$init in
      let _ : Unit
            = loop# [x4$'$k]
                  (\(x2 : Nat#).
                   let us$s$elem : Int# = next# [Int#] [x4$'$k] us$s x2 in
                   let n$ref$val : Int# = read# [Int#] n$ref$acc in
                   let x7 : Int# = add# [Int#] n$ref$val us$s$elem in
                   let _ : Unit = write# [Int#] n$ref$acc x7 in
                   ()) in
      let n$ref$res : Int# = read# [Int#] n$ref$acc in
      let _ : Unit = write# [Int#] n$ref n$ref$res in
      ();
  
  x4$runproc$process : [x4$'$k : Rate].Vector# Int# -> Int# -> RateNat# x4$'$k -> Series# x4$'$k Int# -> Unit
    = /\(x4$'$k : Rate).
       \(x4 : Vector# Int#).\(n : Int#).\(x4$'$k$r : RateNat# x4$'$k).\(us$s : Series# x4$'$k Int#).
      let _ : Unit
            = loop# [x4$'$k]
                  (\(x5 : Nat#).
                   let us$s$elem : Int# = next# [Int#] [x4$'$k] us$s x5 in
                   let x4$s$elem : Int# = div# [Int#] us$s$elem n in
                   let _ : Unit = vwrite# [Int#] x4 x5 x4$s$elem in
                   ()) in
      ();
  
  test : Vector# Int# -> Vector# Int#
    = \(us : Vector# Int#).
      let n$ref : Ref# Int# = new# [Int#] 0i# in
      let n$runproc : Bool#
            = runKernel# [Int#] us
                  (/\(t2 : Rate).
                    \(x3 : RateNat# t2).\(x4 : Series# t2 Int#). n$runproc$process [t2] n$ref x3 x4) in
      let n : Int# = read# [Int#] n$ref in
      let x6 : Nat# = vlength# [Int#] us in
      let x4 : Vector# Int# = vnew# [Int#] x6 in
      let x4$runproc : Bool#
            = runKernel# [Int#] us
                  (/\(t7 : Rate).
                    \(x8 : RateNat# t7).\(x9 : Series# t7 Int#). x4$runproc$process [t7] x4 n x8 x9) in
      x4
}


-- Filter and two folds, then use fold values in map over original and filtered. Three kernels:
-- 1- filter, fold, fold
-- 2- map original
-- 3- map filtered
module Test with
letrec {
  filt$runproc$process : [morig$'$k : Rate].Ref# Int# -> Vector# Int# -> RateNat# morig$'$k -> Series# morig$'$k Int# -> Unit
    = /\(morig$'$k : Rate).
       \(fold$ref : Ref# Int#).\(filt : Vector# Int#).\(morig$'$k$r : RateNat# morig$'$k).\(orig$s : Series# morig$'$k Int#).
      let filt$'$k$count : Ref# Nat# = new# [Nat#] 0# in
      let fold$ref$init : Int# = read# [Int#] fold$ref in
      let fold$ref$acc : Ref# Int# = new# [Int#] fold$ref$init in
      let _ : Unit
            = loop# [morig$'$k]
                  (\(x1 : Nat#).
                   let orig$s$elem : Int# = next# [Int#] [morig$'$k] orig$s x1 in
                   let filt$flags$elem : Bool# = gt# [Int#] 1i# orig$s$elem in
                   let _ : Unit
                         = guard# filt$'$k$count filt$flags$elem
                               (\(x4 : Nat#).
                                let _ : Unit = vwrite# [Int#] filt x4 orig$s$elem in
                                let fold$ref$val : Int# = read# [Int#] fold$ref$acc in
                                let x18 : Int# = add# [Int#] fold$ref$val orig$s$elem in
                                let _ : Unit = write# [Int#] fold$ref$acc x18 in
                                ()) in
                   ()) in
      let x7 : Nat# = read# [Nat#] filt$'$k$count in
      let _ : Unit = vtrunc# [Int#] x7 filt in
      let fold$ref$res : Int# = read# [Int#] fold$ref$acc in
      let _ : Unit = write# [Int#] fold$ref fold$ref$res in
      ();
  
  fold2$runproc$process : [morig$'$k : Rate].Vector# Int# -> Ref# Int# -> Int# -> RateNat# morig$'$k -> Series# morig$'$k Int# -> Unit
    = /\(morig$'$k : Rate).
       \(morig : Vector# Int#).\(fold2$ref : Ref# Int#).\(fold : Int#).\(morig$'$k$r : RateNat# morig$'$k).\(orig$s : Series# morig$'$k Int#).
      let fold2$ref$init : Int# = read# [Int#] fold2$ref in
      let fold2$ref$acc : Ref# Int# = new# [Int#] fold2$ref$init in
      let _ : Unit
            = loop# [morig$'$k]
                  (\(x13 : Nat#).
                   let orig$s$elem : Int# = next# [Int#] [morig$'$k] orig$s x13 in
                   let fold2$ref$val : Int# = read# [Int#] fold2$ref$acc in
                   let x20 : Int# = add# [Int#] fold2$ref$val orig$s$elem in
                   let _ : Unit = write# [Int#] fold2$ref$acc x20 in
                   let morig$s$elem : Int# = add# [Int#] fold orig$s$elem in
                   let _ : Unit = vwrite# [Int#] morig x13 morig$s$elem in
                   ()) in
      let fold2$ref$res : Int# = read# [Int#] fold2$ref$acc in
      let _ : Unit = write# [Int#] fold2$ref fold2$ref$res in
      ();
  
  mfilt$runproc$process : [filt$'$k : Rate].Vector# Int# -> Int# -> RateNat# filt$'$k -> Series# filt$'$k Int# -> Unit
    = /\(filt$'$k : Rate).
       \(mfilt : Vector# Int#).\(fold2 : Int#).\(filt$'$k$r : RateNat# filt$'$k).\(filt$s : Series# filt$'$k Int#).
      let _ : Unit
            = loop# [filt$'$k]
                  (\(x15 : Nat#).
                   let filt$s$elem : Int# = next# [Int#] [filt$'$k] filt$s x15 in
                   let mfilt$s$elem : Int# = add# [Int#] fold2 filt$s$elem in
                   let _ : Unit = vwrite# [Int#] mfilt x15 mfilt$s$elem in
                   ()) in
      ();
  
  test : Vector# Int# -> Tuple2# (Vector# Int#) (Vector# Int#)
    = \(orig : Vector# Int#).
      let x9 : Nat# = vlength# [Int#] orig in
      let filt : Vector# Int# = vnew# [Int#] x9 in
      let fold$ref : Ref# Int# = new# [Int#] 0i# in
      let filt$runproc : Bool#
            = runKernel# [Int#] orig
                  (/\(t10 : Rate).
                    \(x11 : RateNat# t10).\(x12 : Series# t10 Int#). filt$runproc$process [t10] fold$ref filt x11 x12) in
      let fold : Int# = read# [Int#] fold$ref in
      let fold2$ref : Ref# Int# = new# [Int#] 0i# in
      let x14 : Nat# = vlength# [Int#] orig in
      let morig : Vector# Int# = vnew# [Int#] x14 in
      let fold2$runproc : Bool#
            = runKernel# [Int#] orig
                  (/\(t15 : Rate).
                    \(x16 : RateNat# t15).\(x17 : Series# t15 Int#). fold2$runproc$process [t15] morig fold2$ref fold x16 x17) in
      let fold2 : Int# = read# [Int#] fold2$ref in
      let x19 : Nat# = vlength# [Int#] filt in
      let mfilt : Vector# Int# = vnew# [Int#] x19 in
      let mfilt$runproc : Bool#
            = runKernel# [Int#] filt
                  (/\(t20 : Rate).
                    \(x21 : RateNat# t20).\(x22 : Series# t20 Int#). mfilt$runproc$process [t20] mfilt fold2 x21 x22) in
      let x12 : Tuple2# (Vector# Int#) (Vector# Int#)
            = T2# [Vector# Int#] [Vector# Int#] morig mfilt in
      x12
}

