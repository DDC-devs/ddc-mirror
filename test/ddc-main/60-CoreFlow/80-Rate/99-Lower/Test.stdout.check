ok
ok


-- Simple fold over a vector
module Test with
letrec {
  x3$runproc$process : [u1$k : Rate].Ref# Int# -> RateNat# u1$k -> Series# u1$k Int# -> Unit
    = /\(u1$k : Rate).
       \(x3$ref : Ref# Int#).\(_ : RateNat# u1$k).\(u1$s : Series# u1$k Int#).
      let x3$ref$init : Int# = read# [Int#] x3$ref in
      let x3$ref$acc : Ref# Int# = new# [Int#] x3$ref$init in
      let _ : Unit
            = loop# [u1$k]
                  (\(x2 : Nat#).
                   let u1$s$elem : Int# = next# [Int#] [u1$k] u1$s x2 in
                   let x3$ref$val : Int# = read# [Int#] x3$ref$acc in
                   let x4 = add# [Int#] x3$ref$val u1$s$elem in
                   let _ : Unit = write# [Int#] x3$ref$acc x4 in
                   ()) in
      let x3$ref$res : Int# = read# [Int#] x3$ref$acc in
      let _ : Unit = write# [Int#] x3$ref x3$ref$res in
      ();
  
  test : Vector# Int# -> Int#
    = \(u1 : Vector# Int#).
      let x3$ref : Ref# Int# = new# [Int#] 0i# in
      let x5 = x3$runproc$process x3$ref in
      let x3$runproc : Bool# = runKernel# [Int#] u1 x5 in
      let x3 : Int# = read# [Int#] x3$ref in
      x3
}


-- Something like a normalise
module Test with
letrec {
  x3$runproc$process : [x5$'$k : Rate].Ref# Int# -> RateNat# x5$'$k -> Series# x5$'$k Int# -> Unit
    = /\(x5$'$k : Rate).
       \(x3$ref : Ref# Int#).\(_ : RateNat# x5$'$k).\(us$s : Series# x5$'$k Int#).
      let x3$ref$init : Int# = read# [Int#] x3$ref in
      let x3$ref$acc : Ref# Int# = new# [Int#] x3$ref$init in
      let _ : Unit
            = loop# [x5$'$k]
                  (\(x2 : Nat#).
                   let us$s$elem : Int# = next# [Int#] [x5$'$k] us$s x2 in
                   let x3$ref$val : Int# = read# [Int#] x3$ref$acc in
                   let x6 = add# [Int#] x3$ref$val us$s$elem in
                   let _ : Unit = write# [Int#] x3$ref$acc x6 in
                   ()) in
      let x3$ref$res : Int# = read# [Int#] x3$ref$acc in
      let _ : Unit = write# [Int#] x3$ref x3$ref$res in
      ();
  
  x5$runproc$process : [x5$'$k : Rate].Vector# Int# -> Int# -> RateNat# x5$'$k -> Series# x5$'$k Int# -> Unit
    = /\(x5$'$k : Rate).
       \(x5 : Vector# Int#).\(x3 : Int#).\(_ : RateNat# x5$'$k).\(us$s : Series# x5$'$k Int#).
      let _ : Unit
            = loop# [x5$'$k]
                  (\(x4 : Nat#).
                   let us$s$elem : Int# = next# [Int#] [x5$'$k] us$s x4 in
                   let x5$s$elem : Int# = div# [Int#] us$s$elem x3 in
                   let _ : Unit = vwrite# [Int#] x5 x4 x5$s$elem in
                   ()) in
      ();
  
  test : Vector# Int# -> Vector# Int#
    = \(us : Vector# Int#).
      let x3$ref : Ref# Int# = new# [Int#] 0i# in
      let x7 = x3$runproc$process x3$ref in
      let x3$runproc : Bool# = runKernel# [Int#] us x7 in
      let x3 : Int# = read# [Int#] x3$ref in
      let x8 = vlength# [Int#] us in
      let x5 : Vector# Int# = vnew# [Int#] x8 in
      let x9 = x5$runproc$process x5 x3 in
      let x5$runproc : Bool# = runKernel# [Int#] us x9 in
      x5
}


-- Filter and two folds, then use fold values in map over original and filtered. Three kernels:
-- 1- filter, fold, fold
-- 2- map original
-- 3- map filtered
Error transforming core program.
  Error slurping series process.
    Bad series process definition.
    
    smkSel# [x13$'$k] x2$flags
        (/\(x2$'$k : Rate).
          \(x2$sel : Sel1# x13$'$k x2$'$k).
         let x2$s : Series# x2$'$k Int# = spack# [x13$'$k] [x2$'$k] [Int#] x2$sel orig$s in
         let x6$proc : Process#
               = sreduce# [x2$'$k] [Int#] x6$ref
                     (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# x2$s in
         let x16$s : Series# x2$'$k Int#
               = smap# [x2$'$k] [Int#] [Int#]
                     (\(x14 : Int#). add# [Int#] x10 x14) x2$s in
         let x16$proc : Process# = sfill# [x2$'$k] [Int#] x16 x16$s in
         pjoin# x6$proc x16$proc)


