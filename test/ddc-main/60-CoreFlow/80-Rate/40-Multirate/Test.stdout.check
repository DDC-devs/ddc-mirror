ok


-- Use both separately - no reason they should have same rate. Thus, two processes.
module Test with
let x5$runproc$process : Ref# Int# -> Vector# Int# -> [x5$'$k : Rate].RateNat# x5$'$k -> Series# x5$'$k Int# -> Process#
      = \(x9$ref : Ref# Int#).\(x5 : Vector# Int#).
        /\(x5$'$k : Rate).
         \(_ : RateNat# x5$'$k).\(vs$s : Series# x5$'$k Int#).
        let x5$s : Series# x5$'$k Int#
              = smap# [x5$'$k] [Int#] [Int#]
                    (\(x3 : Int#). add# [Int#] 2i# x3) vs$s in
        let x5$proc : Process# = sfill# [x5$'$k] [Int#] x5 x5$s in
        let x9$proc : Process#
              = sreduce# [x5$'$k] [Int#] x9$ref
                    (\(x6 x7 : Int#). add# [Int#] x6 x7) 0i# x5$s in
        pjoin# x5$proc x9$proc
let x2$runproc$process : Vector# Int# -> [x2$'$k : Rate].RateNat# x2$'$k -> Series# x2$'$k Int# -> Process#
      = \(x2 : Vector# Int#).
        /\(x2$'$k : Rate).
         \(_ : RateNat# x2$'$k).\(us$s : Series# x2$'$k Int#).
        let x2$s : Series# x2$'$k Int#
              = smap# [x2$'$k] [Int#] [Int#]
                    (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
        let x2$proc : Process# = sfill# [x2$'$k] [Int#] x2 x2$s in
        x2$proc
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple3# (Vector# Int#) (Vector# Int#) Int#
    = \(us vs : Vector# Int#).
      let x5 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let x9$ref : Ref# Int# = new# [Int#] 0i# in
      let x5$runproc : Bool#
            = runProcess# [Int#] vs (x5$runproc$process x9$ref x5) in
      let x9 : Int# = read# [Int#] x9$ref in
      let x2 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let x2$runproc : Bool#
            = runProcess# [Int#] us (x2$runproc$process x2) in
      T3# [Vector# Int#] [Vector# Int#] [Int#] x2 x5 x9
}


-- Try the criss cross one
module Test with
let x9$runproc$process : Ref# Int# -> [x19$'$k : Rate].RateNat# x19$'$k -> Series# x19$'$k Int# -> Process#
      = \(x13$ref : Ref# Int#).
        /\(x19$'$k : Rate).
         \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
        let x9$s : Series# x19$'$k Int#
              = smap# [x19$'$k] [Int#] [Int#]
                    (\(x7 : Int#). add# [Int#] 2i# x7) vs$s in
        let x13$proc : Process#
              = sreduce# [x19$'$k] [Int#] x13$ref
                    (\(x10 x11 : Int#). add# [Int#] x10 x11) 0i# x9$s in
        x13$proc
let x2$runproc$process : Vector# Int# -> Ref# Int# -> Int# -> [x16$'$k : Rate].RateNat# x16$'$k -> Series# x16$'$k Int# -> Process#
      = \(x16 : Vector# Int#).\(x6$ref : Ref# Int#).\(x13 : Int#).
        /\(x16$'$k : Rate).
         \(_ : RateNat# x16$'$k).\(us$s : Series# x16$'$k Int#).
        let x2$s : Series# x16$'$k Int#
              = smap# [x16$'$k] [Int#] [Int#]
                    (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
        let x6$proc : Process#
              = sreduce# [x16$'$k] [Int#] x6$ref
                    (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# x2$s in
        let x16$s : Series# x16$'$k Int#
              = smap# [x16$'$k] [Int#] [Int#]
                    (\(x14 : Int#). add# [Int#] x13 x14) us$s in
        let x16$proc : Process# = sfill# [x16$'$k] [Int#] x16 x16$s in
        pjoin# x6$proc x16$proc
let x19$runproc$process : Vector# Int# -> Int# -> [x19$'$k : Rate].RateNat# x19$'$k -> Series# x19$'$k Int# -> Process#
      = \(x19 : Vector# Int#).\(x6 : Int#).
        /\(x19$'$k : Rate).
         \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
        let x19$s : Series# x19$'$k Int#
              = smap# [x19$'$k] [Int#] [Int#]
                    (\(x17 : Int#). add# [Int#] x6 x17) vs$s in
        let x19$proc : Process# = sfill# [x19$'$k] [Int#] x19 x19$s in
        x19$proc
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple2# (Vector# Int#) (Vector# Int#)
    = \(us vs : Vector# Int#).
      let x13$ref : Ref# Int# = new# [Int#] 0i# in
      let x9$runproc : Bool#
            = runProcess# [Int#] vs (x9$runproc$process x13$ref) in
      let x13 : Int# = read# [Int#] x13$ref in
      let x6$ref : Ref# Int# = new# [Int#] 0i# in
      let x16 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let x2$runproc : Bool#
            = runProcess# [Int#] us (x2$runproc$process x16 x6$ref x13) in
      let x6 : Int# = read# [Int#] x6$ref in
      let x19 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let x19$runproc : Bool#
            = runProcess# [Int#] vs (x19$runproc$process x19 x6) in
      T2# [Vector# Int#] [Vector# Int#] x16 x19
}


-- Criss cross, but manifest two more vectors
module Test with
let x9$runproc$process : Ref# Int# -> Vector# Int# -> [x19$'$k : Rate].RateNat# x19$'$k -> Series# x19$'$k Int# -> Process#
      = \(x13$ref : Ref# Int#).\(x9 : Vector# Int#).
        /\(x19$'$k : Rate).
         \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
        let x9$s : Series# x19$'$k Int#
              = smap# [x19$'$k] [Int#] [Int#]
                    (\(x7 : Int#). add# [Int#] 2i# x7) vs$s in
        let x9$proc : Process# = sfill# [x19$'$k] [Int#] x9 x9$s in
        let x13$proc : Process#
              = sreduce# [x19$'$k] [Int#] x13$ref
                    (\(x10 x11 : Int#). add# [Int#] x10 x11) 0i# x9$s in
        pjoin# x9$proc x13$proc
let x2$runproc$process : Vector# Int# -> Ref# Int# -> Int# -> [x16$'$k : Rate].RateNat# x16$'$k -> Series# x16$'$k Int# -> Process#
      = \(x16 : Vector# Int#).\(x6$ref : Ref# Int#).\(x13 : Int#).
        /\(x16$'$k : Rate).
         \(_ : RateNat# x16$'$k).\(us$s : Series# x16$'$k Int#).
        let x2$s : Series# x16$'$k Int#
              = smap# [x16$'$k] [Int#] [Int#]
                    (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
        let x6$proc : Process#
              = sreduce# [x16$'$k] [Int#] x6$ref
                    (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# x2$s in
        let x16$s : Series# x16$'$k Int#
              = smap# [x16$'$k] [Int#] [Int#]
                    (\(x14 : Int#). add# [Int#] x13 x14) x2$s in
        let x16$proc : Process# = sfill# [x16$'$k] [Int#] x16 x16$s in
        pjoin# x6$proc x16$proc
let x19$runproc$process : Vector# Int# -> Int# -> [x19$'$k : Rate].RateNat# x19$'$k -> Series# x19$'$k Int# -> Process#
      = \(x19 : Vector# Int#).\(x6 : Int#).
        /\(x19$'$k : Rate).
         \(_ : RateNat# x19$'$k).\(x9$s : Series# x19$'$k Int#).
        let x19$s : Series# x19$'$k Int#
              = smap# [x19$'$k] [Int#] [Int#]
                    (\(x17 : Int#). add# [Int#] x6 x17) x9$s in
        let x19$proc : Process# = sfill# [x19$'$k] [Int#] x19 x19$s in
        x19$proc
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple2# (Vector# Int#) (Vector# Int#)
    = \(us vs : Vector# Int#).
      let x9 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let x13$ref : Ref# Int# = new# [Int#] 0i# in
      let x9$runproc : Bool#
            = runProcess# [Int#] vs (x9$runproc$process x13$ref x9) in
      let x13 : Int# = read# [Int#] x13$ref in
      let x6$ref : Ref# Int# = new# [Int#] 0i# in
      let x16 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let x2$runproc : Bool#
            = runProcess# [Int#] us (x2$runproc$process x16 x6$ref x13) in
      let x6 : Int# = read# [Int#] x6$ref in
      let x19 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] x9) in
      let x19$runproc : Bool#
            = runProcess# [Int#] x9 (x19$runproc$process x19 x6) in
      T2# [Vector# Int#] [Vector# Int#] x16 x19
}
