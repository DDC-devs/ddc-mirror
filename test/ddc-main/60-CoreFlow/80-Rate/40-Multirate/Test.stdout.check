ok


-- Use both separately - no reason they should have same rate. Thus, two processes.
module Test with
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple3# (Vector# Int#) (Vector# Int#) Int#
    = \(us vs : Vector# Int#).
      let x5 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let x9$ref : Ref# Int# = new# [Int#] 0i# in
      let _ : Bool#
            = runProcess# [Int#] vs
                  (/\(x5$'$k : Rate).
                    \(_ : RateNat# x5$'$k).\(vs$s : Series# x5$'$k Int#).
                   let x5$s : Series# x5$'$k Int#
                         = smap# [x5$'$k] [Int#] [Int#]
                               (\(x3 : Int#). add# [Int#] 2i# x3) vs$s in
                   let x9$proc : Process#
                         = sreduce# [x5$'$k] [Int#] x9$ref
                               (\(x6 x7 : Int#). add# [Int#] x6 x7) 0i# x5$s in
                   pjoin# (sfill# [x5$'$k] [Int#] x5 x5$s) x9$proc) in
      let x9 : Int# = read# [Int#] x9$ref in
      let x2 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let _ : Bool#
            = runProcess# [Int#] us
                  (/\(x2$'$k : Rate).
                    \(_ : RateNat# x2$'$k).\(us$s : Series# x2$'$k Int#).
                   let x2$s : Series# x2$'$k Int#
                         = smap# [x2$'$k] [Int#] [Int#]
                               (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
                   sfill# [x2$'$k] [Int#] x2 x2$s) in
      T3# [Vector# Int#] [Vector# Int#] [Int#] x2 x5 x9
}


-- Try the criss cross one
module Test with
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple2# (Vector# Int#) (Vector# Int#)
    = \(us vs : Vector# Int#).
      let x13$ref : Ref# Int# = new# [Int#] 0i# in
      let _ : Bool#
            = runProcess# [Int#] vs
                  (/\(x19$'$k : Rate).
                    \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
                   let x9$s : Series# x19$'$k Int#
                         = smap# [x19$'$k] [Int#] [Int#]
                               (\(x7 : Int#). add# [Int#] 2i# x7) vs$s in
                   let x13$proc : Process#
                         = sreduce# [x19$'$k] [Int#] x13$ref
                               (\(x10 x11 : Int#). add# [Int#] x10 x11) 0i# x9$s in
                   x13$proc) in
      let x13 : Int# = read# [Int#] x13$ref in
      let x6$ref : Ref# Int# = new# [Int#] 0i# in
      let x16 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let _ : Bool#
            = runProcess# [Int#] us
                  (/\(x16$'$k : Rate).
                    \(_ : RateNat# x16$'$k).\(us$s : Series# x16$'$k Int#).
                   let x2$s : Series# x16$'$k Int#
                         = smap# [x16$'$k] [Int#] [Int#]
                               (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
                   let x6$proc : Process#
                         = sreduce# [x16$'$k] [Int#] x6$ref
                               (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# x2$s in
                   let x16$s : Series# x16$'$k Int#
                         = smap# [x16$'$k] [Int#] [Int#]
                               (\(x14 : Int#). add# [Int#] x13 x14) us$s in
                   pjoin# x6$proc (sfill# [x16$'$k] [Int#] x16 x16$s)) in
      let x6 : Int# = read# [Int#] x6$ref in
      let x19 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let _ : Bool#
            = runProcess# [Int#] vs
                  (/\(x19$'$k : Rate).
                    \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
                   let x19$s : Series# x19$'$k Int#
                         = smap# [x19$'$k] [Int#] [Int#]
                               (\(x17 : Int#). add# [Int#] x6 x17) vs$s in
                   sfill# [x19$'$k] [Int#] x19 x19$s) in
      T2# [Vector# Int#] [Vector# Int#] x16 x19
}


-- Criss cross, but manifest two more vectors
module Test with
letrec {
  test : Vector# Int# -> Vector# Int# -> Tuple2# (Vector# Int#) (Vector# Int#)
    = \(us vs : Vector# Int#).
      let x9 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] vs) in
      let x13$ref : Ref# Int# = new# [Int#] 0i# in
      let _ : Bool#
            = runProcess# [Int#] vs
                  (/\(x19$'$k : Rate).
                    \(_ : RateNat# x19$'$k).\(vs$s : Series# x19$'$k Int#).
                   let x9$s : Series# x19$'$k Int#
                         = smap# [x19$'$k] [Int#] [Int#]
                               (\(x7 : Int#). add# [Int#] 2i# x7) vs$s in
                   let x13$proc : Process#
                         = sreduce# [x19$'$k] [Int#] x13$ref
                               (\(x10 x11 : Int#). add# [Int#] x10 x11) 0i# x9$s in
                   pjoin# (sfill# [x19$'$k] [Int#] x9 x9$s) x13$proc) in
      let x13 : Int# = read# [Int#] x13$ref in
      let x6$ref : Ref# Int# = new# [Int#] 0i# in
      let x16 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let _ : Bool#
            = runProcess# [Int#] us
                  (/\(x16$'$k : Rate).
                    \(_ : RateNat# x16$'$k).\(us$s : Series# x16$'$k Int#).
                   let x2$s : Series# x16$'$k Int#
                         = smap# [x16$'$k] [Int#] [Int#]
                               (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
                   let x6$proc : Process#
                         = sreduce# [x16$'$k] [Int#] x6$ref
                               (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# x2$s in
                   let x16$s : Series# x16$'$k Int#
                         = smap# [x16$'$k] [Int#] [Int#]
                               (\(x14 : Int#). add# [Int#] x13 x14) x2$s in
                   pjoin# x6$proc (sfill# [x16$'$k] [Int#] x16 x16$s)) in
      let x6 : Int# = read# [Int#] x6$ref in
      let x19 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] x9) in
      let _ : Bool#
            = runProcess# [Int#] x9
                  (/\(x19$'$k : Rate).
                    \(_ : RateNat# x19$'$k).\(x9$s : Series# x19$'$k Int#).
                   let x19$s : Series# x19$'$k Int#
                         = smap# [x19$'$k] [Int#] [Int#]
                               (\(x17 : Int#). add# [Int#] x6 x17) x9$s in
                   sfill# [x19$'$k] [Int#] x19 x19$s) in
      T2# [Vector# Int#] [Vector# Int#] x16 x19
}
