ok


-- Two possible schedules, but should be one with only one manifest array (ys)
module Test with
let x6$runproc$process : Ref# Int# -> [x9$'$k : Rate].RateNat# x9$'$k -> Series# x9$'$k Int# -> Process#
      = \(x6$ref : Ref# Int#).
        /\(x9$'$k : Rate).
         \(_ : RateNat# x9$'$k).\(us$s : Series# x9$'$k Int#).
        let x6$proc : Process#
              = sreduce# [x9$'$k] [Int#] x6$ref
                    (\(x3 x4 : Int#). add# [Int#] x3 x4) 0i# us$s in
        x6$proc
let x2$runproc$process : Vector# Int# -> Int# -> [x9$'$k : Rate].RateNat# x9$'$k -> Series# x9$'$k Int# -> Process#
      = \(x9 : Vector# Int#).\(x6 : Int#).
        /\(x9$'$k : Rate).
         \(_ : RateNat# x9$'$k).\(us$s : Series# x9$'$k Int#).
        let x2$s : Series# x9$'$k Int#
              = smap# [x9$'$k] [Int#] [Int#]
                    (\(x0 : Int#). add# [Int#] 1i# x0) us$s in
        let x9$s : Series# x9$'$k Int#
              = smap# [x9$'$k] [Int#] [Int#]
                    (\(x7 : Int#). add# [Int#] x6 x7) x2$s in
        let x9$proc : Process# = sfill# [x9$'$k] [Int#] x9 x9$s in
        x9$proc
letrec {
  test : Vector# Int# -> Vector# Int#
    = \(us : Vector# Int#).
      let x6$ref : Ref# Int# = new# [Int#] 0i# in
      let x6$runproc : Bool#
            = runProcess# [Int#] us (x6$runproc$process x6$ref) in
      let x6 : Int# = read# [Int#] x6$ref in
      let x9 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] us) in
      let x2$runproc : Bool#
            = runProcess# [Int#] us (x2$runproc$process x9 x6) in
      x9
}


