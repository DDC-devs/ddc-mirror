ok


-- Simple map2
module Test with
let x3$runproc$process : Vector# Int# -> [x3$'$k : Rate].RateNat# x3$'$k -> Series# x3$'$k Int# -> Series# x3$'$k Int# -> Process#
      = \(x3 : Vector# Int#).
        /\(x3$'$k : Rate).
         \(_ : RateNat# x3$'$k).\(u1$s u2$s : Series# x3$'$k Int#).
        let x3$s : Series# x3$'$k Int#
              = smap2# [x3$'$k] [Int#] [Int#] [Int#]
                    (\(x0 x1 : Int#). add# [Int#] x0 x1) u1$s u2$s in
        sfill# [x3$'$k] [Int#] x3 x3$s
letrec {
  test : Vector# Int# -> Vector# Int# -> Vector# Int#
    = \(u1 u2 : Vector# Int#).
      let x3 : Vector# Int#
            = vnew# [Int#] (vlength# [Int#] u1) in
      let x3$runproc : Bool#
            = runProcess2# [Int#] [Int#] u1 u2 (x3$runproc$process x3) in
      x3
}


-- Different vector types
module Test with
let x1$runproc$process : Vector# Float32# -> [x1$'$k : Rate].RateNat# x1$'$k -> Series# x1$'$k Int# -> Series# x1$'$k Float32# -> Process#
      = \(x1 : Vector# Float32#).
        /\(x1$'$k : Rate).
         \(_ : RateNat# x1$'$k).\(us$s : Series# x1$'$k Int#).\(vs$s : Series# x1$'$k Float32#).
        let x1$s : Series# x1$'$k Float32#
              = smap2# [x1$'$k] [Int#] [Float32#] [Float32#]
                    (\(u : Int#).\(v : Float32#). v) us$s vs$s in
        sfill# [x1$'$k] [Float32#] x1 x1$s
letrec {
  test : Vector# Int# -> Vector# Float32# -> Vector# Float32#
    = \(us : Vector# Int#).\(vs : Vector# Float32#).
      let x1 : Vector# Float32#
            = vnew# [Float32#] (vlength# [Int#] us) in
      let x1$runproc : Bool#
            = runProcess2# [Int#] [Float32#] us vs (x1$runproc$process x1) in
      x1
}


-- Some other ops thrown in. Two processes, 'fs' and 'zs' are manifest
module Test with
let x1$runproc$process : Ref# Float32# -> Vector# Float32# -> Float32# -> [x9$'$k : Rate].RateNat# x9$'$k -> Series# x9$'$k Int# -> Series# x9$'$k Float32# -> Process#
      = \(x7$ref : Ref# Float32#).\(x3 : Vector# Float32#).\(z : Float32#).
        /\(x9$'$k : Rate).
         \(_ : RateNat# x9$'$k).\(us$s : Series# x9$'$k Int#).\(vs$s : Series# x9$'$k Float32#).
        let x1$s : Series# x9$'$k Int#
              = smap# [x9$'$k] [Int#] [Int#]
                    (\(u : Int#). u) us$s in
        let x3$s : Series# x9$'$k Float32#
              = smap2# [x9$'$k] [Int#] [Float32#] [Float32#]
                    (\(u : Int#).\(v : Float32#). v) x1$s vs$s in
        let x7$proc : Process#
              = sreduce# [x9$'$k] [Float32#] x7$ref
                    (\(x4 x5 : Float32#). add# [Float32#] x4 x5) z x3$s in
        pjoin# (sfill# [x9$'$k] [Float32#] x3 x3$s) x7$proc
let x9$runproc$process : Vector# Float32# -> Float32# -> [x9$'$k : Rate].RateNat# x9$'$k -> Series# x9$'$k Int# -> Series# x9$'$k Float32# -> Series# x9$'$k Float32# -> Process#
      = \(x9 : Vector# Float32#).\(x7 : Float32#).
        /\(x9$'$k : Rate).
         \(_ : RateNat# x9$'$k).\(us$s : Series# x9$'$k Int#).\(vs$s x3$s : Series# x9$'$k Float32#).
        let x9$s : Series# x9$'$k Float32#
              = smap3# [x9$'$k] [Int#] [Float32#] [Float32#] [Float32#]
                    (\(u : Int#).\(v ff : Float32#). add# [Float32#] ff x7) us$s vs$s x3$s in
        sfill# [x9$'$k] [Float32#] x9 x9$s
letrec {
  test : Vector# Int# -> Vector# Float32# -> Float32# -> Vector# Float32#
    = \(us : Vector# Int#).\(vs : Vector# Float32#).\(z : Float32#).
      let x3 : Vector# Float32#
            = vnew# [Float32#] (vlength# [Int#] us) in
      let x7$ref : Ref# Float32# = new# [Float32#] z in
      let x1$runproc : Bool#
            = runProcess2# [Int#] [Float32#] us vs (x1$runproc$process x7$ref x3 z) in
      let x7 : Float32# = read# [Float32#] x7$ref in
      let x9 : Vector# Float32#
            = vnew# [Float32#] (vlength# [Int#] us) in
      let x9$runproc : Bool#
            = runProcess3# [Int#] [Float32#] [Float32#] us vs x3 (x9$runproc$process x9 x7) in
      x9
}

