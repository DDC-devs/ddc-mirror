ok

-- map2 with two filtered - should be outlawed!
module Test with
letrec {
  test : Vector# Int# -> Vector# Int#
    = \(us : Vector# Int#).
      let us1 : Vector# Int#
            = vfilter# [Int#]
                  (\(x0 : Int#). gt# [Int#] 1i# x0) us in
      let us2 : Vector# Int#
            = vfilter# [Int#]
                  (\(x2 : Int#). gt# [Int#] 2i# x2) us in
      let us' : Vector# Int#
            = vmap2# [Int#] [Int#] [Int#]
                  (\(x4 x5 : Int#). add# [Int#] x4 x5) us1 us2 in
      us'
}


-- Simple filter - return filtered
Error transforming core program.
  Kind mismatch.
                  Expected kind: Proc
   does not match inferred kind: Rate
  
  with: us$k


-- Map over a filter
Error transforming core program.
  Kind mismatch.
                  Expected kind: Proc
   does not match inferred kind: Rate
  
  with: us$k


-- Filter of a filtered, return both. Should be single kernel
Error transforming core program.
  Kind mismatch.
                  Expected kind: Proc
   does not match inferred kind: Rate
  
  with: us$k


-- Filter and fold, then use fold value in map over original and filtered. Three kernels:
-- 1- filter, fold
-- 2- map original
-- 3- map filtered
-- :flow-rate..
-- module Test with letrec
-- test    (orig : Vector# Int#) : Tuple2# (Vector# Int#) (Vector# Int#)
--         -- Kernel 1
--  = do   filt  = vfilter# (gt#  1i#) orig 
--         fold  = vreduce#  add# 0i# filt
-- 
--         -- Kernel 2
--         morig = vmap# (add# fold) orig
-- 
--         -- Kernel 3
--         mfilt = vmap# (add# fold) filt
--         T2# morig mfilt
-- ;;
-- 


-- Filter and two folds, then use fold values in map over original and filtered. Three kernels:
-- 1- filter, fold, fold
-- 2- map original
-- 3- map filtered
Error transforming core program.
  Kind mismatch.
                  Expected kind: Proc
   does not match inferred kind: Rate
  
  with: morig$'$k


