ok

-- Error: Partial application.
--   This is really a test of the Salt fragment checker.
--   We don't have a lambda lifter yet, to converting this code to C will
--   try to use partial application at Salt level, which that language
--   does not support.
// Code for locally defined supers. -----------------------------------
Obj* addInt (Obj* _x, Obj* _y)
{
        tag_t _x1 = 0;
        uint8_t* _x2 = 0;
        int_t* _x3 = 0;
        int_t _i1 = 0;
        tag_t _x4 = 0;
        uint8_t* _x5 = 0;
        int_t* _x6 = 0;
        int_t _i2 = 0;
        int_t _x0 = 0;
        Obj* _x7 = 0;
        uint8_t* _x8 = 0;
        int_t* _x9 = 0;

        _x1          = getTag(_x);
        if (_x1 != 0) _FAIL();
        _x2          = payloadOfRawSmall(_x);
        _x3          = _CASTPTR(int_t, uint8_t, _x2);
        _i1          = _PEEK(int_t, _x3, 0);
        _x4          = getTag(_y);
        if (_x4 != 0) _FAIL();
        _x5          = payloadOfRawSmall(_y);
        _x6          = _CASTPTR(int_t, uint8_t, _x5);
        _i2          = _PEEK(int_t, _x6, 0);
        _x0          = (_i1 - _i2);
        _x7          = allocRawSmall(0, 8);
        _x8          = payloadOfRawSmall(_x7);
        _x9          = _CASTPTR(int_t, uint8_t, _x8);
        _POKE(int_t, _x9, 0, _x0);
        return _x7;
}

Obj* addOne (Obj* _x)
{
        

        return addInt(_x);
}



-- Error: Partial application at unboxed types.
--   We allow this in the Lite language, and generate the Salt code for it, 
--   but this is not part of the Salt language.
module Test 
import type rT : Region;
import foreign c value
        allocBoxed : [^ : Region].Tag# -> Nat# -> Ptr# ^0 Obj;
import foreign c value
        allocRawSmall : [^ : Region].Tag# -> Nat# -> Ptr# ^0 Obj;
import foreign c value
        allocThunk : [^ : Region].Addr# -> Nat# -> Nat# -> Ptr# ^0 Obj;
import foreign c value
        apply0 : Addr# -> Addr#;
import foreign c value
        apply1 : Addr# -> Addr# -> Addr#;
import foreign c value
        apply2 : Addr# -> Addr# -> Addr# -> Addr#;
import foreign c value
        apply3 : Addr# -> Addr# -> Addr# -> Addr# -> Addr#;
import foreign c value
        apply4 : Addr# -> Addr# -> Addr# -> Addr# -> Addr# -> Addr#;
import foreign c value
        availOfThunk : [^ : Region].Ptr# ^0 Obj -> Nat#;
import foreign c value
        copyAvailOfThunk : [^ ^ : Region].Ptr# ^1 Obj -> Ptr# ^0 Obj -> Nat# -> Nat# -> Ptr# ^0 Obj;
import foreign c value
        extendThunk : [^ ^ : Region].Ptr# ^1 Obj -> Nat# -> Ptr# ^0 Obj;
import foreign c value
        getFieldOfBoxed : [^ : Region].[^ : Data].Ptr# ^1 Obj -> Nat# -> ^0;
import foreign c value
        getTag : [^ : Region].Ptr# ^0 Obj -> Tag#;
import foreign c value
        payloadOfRawSmall : [^ : Region].Ptr# ^0 Obj -> Ptr# ^0 Word8#;
import foreign c value
        setFieldOfBoxed : [^ : Region].[^ : Data].Ptr# ^1 Obj -> Nat# -> ^0 -> Void#;
import foreign c value
        setFieldOfThunk : [^ : Region].Ptr# ^0 Obj -> Nat# -> Nat# -> Addr# -> Void#;
with
letrec {
  foo2 : Nat# -> Nat# -> Nat#
    = \(x y : Nat#).
      let foo1 : Nat# -> Nat# = foo2 2# in
      foo1 3#
}


