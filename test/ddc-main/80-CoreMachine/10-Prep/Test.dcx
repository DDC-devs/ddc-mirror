:set lang Machine
:set PrettyUseLetCase
:set Synth

:machine-prep..
module Map

-- Needed to lift these to top-level rather than on each function.
-- Looks like substitution or beta for nested data binders is broken
-- Maybe forward just needs to anonymize the payload before moving
import foreign abstract type
    a0 : Data
    b0 : Data
    c0 : Data
import value
    f0 : a0 -> b0
    g0 : b0 -> c0

-- Mark the top-level function as an export so it won't be forwarded
export exec : Source# a0 -> Sink# c0 -> Process#

with
-- These need to be lets, not letrec because Forward (rightly) doesn't
-- forward recursive definitions.
-- Another pass that converts non-recursive letrecs into lets would be ideal.
let map [a b : Data] (f : a -> b) (as : Stream# a) : Tuple1# (Stream# b)
 = stream_1_1# (\inp out. letrec
    p1   = pull# inp p2
    p2 v = push# out (f v) p3
    p3   = drop# inp p1
 in p1) as

in let mapmap xs
 =  letcase T1# ys = map f0 xs
 in letcase T1# zs = map g0 ys
 in T1# zs

in let exec  (ins : Source# a0) (outs : Sink# c0) 
 = process_1_1# mapmap ins outs
;;

