-- Construct an empty list.
Nil [R0#] [Int R0#] ()


-- Construct a single element list.
:eval..
Cons [R0#] [Int R0#]
        (5 [R0#] ())
        (Nil [R0#] [Int R0#] ());;


-- Contruct and destruct a single element list.
:eval..
let i   = 5 [R0#] () in
let nil = Nil  [R0#] [Int R0#] () in
let xx  = Cons [R0#] [Int R0#] i nil in
case xx of {
        Nil           -> 0 [R0#] ();
        Cons x xs     -> x
};;


-- Match on an integer literal.
:eval..
case 5 [R0#] () of {
        5  -> 1 [R0#] ();
        _  -> 0 [R0#] ();
};;


-- Fall through to default alternative.
:eval..
case 5 [R0#] () of {
        6 -> 1 [R0#] ();
        _ -> 0 [R0#] ();
};;


-- Handle forget cast around the discriminant.
:eval..
letregion r with {w : Global r} in
let xx = forget <use [r] w> in 
        Cons [r] [Int r] (5 [r] ()) (Nil [r] [Int r] ()) in
case xx of {
        Nil      -> 0 [R0#] ();
        Cons x _ -> addInt [:r R0# R0#:] x (0 [R0#] ());
};;


-- Should be able to build a pair of unit
-- All unit values share a single location.
:eval..
case Pr [R0#] [Unit] [Int R0#] () (5 [R0#] ()) of {
        Pr x _ -> x
};;


-- Let-bound loc gets redirected to a static store location,
-- and the integer constructor needs to accept this.
:eval..
let x : Int R1# = 2 [R1#] () in
let ^ : Unit    = () in
let ^ : [^ : Region].Unit -(Alloc ^0 | Empty)> Int ^0 = 1 in
let ^           = ^0 [R0#] ^1 in
addInt [R0#] [R1#] [R2#] ^0 x;;
