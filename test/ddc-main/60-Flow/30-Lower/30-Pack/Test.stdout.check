
-- Pack with an existing series of flags.
module Test with
letrec {
  packMe : [k0 : Rate].[a : Data].Series# k0 a -> Series# k0 Bool# -> Vector# a
    = /\(k0 : Rate)./\(a : Data).
       \(s : Series# k0 a).\(flags : Series# k0 Bool#).
      let k1$count : Ref# Int# = new# [Int#] 0i# in
      let x0 : Vector# a = vnewR# [a] [k0] in
      let _ : Unit
            = loop# [k0]
                  (\(^ : Int#).
                   let flags$elem : Bool# = next# [Bool#] [k0] flags ^0 in
                   let flags$use$elem : Bool# = flags$elem in
                   let s$elem : a = next# [a] [k0] s ^0 in
                   let _ : Unit
                         = guard# k1$count flags$use$elem
                               (\(^ : Int#).
                                let _ : Unit = vwrite# [a] x0 ^0 s$elem in
                                ()) in
                   ()) in
      let ^ : Int# = read# [Int#] k1$count in
      let x0 : Vector# a = vslice# [a] ^0 x0 in
      let x2 : Vector# a = x0 in
      x2
}


-- Filter, producing our own flags.
module Test with
letrec {
  filter : [k0 : Rate].[a : Data].(a -> Bool#) -> Series# k0 a -> Vector# a
    = /\(k0 : Rate)./\(a : Data).
       \(f : a -> Bool#).\(s : Series# k0 a).
      let k1$count : Ref# Int# = new# [Int#] 0i# in
      let x2 : Vector# a = vnewR# [a] [k0] in
      let _ : Unit
            = loop# [k0]
                  (\(^ : Int#).
                   let s$elem : a = next# [a] [k0] s ^0 in
                   let x1$elem : Bool# = f s$elem in
                   let x1$use$elem : Bool# = x1$elem in
                   let _ : Unit
                         = guard# k1$count x1$use$elem
                               (\(^ : Int#).
                                let _ : Unit = vwrite# [a] x2 ^0 s$elem in
                                ()) in
                   ()) in
      let ^ : Int# = read# [Int#] k1$count in
      let x2 : Vector# a = vslice# [a] ^0 x2 in
      let x4 : Vector# a = x2 in
      x4
}


-- Filter, and also materialize the input vector inside the new
-- selector context.
module Test with
letrec {
  filter : [k0 : Rate].[a : Data].(a -> Bool#) -> Series# k0 a -> Tuple2# (Vector# a) (Vector# a)
    = /\(k0 : Rate)./\(a : Data).
       \(f : a -> Bool#).\(s : Series# k0 a).
      let k1$count : Ref# Int# = new# [Int#] 0i# in
      let x2 : Vector# a = vnewR# [a] [k0] in
      let x3 : Vector# a = vnewR# [a] [k0] in
      let _ : Unit
            = loop# [k0]
                  (\(^ : Int#).
                   let s$elem : a = next# [a] [k0] s ^0 in
                   let x1$elem : Bool# = f s$elem in
                   let x1$use$elem : Bool# = x1$elem in
                   let _ : Unit = vwrite# [a] x3 ^0 s$elem in
                   let _ : Unit
                         = guard# k1$count x1$use$elem
                               (\(^ : Int#).
                                let _ : Unit = vwrite# [a] x2 ^0 s$elem in
                                ()) in
                   ()) in
      let ^ : Int# = read# [Int#] k1$count in
      let x2 : Vector# a = vslice# [a] ^0 x2 in
      let x4 : Tuple2# (Vector# a) (Vector# a)
            = T2# [Vector# a] [Vector# a] x2 x3 in
      let x6 : Tuple2# (Vector# a) (Vector# a) = x4 in
      x6
}


-- Nested filter.
-- Ensure we can handle nested selector contexts.
module Test with
letrec {
  filter : [k0 : Rate].[a : Data].(a -> Bool#) -> (a -> Bool#) -> Series# k0 a -> Vector# a
    = /\(k0 : Rate)./\(a : Data).
       \(f g : a -> Bool#).\(s0 : Series# k0 a).
      let k1$count : Ref# Int# = new# [Int#] 0i# in
      let k2$count : Ref# Int# = new# [Int#] 0i# in
      let x4 : Vector# a = vnewR# [a] [k0] in
      let _ : Unit
            = loop# [k0]
                  (\(^ : Int#).
                   let s0$elem : a = next# [a] [k0] s0 ^0 in
                   let x1$elem : Bool# = f s0$elem in
                   let x1$use$elem : Bool# = x1$elem in
                   let _ : Unit
                         = guard# k1$count x1$use$elem
                               (\(^ : Int#).
                                let x3$elem : Bool# = g s0$elem in
                                let x3$use$elem : Bool# = x3$elem in
                                let _ : Unit
                                      = guard# k2$count x3$use$elem
                                            (\(^ : Int#).
                                             let _ : Unit = vwrite# [a] x4 ^0 s0$elem in
                                             ()) in
                                ()) in
                   ()) in
      let ^ : Int# = read# [Int#] k2$count in
      let x4 : Vector# a = vslice# [a] ^0 x4 in
      let x6 : Vector# a = x4 in
      let x8 : Vector# a = x6 in
      x8
}

-- Sequential filter.
-- Ensure we can handle two selector contexts on the same input.
module Test with
letrec {
  filter : [k0 : Rate].[a : Data].(a -> Bool#) -> (a -> Bool#) -> Series# k0 a -> Tuple2# (Vector# a) (Vector# a)
    = /\(k0 : Rate)./\(a : Data).
       \(f g : a -> Bool#).\(s0 : Series# k0 a).
      let k1$count : Ref# Int# = new# [Int#] 0i# in
      let k2$count : Ref# Int# = new# [Int#] 0i# in
      let x4 : Vector# a = vnewR# [a] [k0] in
      let x7 : Vector# a = vnewR# [a] [k0] in
      let _ : Unit
            = loop# [k0]
                  (\(^ : Int#).
                   let s0$elem : a = next# [a] [k0] s0 ^0 in
                   let x1$elem : Bool# = f s0$elem in
                   let x3$elem : Bool# = f s0$elem in
                   let x1$use$elem : Bool# = x1$elem in
                   let x3$use$elem : Bool# = x3$elem in
                   let _ : Unit
                         = guard# k1$count x1$use$elem
                               (\(^ : Int#).
                                let _ : Unit = vwrite# [a] x4 ^0 s0$elem in
                                ()) in
                   let _ : Unit
                         = guard# k2$count x3$use$elem
                               (\(^ : Int#).
                                let _ : Unit = vwrite# [a] x7 ^0 s0$elem in
                                ()) in
                   ()) in
      let ^ : Int# = read# [Int#] k1$count in
      let x4 : Vector# a = vslice# [a] ^0 x4 in
      let ^ : Int# = read# [Int#] k2$count in
      let x7 : Vector# a = vslice# [a] ^0 x7 in
      let x6 : Vector# a = x4 in
      let x9 : Vector# a = x7 in
      let x10 : Tuple2# (Vector# a) (Vector# a)
            = T2# [Vector# a] [Vector# a] x6 x9 in
      x10
}



