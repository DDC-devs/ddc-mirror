

:set lang Flow
:flow-prep..
module Test with letrec

highInt (x : Int#) (y : Int#) : Int#
 = case gt# [Int#] x y of
        True#   -> x
        False#  -> y

maxPack [k1 : Rate]
        (ss : Series# k1 Int#)
        : Tuple2# Int# (Vector# Int#)
 = do
        flags   = map#  [k1] [Int#] [Bool#]
                        (\(x : Int#). gt# [Int#] x 0i#)
                        ss

        mkSel1# [k1] [Tuple2# Int# (Vector# Int#)] flags
         (/\(k2 : Rate). \(sel : Sel1# k1 k2).
          let sAbove   = pack# [k1] [k2]   [Int#] sel ss in 
          let max      = fold# [k2] [Int#] [Int#] highInt 0i# sAbove in
          let vAbove   = vectorOfSeries# [k2] [Int#] sAbove 
          in T2# [Int#] [Vector# Int#] max vAbove)
;;


-- Tupling of pack with fold.
-- Returns the even values, along with sum of all and just evens.
:flow-lower..
module Test with letrec
lower_even_sum 
        [k0 : Rate] 
        (s0 : Series# k0 Int#)
        : Tuple3# (Vector# Int#) Int# Int#
 = do  
        total   = fold# [k0] [Int#] [Int#] (add# [Int#]) 0i# s0 

        flags   = map#  [k0] [Int#] [Bool#] 
                        (\(x : Int#). eq# [Int#] (mod# [Int#] x 2i#) 0i#) 
                        s0

        mkSel1# [k0] [Tuple3# (Vector# Int#) Int# Int#] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let sPositive = pack# [k0] [k1] [Int#] sel s0
          in  T3# [Vector# Int#] [Int#] [Int#]
                (vectorOfSeries# [k1] [Int#] sPositive)
                total
                (fold# [k1] [Int#] [Int#] (add# [Int#]) 0i# sPositive))
;;
