:set SuppressLetTypes

-- Pack with an existing series of flags.
:flow-lower..
module Test with letrec
packMe  [k0 : Rate] [a : Data]
        (s  : Series# k0 a) (flags : Series# k0 Bool#)
        : Vector# a

 =      smkSel1# [k0] [Vector# a] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let s2       = spack# [k0] [k1] [a] sel s
          in  screate#  [k1] [a] s2)
;;


-- Filter, producing our own flags.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#) (s : Series# k0 a)
        : Vector# a
 = do   
        flags   = smap# [k0] [a] [Bool#] (\(x : a). f x) s

        smkSel1# [k0] [Vector# a] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let  s2      =  spack# [k0] [k1] [a] sel s
          in   screate#  [k1] [a] s2)
;;


-- Filter, and also materialize the input vector inside the new
-- selector context.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#) (s : Series# k0 a)
        : Tuple2# (Vector# a) (Vector# a)
 = do   
        flags   = smap# [k0] [a] [Bool#] (\(x : a). f x) s

        smkSel1# [k0] [Tuple2# (Vector# a) (Vector# a)] flags
         (/\(k1 : Rate). \(sel : Sel1# k0 k1).
          let  s2      =  spack# [k0] [k1] [a] sel s
          in   T2# [Vector# a] [Vector# a]
                   (screate#  [k1] [a] s2)
                   (screate#  [k0] [a] s))
;;


-- Nested filter.
-- Ensure we can handle nested selector contexts.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#)  (g : a -> Bool#)
        (s0 : Series# k0 a)
        : Vector# a
 = do   
        flags1  = smap# [k0] [a] [Bool#] (\(x : a). f x) s0

        smkSel1# [k0] [Vector# a] flags1
         (/\(k1 : Rate). \(sel1 : Sel1# k0 k1).
          let  s1      = spack# [k0] [k1] [a] sel1 s0 in
          let  flags2  = smap#  [k1] [a]  [Bool#] (\(x : a). g x) s1 

          in   smkSel1# [k1] [Vector# a] flags2
                 (/\(k2 : Rate). \(sel2 : Sel1# k1 k2).
                  let   s2 = spack# [k1] [k2] [a] sel2 s1
                  in    screate# [k2] [a] s2))
;;

-- Sequential filter.
-- Ensure we can handle two selector contexts on the same input.
:flow-lower..
module Test with letrec
filter  [k0 : Rate] [a : Data]
        (f  : a -> Bool#)  (g : a -> Bool#)
        (s0 : Series# k0 a)
        : Tuple2# (Vector# a) (Vector# a)
 = do   
        flags1  = smap# [k0] [a] [Bool#] (\(x : a). f x) s0
        flags2  = smap# [k0] [a] [Bool#] (\(x : a). f x) s0

        s1 = smkSel1# [k0] [Vector# a] flags1
         (/\(k1 : Rate). \(sel1 : Sel1# k0 k1).
          let  s1      = spack# [k0] [k1] [a] sel1 s0 in
               screate# [k1] [a] s1)
         
        s2 = smkSel1# [k0] [Vector# a] flags2
         (/\(k2 : Rate). \(sel2 : Sel1# k0 k2).
          let  s2      = spack# [k0] [k2] [a] sel2 s0 in
               screate# [k2] [a] s2)

        T2# [Vector# a] [Vector# a] s1 s2
;;



