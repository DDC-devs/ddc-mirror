ok

-- Fold and reduce at the same time.
module Test with
letrec {
  ffold : [k : Rate].Ref# Int# -> Series# k Int# -> Int#
    = /\(k : Rate).
       \(x : Ref# Int#).\(s : Series# k Int#).
      let x$init = read# [Int#] x in
      let x$acc = new# [Int#] x$init in
      let x7$acc = new# [Int#] 0i# in
      let _
            = loop# [k]
                  (\(x2 : Nat#).
                   let s$elem = next# [Int#] [k] s x2 in
                   let x$val = read# [Int#] x$acc in
                   let x3 = mul# [Int#] x$val s$elem in
                   let _ = write# [Int#] x$acc x3 in
                   let x7$val = read# [Int#] x7$acc in
                   let x4 = add# [Int#] x7$val s$elem in
                   let _ = write# [Int#] x7$acc x4 in
                   ()) in
      let x$res = read# [Int#] x$acc in
      let _ = write# [Int#] x x$res in
      let x7 = read# [Int#] x7$acc in
      x7
}
