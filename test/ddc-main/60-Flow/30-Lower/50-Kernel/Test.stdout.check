
-- Multiply two series.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Vector# Float32# -> Series# (Down4# k) Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(v : Vector# Float32#).\(s1 s2 : Series# (Down4# k) Float32#).
      let _ : Unit
            = loop# [k]
                  (\(x2 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x2 in
                   let s2$elem : Vec4# Float32# = next$4# [Float32#] [k] s2 x2 in
                   let x3$elem : Vec4# Float32# = vmul$4# [Float32#] s1$elem s2$elem in
                   let _ : Unit = vwrite$4# [Float32#] v x2 x3$elem in
                   ()) in
      ()
}


-- Multiply by constant, lifting replicates constant.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Vector# Float32# -> Series# (Down4# k) Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(v : Vector# Float32#).\(s1 s2 : Series# (Down4# k) Float32#).
      let _ : Unit
            = loop# [k]
                  (\(x2 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x2 in
                   let s2$elem : Vec4# Float32# = next$4# [Float32#] [k] s2 x2 in
                   let x3$elem : Vec4# Float32# = vmul$4# [Float32#] s1$elem s2$elem in
                   let x3 : Vec4# Float32# = vrep$4# [Float32#] 2.0f32# in
                   let x6$elem : Vec4# Float32# = vadd$4# [Float32#] x3 x3$elem in
                   let _ : Unit = vwrite$4# [Float32#] v x2 x6$elem in
                   ()) in
      ()
}


-- Gather from vector.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Vector# Float32# -> Vector# Float32# -> Series# (Down4# k) Nat# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(v1 v2 : Vector# Float32#).\(s1 : Series# (Down4# k) Nat#).
      let _ : Unit
            = loop# [k]
                  (\(x1 : Nat#).
                   let s1$elem : Vec4# Nat# = next$4# [Nat#] [k] s1 x1 in
                   let s2$elem : Vec4# Float32# = vgather$4# [Float32#] v1 s1$elem in
                   let x2 : Vec4# Float32# = vrep$4# [Float32#] 2.0f32# in
                   let x2$elem : Vec4# Float32# = vadd$4# [Float32#] x2 s2$elem in
                   let _ : Unit = vwrite$4# [Float32#] v2 x1 x2$elem in
                   ()) in
      ()
}


-- Scatter into vector.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Vector# Float32# -> Series# (Down4# k) Nat# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(v1 : Vector# Float32#).\(s1 : Series# (Down4# k) Nat#).\(s2 : Series# (Down4# k) Float32#).
      let _ : Unit
            = loop# [k]
                  (\(x1 : Nat#).
                   let s1$elem : Vec4# Nat# = next$4# [Nat#] [k] s1 x1 in
                   let s2$elem : Vec4# Float32# = next$4# [Float32#] [k] s2 x1 in
                   let x2 : Vec4# Float32# = vrep$4# [Float32#] 2.0f32# in
                   let x2$elem : Vec4# Float32# = vadd$4# [Float32#] x2 s2$elem in
                   let _ : Unit = vscatter$4# [Float32#] v1 s1$elem x2$elem in
                   ()) in
      ()
}


-- Sum the elements of a vector.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Ref# Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(x1 : Ref# Float32#).\(s1 : Series# (Down4# k) Float32#).
      let x4 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x1$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x4 in
      let _ : Unit
            = loop# [k]
                  (\(x3 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x3 in
                   let x1$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x1$vec in
                   let x5 : Vec4# Float32# = vadd$4# [Float32#] x1$val s1$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x1$vec x5 in
                   ()) in
      let x1$res : Vec4# Float32#
            = read# [Vec4# Float32#] x1$vec in
      let x7 : Float32# = vproj$4$0# [Float32#] x1$res in
      let x1$res$0 : Float32# = add# [Float32#] 0.0f32# x7 in
      let x9 : Float32# = vproj$4$1# [Float32#] x1$res in
      let x1$res$1 : Float32# = add# [Float32#] x1$res$0 x9 in
      let x11 : Float32# = vproj$4$2# [Float32#] x1$res in
      let x1$res$2 : Float32# = add# [Float32#] x1$res$1 x11 in
      let x13 : Float32# = vproj$4$3# [Float32#] x1$res in
      let x1$res$3 : Float32# = add# [Float32#] x1$res$2 x13 in
      let _ : Unit = write# [Float32#] x1 x1$res$3 in
      ()
}


-- Fuse gather, map and reduce in one.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Ref# Float32# -> Vector# Float32# -> Series# (Down4# k) Nat# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(x1 : Ref# Float32#).\(v1 : Vector# Float32#).\(s1 : Series# (Down4# k) Nat#).
      let x3 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x1$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x3 in
      let _ : Unit
            = loop# [k]
                  (\(x2 : Nat#).
                   let s1$elem : Vec4# Nat# = next$4# [Nat#] [k] s1 x2 in
                   let s2$elem : Vec4# Float32# = vgather$4# [Float32#] v1 s1$elem in
                   let x4 : Vec4# Float32# = vrep$4# [Float32#] 2.0f32# in
                   let x3$elem : Vec4# Float32# = vmul$4# [Float32#] x4 s2$elem in
                   let x1$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x1$vec in
                   let x6 : Vec4# Float32# = vadd$4# [Float32#] x1$val x3$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x1$vec x6 in
                   ()) in
      let x1$res : Vec4# Float32#
            = read# [Vec4# Float32#] x1$vec in
      let x8 : Float32# = vproj$4$0# [Float32#] x1$res in
      let x1$res$0 : Float32# = add# [Float32#] 0.0f32# x8 in
      let x10 : Float32# = vproj$4$1# [Float32#] x1$res in
      let x1$res$1 : Float32# = add# [Float32#] x1$res$0 x10 in
      let x12 : Float32# = vproj$4$2# [Float32#] x1$res in
      let x1$res$2 : Float32# = add# [Float32#] x1$res$1 x12 in
      let x14 : Float32# = vproj$4$3# [Float32#] x1$res in
      let x1$res$3 : Float32# = add# [Float32#] x1$res$2 x14 in
      let _ : Unit = write# [Float32#] x1 x1$res$3 in
      ()
}


-- Dot product.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Ref# Float32# -> Series# (Down4# k) Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(x1 : Ref# Float32#).\(s1 s2 : Series# (Down4# k) Float32#).
      let x4 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x1$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x4 in
      let _ : Unit
            = loop# [k]
                  (\(x3 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x3 in
                   let s2$elem : Vec4# Float32# = next$4# [Float32#] [k] s2 x3 in
                   let x4$elem : Vec4# Float32# = vmul$4# [Float32#] s1$elem s2$elem in
                   let x1$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x1$vec in
                   let x5 : Vec4# Float32# = vadd$4# [Float32#] x1$val x4$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x1$vec x5 in
                   ()) in
      let x1$res : Vec4# Float32#
            = read# [Vec4# Float32#] x1$vec in
      let x8 : Float32# = vproj$4$0# [Float32#] x1$res in
      let x1$res$0 : Float32# = add# [Float32#] 0.0f32# x8 in
      let x10 : Float32# = vproj$4$1# [Float32#] x1$res in
      let x1$res$1 : Float32# = add# [Float32#] x1$res$0 x10 in
      let x12 : Float32# = vproj$4$2# [Float32#] x1$res in
      let x1$res$2 : Float32# = add# [Float32#] x1$res$1 x12 in
      let x14 : Float32# = vproj$4$3# [Float32#] x1$res in
      let x1$res$3 : Float32# = add# [Float32#] x1$res$2 x14 in
      let _ : Unit = write# [Float32#] x1 x1$res$3 in
      ()
}


-- Fuse sum and product.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Ref# Float32# -> Ref# Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(x1 x2 : Ref# Float32#).\(s1 : Series# (Down4# k) Float32#).
      let x5 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x1$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x5 in
      let x6 : Vec4# Float32# = vrep$4# [Float32#] 1.0f32# in
      let x2$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x6 in
      let _ : Unit
            = loop# [k]
                  (\(x4 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x4 in
                   let x1$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x1$vec in
                   let x8 : Vec4# Float32# = vadd$4# [Float32#] x1$val s1$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x1$vec x8 in
                   let x2$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x2$vec in
                   let x9 : Vec4# Float32# = vmul$4# [Float32#] x2$val s1$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x2$vec x9 in
                   ()) in
      let x1$res : Vec4# Float32#
            = read# [Vec4# Float32#] x1$vec in
      let x11 : Float32# = vproj$4$0# [Float32#] x1$res in
      let x1$res$0 : Float32# = add# [Float32#] 0.0f32# x11 in
      let x13 : Float32# = vproj$4$1# [Float32#] x1$res in
      let x1$res$1 : Float32# = add# [Float32#] x1$res$0 x13 in
      let x15 : Float32# = vproj$4$2# [Float32#] x1$res in
      let x1$res$2 : Float32# = add# [Float32#] x1$res$1 x15 in
      let x17 : Float32# = vproj$4$3# [Float32#] x1$res in
      let x1$res$3 : Float32# = add# [Float32#] x1$res$2 x17 in
      let _ : Unit = write# [Float32#] x1 x1$res$3 in
      let x2$res : Vec4# Float32#
            = read# [Vec4# Float32#] x2$vec in
      let x19 : Float32# = vproj$4$0# [Float32#] x2$res in
      let x2$res$0 : Float32# = mul# [Float32#] 1.0f32# x19 in
      let x21 : Float32# = vproj$4$1# [Float32#] x2$res in
      let x2$res$1 : Float32# = mul# [Float32#] x2$res$0 x21 in
      let x23 : Float32# = vproj$4$2# [Float32#] x2$res in
      let x2$res$2 : Float32# = mul# [Float32#] x2$res$1 x23 in
      let x25 : Float32# = vproj$4$3# [Float32#] x2$res in
      let x2$res$3 : Float32# = mul# [Float32#] x2$res$2 x25 in
      let _ : Unit = write# [Float32#] x2 x2$res$3 in
      ()
}


-- Fuse sum and dot product.
module Test with
letrec {
  test : [k : Rate].RateNat# k -> Ref# Float32# -> Ref# Float32# -> Series# (Down4# k) Float32# -> Series# (Down4# k) Float32# -> Unit
    = /\(k : Rate).
       \(n : RateNat# k).\(x1 x2 : Ref# Float32#).\(s1 s2 : Series# (Down4# k) Float32#).
      let x5 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x1$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x5 in
      let x6 : Vec4# Float32# = vrep$4# [Float32#] 0.0f32# in
      let x2$vec : Ref# (Vec4# Float32#)
            = new# [Vec4# Float32#] x6 in
      let _ : Unit
            = loop# [k]
                  (\(x4 : Nat#).
                   let s1$elem : Vec4# Float32# = next$4# [Float32#] [k] s1 x4 in
                   let s2$elem : Vec4# Float32# = next$4# [Float32#] [k] s2 x4 in
                   let x5$elem : Vec4# Float32# = vmul$4# [Float32#] s1$elem s2$elem in
                   let x1$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x1$vec in
                   let x8 : Vec4# Float32# = vadd$4# [Float32#] x1$val x5$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x1$vec x8 in
                   let x2$val : Vec4# Float32#
                         = read# [Vec4# Float32#] x2$vec in
                   let x9 : Vec4# Float32# = vadd$4# [Float32#] x2$val s1$elem in
                   let _ : Unit
                         = write# [Vec4# Float32#] x2$vec x9 in
                   ()) in
      let x1$res : Vec4# Float32#
            = read# [Vec4# Float32#] x1$vec in
      let x12 : Float32# = vproj$4$0# [Float32#] x1$res in
      let x1$res$0 : Float32# = add# [Float32#] 0.0f32# x12 in
      let x14 : Float32# = vproj$4$1# [Float32#] x1$res in
      let x1$res$1 : Float32# = add# [Float32#] x1$res$0 x14 in
      let x16 : Float32# = vproj$4$2# [Float32#] x1$res in
      let x1$res$2 : Float32# = add# [Float32#] x1$res$1 x16 in
      let x18 : Float32# = vproj$4$3# [Float32#] x1$res in
      let x1$res$3 : Float32# = add# [Float32#] x1$res$2 x18 in
      let _ : Unit = write# [Float32#] x1 x1$res$3 in
      let x2$res : Vec4# Float32#
            = read# [Vec4# Float32#] x2$vec in
      let x20 : Float32# = vproj$4$0# [Float32#] x2$res in
      let x2$res$0 : Float32# = add# [Float32#] 0.0f32# x20 in
      let x22 : Float32# = vproj$4$1# [Float32#] x2$res in
      let x2$res$1 : Float32# = add# [Float32#] x2$res$0 x22 in
      let x24 : Float32# = vproj$4$2# [Float32#] x2$res in
      let x2$res$2 : Float32# = add# [Float32#] x2$res$1 x24 in
      let x26 : Float32# = vproj$4$3# [Float32#] x2$res in
      let x2$res$3 : Float32# = add# [Float32#] x2$res$2 x26 in
      let _ : Unit = write# [Float32#] x2 x2$res$3 in
      ()
}
