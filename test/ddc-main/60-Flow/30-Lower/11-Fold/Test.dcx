:set SuppressLetTypes

-- Single fold of input series.
:flow-lower..
module Test with letrec
fold [k : Rate] (s : Series# k Int#) : Int#
 = sfold# [k] [Int#] [Int#] (add# [Int#]) 0i# s
;;


-- Two folds over the same input series.
:flow-lower..
module Test with letrec
ffold [k : Rate] (s : Series# k Int#) : Int#
 = add# [Int#]
        (sfold# [k] [Int#] [Int#] (add# [Int#]) 0i# s)
        (sfold# [k] [Int#] [Int#] (mul# [Int#]) 1i# s)
;;


-- Three folds over the same input series
:flow-lower..
module Test with letrec
fffold [k : Rate] (s : Series# k Int#) : Tuple2# Int# Int#
 = T2# [Int#] [Int#]
    (add# [Int#]
          (sfold# [k] [Int#] [Int#] (add# [Int#]) 0i# s)
          (sfold# [k] [Int#] [Int#] (mul# [Int#]) 1i# s))
    (sfold# [k] [Int#] [Int#] (mul# [Int#]) 1i# s)
;;


-- Fuse map into fold
:flow-lower..
module Test with letrec
foldMap [k : Rate] (s : Series# k Int#) : Int#
 = sfold# [k] [Int#] [Int#] (add# [Int#]) 0i#
         (smap1# [k] [Int#] [Int#]
                 (\(x : Int#). mul# [Int#] x 2i#) s)
;;


-- Fold and fold with index.
:flow-lower..
module Test 
imports { 
        minIx  :: Nat# -> Tuple2# Int# Int# -> Int# -> Tuple2# Int# Int#;
        addInt :: Int# -> Int# -> Int#
}
with letrec
foldix [k : Rate] (s : Series# k Int#) 
        : Tuple2# (Tuple2# Int# Int#) Int#
 = do   mix     = sfoldIndex# [k] [Tuple2# Int# Int#] [Int#] 
                        minIx 
                        (T2# [Int#] [Int#] 0i# 0i#) s 
        sum     = sfold# [k] [Int#] [Int#] addInt 0i# s
   
        T2# [Tuple2# Int# Int#] [Int#] mix sum;;

