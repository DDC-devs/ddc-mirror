
ok
ok

-- Identity function
let ^
      = \(x : Unit). x in
^0 ()
()


-- Identify function with indices.
let ^
      = \(^ : Unit). ^0 in
^0 ()
()


-- Primitive operator.
let ^ = 1 [R0#] () in
let ^ = 2 [R0#] () in
addInt [R0#] [R0#] [R0#] ^1 ^0
3


-- Nested applications
let ^ = 1 [R0#] () in
let ^
      = let ^ = 2 [R1#] () in
        let ^
              = let ^ = 3 [R3#] () in
                let ^ = 4 [R3#] () in
                addInt [R3#] [R3#] [R1#] ^1 ^0 in
        addInt [R1#] [R1#] [R1#] ^1 ^0 in
addInt [R0#] [R1#] [R2#] ^1 ^0
10

-- Type abstraction
let ^
      = /\(t : *).
         \(x : t). x in
let ^
      = Nil [R0#] [Int R0#] () in
^1 [List R0# (Int R0#)] ^0
Nil


-- Primitive in case exp
let ^
      = \(u : Unit).
        let ^ = 1 [R0#] u in
        case ^0 of {
          0  
           -> 1 [R0#] u;
          _ 
           -> let ^ = 2 [R0#] u in
              let ^ = 3 [R0#] u in
              addInt [R0#] [R0#] [R0#] ^1 ^0
        } in
^0 ()
5


-- Letrec
letrec {
  fac : [r : %].Int r -(Read r + Alloc r | Use r)> Int r
    = /\(r : %).
       \(n : Int r).
      case n of {
        0  
         -> 1 [r] ();
        _ 
         -> let ^
                  = let ^
                          = let ^ = 1 [r] () in
                            subInt [r] [r] [r] n ^0 in
                    fac [r] ^0 in
            mulInt [r] [r] [r] n ^0
      }
} in
let ^ = 5 [R1#] () in
fac [R1#] ^0
120


-- Snip out discriminants of case expressions
let ^
      = let ^
              = \(x : Int R0#). x in
        let ^ = 5 [R0#] () in
        ^1 ^0 in
case ^0 of {
  _ 
   -> ()
}
()


-- Over-application
let id : [a : *].a -> a
      = /\(a : *).
         \(x : a). x in
let add : Int R0# -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(x y : Int R0#). addInt [R0#] [R0#] [R0#] x y in
let ^ = 2 [R0#] () in
let ^ = 3 [R0#] () in
id [Int R0# -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#] add ^1 ^0
5
