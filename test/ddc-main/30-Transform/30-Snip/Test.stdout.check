
ok
ok

-- Identity function
let ^ : Unit -> Unit
      = \(x : Unit). x in
^0 ()
()


-- Identify function with indices.
let ^ : Unit -> Unit
      = \(^ : Unit). ^0 in
^0 ()
()


-- Primitive operator.
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R0# = 2 [R0#] () in
addInt [R0#] [R0#] [R0#] ^1 ^0
3


-- Nested applications
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R1#
      = let ^ : Int R1# = 2 [R1#] () in
        let ^ : Int R1#
              = let ^ : Int R3# = 3 [R3#] () in
                let ^ : Int R3# = 4 [R3#] () in
                addInt [R3#] [R3#] [R1#] ^1 ^0 in
        addInt [R1#] [R1#] [R1#] ^1 ^0 in
addInt [R0#] [R1#] [R2#] ^1 ^0
10

-- Type abstraction
let ^ : [t : *].t -> t
      = /\(t : *).
         \(x : t). x in
let ^ : List R0# (Int R0#)
      = Nil [R0#] [Int R0#] () in
^1 [List R0# (Int R0#)] ^0
Nil


-- Primitive in case exp
let ^ : Unit -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(u : Unit).
        let ^ : Int R0# = 1 [R0#] u in
        case ^0 of {
          0  
           -> 1 [R0#] u;
          _ 
           -> let ^ : Int R0# = 2 [R0#] u in
              let ^ : Int R0# = 3 [R0#] u in
              addInt [R0#] [R0#] [R0#] ^1 ^0
        } in
^0 ()
5


-- Letrec
letrec {
  fac : [r : %].Int r -(Read r + Alloc r | Use r)> Int r
    = /\(r : %).
       \(n : Int r).
      case n of {
        0  
         -> 1 [r] ();
        _ 
         -> let ^ : Int r
                  = let ^ : Int r
                          = let ^ : Int r = 1 [r] () in
                            subInt [r] [r] [r] n ^0 in
                    fac [r] ^0 in
            mulInt [r] [r] [r] n ^0
      }
} in
let ^ : Int R1# = 5 [R1#] () in
fac [R1#] ^0
120


-- Snip out discriminants of case expressions
let ^ : Int R0#
      = let ^ : Int R0# -> Int R0#
              = \(x : Int R0#). x in
        let ^ : Int R0# = 5 [R0#] () in
        ^1 ^0 in
case ^0 of {
  _ 
   -> ()
}
()


-- Introduce new bindings for over-applied functions.
ok
let id : [a : *].a -> a
      = /\(a : *).
         \(x : a). x in
let add : Int R0# -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(x y : Int R0#). addInt [R0#] [R0#] [R0#] x y in
let ^ : Int R0# = 2 [R0#] () in
let ^ : Int R0# = 3 [R0#] () in
let ^ : Int R0# -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = id [Int R0# -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#] add in
^0 ^2 ^1
5


-- Function applied to several nested arguments with deBruijn binders.
ok
ok
/\(^ : %)./\(^ : *).
 \(^ : Ptr# ^1 Obj).\(^ : Nat#).\(^ : ^0).
let ^ : Addr# = takePtr# [^1] [Obj] ^2 in
let ^ : Nat#
      = let ^ : Nat#
              = let ^ : Nat# = size2# [Addr#] in
                shl# [Nat#] ^3 ^0 in
        add# [Nat#] 8# ^0 in
write# [^0] ^1 ^0 ^2

