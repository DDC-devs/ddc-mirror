
-- add is commutative. particular regions so it only runs once (ie terminates)
ok, added add_comm

-- commutativity. doesn't change (weaken) type. only for regions
ok

-- swap the 1 and 2
addInt [R1#] [R0#] [R2#] (2 [R1#] ()) (1 [R0#] ())

-- don't swap because they're all R0.
addInt [R0#] [R0#] [R0#] (1 [R0#] ()) (2 [R0#] ())

-- swap the whole whiz-bang
addInt [R1#] [R0#] [R2#] (3 [R1#] ()) (addInt [R0#] [R0#] [R0#] (1 [R0#] ()) (2 [R0#] ()))

-- don't rewrite if it's not an addInt
mulInt [R0#] [R1#] [R2#] (1 [R0#] ()) (2 [R1#] ())

-- rule: let in right-hand side
ok, added mul2

ok
ok

-- simple let
weakclo {mulInt} in
let ^ : Int R0# = 5 [R0#] () in
addInt [R0#] [R0#] [R0#] ^0 ^0
10

-- nested apps 
weakclo {mulInt} in
let ^ : Int R0#
      = weakclo {mulInt} in
        let ^ : Int R0#
              = addInt [R0#] [R0#] [R0#] (1 [R0#] ()) (2 [R0#] ()) in
        addInt [R0#] [R0#] [R0#] ^0 ^0 in
addInt [R0#] [R0#] [R0#] ^0 ^0
12

-- binders inside let
weakclo {mulInt} in
let ^ : Int R0#
      = let ^ : [^ : Region].Unit -(Alloc ^0 | Empty)> Int ^0 = 5 in
        let ^ : Unit = () in
        (/\(^ : Region).
          \(^ : Unit). ^2 [^0] ^0) [R0#] () in
addInt [R0#] [R0#] [R0#] ^0 ^0
10
