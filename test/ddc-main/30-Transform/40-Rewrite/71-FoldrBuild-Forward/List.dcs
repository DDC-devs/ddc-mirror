module List
exports {

compose :: [a b c : Data]. [ef eg : Effect]. [cf cg : Closure].
       (b -(ef|cf)> c)
    -> (a -(eg|cg)> b)
    -(Pure      | cf)>
	a
    -(ef + eg | cf + cg)>
	c;

plus ::
    Int R0#
    -( Pure | Use R0#)>
    Int R0#
    -(Read R0# + Alloc R0# | Use R0#)>
    Int R0#;

zero ::
    Unit
    -(Alloc R0# | Use R0#)>
    Int R0#;

pred ::
    Int R0#
    -(Read R0# + Alloc R0# | Use R0#)>
    Int R0#;

count' ::
    Int R0#
    -(Pure | Use R0#)>
    ([b : Data].
    [ec1 ec2 en : Effect].
    [cc1 cc2 cn : Closure].
    (Int R0# -(ec1|cc1)> b -(ec2|cc2)> b)
    -(Pure | Use R0#)>
    (Unit -(en|cn)> b)
    -(Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + Use R0#)>
    b);

double ::
    Int R0#
    -(Alloc R0# + Read R0# | Use R0#)>
    Int R0#;

even ::
    Int R0#
    -(Alloc R0# + Read R0# | Use R0# )>
    Int R0#;

sum ::
    List R1# (Int R0#)
    -(Read R0# + Read R1# + Alloc R0# | Use R0# + Use R1#)>
    Int R0#;

count ::
    Int R0#
    -(Read R0# + Alloc R0# + Alloc R1# | Use R0# + Use R1#)>
    List R1# (Int R0#);

}
imports {
foldr  :: [a b : Data]. [r : Region].
    [ek1 ek2 ez : Effect]. [ck1 ck2 cz : Closure].
	(a -(ek1|ck1)> b -(ek2|ck2)> b)
    ->	(Unit -(ez|cz)> b)
    ->	(List r a)
    -(Read r + ek1 + ek2 + ez | ck1 + ck2 + cz + Use r)>
	b;

build :: [a : Data]. [r : Region]. [eg1 eg2 : Effect]. [cg1 cg2 : Closure].
    ([b : Data]. [ec1 ec2 en : Effect]. [cc1 cc2 cn : Closure].
	 (a -(ec1|cc1)> b -(ec2|cc2)> b)
	-(eg1|cg1)>
	 (Unit -(en|cn)> b)
	-(eg2+ec1+ec2+en|cg2+cc1)>
	 b)
    -(eg1+eg2 + Alloc r | Use r)> List r a;

}
with letrec

compose [a b c : Data] [ef eg : Effect] [cf cg : Closure]
    (f : b -(ef|cf)> c) (g : a -(eg|cg)> b)
	    { Pure      | cf }
    (x : a) { ef + eg | cf + cg }
	    : c
 = f (g x)


plus
    (a : Int R0#)
    { Pure | Use R0# }
    (b : Int R0#)
    { Read R0# + Alloc R0# | Use R0# }
    : Int R0#
    = addInt [:R0# R0# R0#:] a b

zero
    (u : Unit)
    { Alloc R0# | Use R0# }
    : Int R0# = 0 [R0#] ()

pred
    (a : Int R0#)
    { Read R0# + Alloc R0# | Use R0# }
    : Int R0# = subInt [:R0# R0# R0#:] a (1 [R0#] ())

count' (m : Int R0#)
       { Pure | Use R0# }
       [b : Data]
       [ec1 ec2 en : Effect]
       [cc1 cc2 cn : Closure]
       (k : Int R0# -(ec1|cc1)> b -(ec2|cc2)> b)
       { Pure | Use R0# }
       (z : Unit -(en|cn)> b)
       { Read R0# + Alloc R0# + ec1 + ec2 + en | cc1 + Use R0# }
       : b
    = case m of {
	0	-> z ();
	_	-> k m (count' (pred m) [:b ec1 ec2 en cc1 cc2 cn:] k z)
	}


double (c : Int R0#)
    {Alloc R0# + Read R0# | Use R0# }
    : Int R0#
    = mulInt [:R0# R0# R0#:] c (2 [R0#] ())

even (c : Int R0#)
    {Alloc R0# + Read R0# | Use R0# }
    : Int R0#
    = weakeff [Read R0#]
      in
      0 [R0#] ()


sum (xs : List R1# (Int R0#))
    { Read R0# + Read R1# + Alloc R0# | Use R0# + Use R1# }
    : Int R0#
 = foldr
	    [:(Int R0#) (Int R0#) R1#
	    Pure (Read R0# + Alloc R0#) (Alloc R0#)
	    (Use R0#) (Use R0#) (Use R0#):]
	plus zero xs

count (m : Int R0#)
    { Read R0# + Alloc R0# + Alloc R1# | Use R0# + Use R1# }
    : List R1# (Int R0#) 
 = build
	[:(Int R0#) R1# Pure (Read R0# + Alloc R0#) (Use R0#) (Use R0#):]
	(count' m)


