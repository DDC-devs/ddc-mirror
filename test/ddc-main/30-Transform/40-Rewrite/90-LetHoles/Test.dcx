:set Indent
:with test/ddc-main/30-Transform/40-Rewrite/90-LetHoles/Module.dcs

-- don't look past lets normally
:set.. rule unbox_box (s : Int r0#).
    unbox (box s)
    = s
;;
:set trans Rewrite


-- don't rewrite non-locals
:trans..
let x = box (5 [r0#] ())	in
let y = unbox x			in
let z = unbox x			in
    unbox (box (addInt [:r0# r0# r0#:] y z))
;;


-- the {{ }} brackets indicate that the argument is cheap enough to be split across places
:set.. rule unbox_box (s : Int r0#).
    unbox _{box s}_
    = s
;;
:set trans Rewrite


-- rewrite y and z
:trans..
let x = box (5 [r0#] ())	in
let y = unbox x			in
let z = unbox x			in
    addInt [:r0# r0# r0#:] y z
;;


-- shadowing, don't rewrite
:trans..
let x = box (5 [r0#] ())	in
let x = 2 [r0#] ()		in
    unbox x
;;


-- shadowing with lambdas, don't rewrite
:trans..
let x = box (5 [r0#] ())	in
\(x : Int r0#).
    unbox x
;;


-- some de bruijns. do rewrite
:trans..
let ^ = box (5 [r0#] ())	in
let ^ = 2 [r0#] ()		in
let b = unbox ^1		in
let ^ = 3 [r0#] ()		in
let c = unbox ^2		in
    ()
;;


-- some surrounding de bruijns
:trans..
let ^ = 2 [r0#] ()		in
let ^ = box (5 [r0#] ())	in
let ^ = ^1	        	in
let c = unbox ^1		in
    ()
;;


-- some lambda-y de bruijns
:trans..
let ^ = 2 [r0#] ()		in
let ^ = box (5 [r0#] ())	in
 (\(a : Unit).
  \(^ : Unit).
    let ^ = ^2	        	in
    let c = unbox ^2		in
	()
 )
;;


-- now with a Const contraint and regions
:set.. rule unbox_box [r : Region] (s : Int r).
    Const r =>
    unbox_ [r] _{box_ [r] s}_
    = s
;;
:set trans Rewrite


-- don't do it: not const
:trans..
unbox_ [r0#] (box_ [r0#] (5 [r0#] ()))
;;


-- do it: const
:trans..
letregion r with {w : Const r}		in
let x = unbox_ [r] (box_ [r] (5 [r] ()))	in
    ()
;;


-- separated
:trans..
letregion r with {w : Const r}	in
let x = box_ [r] (5 [r] ())	in
let y = unbox_ [r] x		in
    ()
;;


:set.. rule silly [r : Region] (x y : Int r).
    addInt [:r r r:] x _{subInt [:r r r:] y x}_
    = y
;;
:set trans Rewrite


-- don't fire, just unfold
:trans..
let z = subInt [:r0# r0# r0#:] (5 [r0#] ()) (3 [r0#] ())
in  addInt [:r0# r0# r0#:] (0 [r0#] ()) z
;;
