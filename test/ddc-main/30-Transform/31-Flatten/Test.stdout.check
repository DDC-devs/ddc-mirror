
-- Flatten --------------------------------------------------------------------
ok
ok

module Main with
letrec {
  foo : [r : %].Int r -(Alloc r | Use r)> Unit
    = /\(r : %).
       \(x : Int r).
      let ^ : Int r = 10 [r] () in
      let _ : Unit = () in
      let x0 : Int r = ^0 in
      let ^ : Unit = () in
      ^0
}


-- A-Normalisation ------------------------------------------------------------
-- These tests use a combination of snipping and flattening.
ok

-- Nested applications
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R1# = 2 [R1#] () in
let ^ : Int R3# = 3 [R3#] () in
let ^ : Int R3# = 4 [R3#] () in
let ^ : Int R1# = addInt [R3#] [R3#] [R1#] ^1 ^0 in
let ^ : Int R1# = addInt [R1#] [R1#] [R1#] ^3 ^0 in
addInt [R0#] [R1#] [R2#] ^5 ^0
10


-- Lets in args (inner x must be anonymized)
let x : Int R1# = 2 [R1#] () in
let ^ : Unit = () in
let ^ : [^ : %].Unit -(Alloc ^0 | $0)> Int ^0 = 1 in
let ^ : Int R0# = ^0 [R0#] ^1 in
addInt [R0#] [R1#] [R2#] ^0 x
3


-- Arity
let cmp : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let f' : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(x : Int R0#).
        let ^ : Int R0# = g x in
        f' ^0 in
let up : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(n : Int R0#).
        let ^ : Int R0# = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] n ^0 in
let ^ : Int R0# = 1 [R0#] () in
cmp up up ^0
3


-- Arity anon
let ^ : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(!0 | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(^ : Int R0#).
        let ^ : Int R0# = g ^0 in
        ^2 ^0 in
let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(^ : Int R0#).
        let ^ : Int R0# = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] ^1 ^0 in
let ^ : Int R0# = 1 [R0#] () in
^2 ^1 ^1 ^0
3


-- Letrec
letrec {
  fac : [r : %].Int r -(Read r + Alloc r | Use r)> Int r
    = /\(r : %).
       \(n : Int r).
      case n of {
        0  
         -> 1 [r] ();
        _ 
         -> let ^ : Int r = 1 [r] () in
            let ^ : Int r = subInt [r] [r] [r] n ^0 in
            let ^ : Int r = fac [r] ^0 in
            mulInt [r] [r] [r] n ^0
      }
} in
let ^ : Int R1# = 5 [R1#] () in
fac [R1#] ^0
120


-- Snip out discriminants of case expressions
let ^ : Int R0# -> Int R0#
      = \(x : Int R0#). x in
let ^ : Int R0# = 5 [R0#] () in
let ^ : Int R0# = ^1 ^0 in
case ^0 of {
  _ 
   -> ()
}


-- Anonymous witnesses
let useWit : Const R0# => Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(^ : Const R0#).\(^ : Int R0#). addInt [R0#] [R0#] [R0#] ^0 ^0 in
\(^ : Const R0#).\(^ : Int R0#).
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R0# = addInt [R0#] [R0#] [R0#] ^0 ^1 in
useWit <^3> ^0
