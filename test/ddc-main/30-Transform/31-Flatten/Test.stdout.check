
-- Flatten --------------------------------------------------------------------
ok
ok

module Main with
letrec {
  foo : [r : Region].Int r -(Alloc r | Use r)> Unit
    = /\(r : Region).
       \(x : Int r).
      let ^ : Int r = 10 [r] () in
      let _ : Unit = () in
      let x0 : Int r = ^0 in
      let ^ : Unit = () in
      ^0
}


-- A-Normalisation ------------------------------------------------------------
-- These tests use a combination of snipping and flattening.
ok

-- Nested applications
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R1# = 2 [R1#] () in
let ^ : Int R3# = 3 [R3#] () in
let ^ : Int R3# = 4 [R3#] () in
let ^ : Int R1# = addInt [R3#] [R3#] [R1#] ^1 ^0 in
let ^ : Int R1# = addInt [R1#] [R1#] [R1#] ^3 ^0 in
addInt [R0#] [R1#] [R2#] ^5 ^0
10


-- Lets in args (inner x must be anonymized)
let x : Int R1# = 2 [R1#] () in
let ^ : Unit = () in
let ^ : [^ : Region].Unit -(Alloc ^0 | Empty)> Int ^0 = 1 in
let ^ : Int R0# = ^0 [R0#] ^1 in
addInt [R0#] [R1#] [R2#] ^0 x
3


-- Arity
let cmp : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(Pure | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let f' : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(x : Int R0#).
        let ^ : Int R0# = g x in
        f' ^0 in
let up : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(n : Int R0#).
        let ^ : Int R0# = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] n ^0 in
let ^ : Int R0# = 1 [R0#] () in
cmp up up ^0
3


-- Arity anon
let ^ : (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -> (Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#) -(Pure | Use R0#)> Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
        let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0# = f in
        \(^ : Int R0#).
        let ^ : Int R0# = g ^0 in
        ^2 ^0 in
let ^ : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(^ : Int R0#).
        let ^ : Int R0# = 1 [R0#] () in
        addInt [R0#] [R0#] [R0#] ^1 ^0 in
let ^ : Int R0# = 1 [R0#] () in
^2 ^1 ^1 ^0
3


-- Letrec
letrec {
  fac : [r : Region].Int r -(Read r + Alloc r | Use r)> Int r
    = /\(r : Region).
       \(n : Int r).
      case n of {
        0  
         -> 1 [r] ();
        _ 
         -> let ^ : Int r = 1 [r] () in
            let ^ : Int r = subInt [r] [r] [r] n ^0 in
            let ^ : Int r = fac [r] ^0 in
            mulInt [r] [r] [r] n ^0
      }
} in
let ^ : Int R1# = 5 [R1#] () in
fac [R1#] ^0
120


-- Snip out discriminants of case expressions
let ^ : Int R0# -> Int R0#
      = \(x : Int R0#). x in
let ^ : Int R0# = 5 [R0#] () in
let ^ : Int R0# = ^1 ^0 in
case ^0 of {
  _ 
   -> ()
}


-- Anonymous witnesses
let useWit : Const R0# => Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#
      = \(^ : Const R0#).\(^ : Int R0#). addInt [R0#] [R0#] [R0#] ^0 ^0 in
\(^ : Const R0#).\(^ : Int R0#).
let ^ : Int R0# = 1 [R0#] () in
let ^ : Int R0# = addInt [R0#] [R0#] [R0#] ^0 ^1 in
useWit <^3> ^0


-- Drag letregion out of the top-level of a binding
--  using anonymous binders.
-- 
ok
ok
let ^ : [^ ^ : Region].Unit -(Read ^1 + Alloc ^0 + Alloc ^1 | Use ^0 + Use ^1)> Pair ^1 (Int ^1) (Int ^0)
      = /\(^ ^ : Region).
         \(_ : Unit).
        let ^ : Int ^1 = 5 [^1] () in
        letregion ^ in
        let ^ : Int ^0 = 1 [^0] () in
        let ^ : Int ^1 = addInt [^2] [^0] [^1] ^1 ^0 in
        Pr [^2] [Int ^2] [Int ^1] ^2 ^0 in
letregion ^ in
letregion ^ in
let ^ : Pair ^1 (Int ^1) (Int ^0) = ^0 [^1] [^0] () in
case ^0 of {
  Pr (_ : Int ^1) (^ : Int ^0) 
   -> copyInt [^0] [R0#] ^0
}

