
-- Flatten --------------------------------------------------------------------
:set +Indent
:set trans Flatten

:load..
module Main with
letrec {
foo : [r : Region]. Int r -(Alloc r | Use r)> Unit
 = /\(r : Region). \(x : Int r). 
   let x0 : Int r
         = let ^ : Int r  = 10 [r] () in
           let _ : Unit   = () in
           ^0 in
   let ^ : Unit = ()
   in ^0
};;


-- A-Normalisation ------------------------------------------------------------
-- These tests use a combination of snipping and flattening.
:set trans Snip; Flatten

-- Nested applications
:trun.. 
addInt [:R0# R1# R2#:] 
       (1 [R0#] ()) 
       (addInt [:R1# R1# R1#:] 
               (2 [R1#] ()) 
               (addInt [:R3# R3# R1#:] 
                       (3 [R3#] ()) 
                       (4 [R3#] ())));;


-- Lets in args (inner x must be anonymized)
:trun..
let x = (2 [R1#] ()) in
addInt [:R0# R1# R2#:]
    (let x = () in
     let ^ = 1 in
     ^0 [R0#] x)
    x;;


-- Arity
:trun..
let cmp = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
    let f' = f in \(x:Int R0#). f' (g x) in
let up = \(n : Int R0#). addInt [:R0# R0# R0#:] n (1 [R0#] ()) in
cmp up up (1 [R0#] ());;


-- Arity anon
:trun..
let ^ = \(f g : Int R0# -(Read R0# + Alloc R0# | Use R0#)> Int R0#).
    let ^ = f in \(^ : Int R0#). ^1 (g ^0) in
let ^ = \(^ : Int R0#). addInt [:R0# R0# R0#:] ^0 (1 [R0#] ()) in
^1 ^0 ^0 (1 [R0#] ());;


-- Letrec
:trun..
letrec {
 fac    [r:Region] (n : Int r) {Read r + Alloc r | Use r} : Int r
  = case n of {
        0       -> 1 [r] ();
        _       -> mulInt [:r r r:] n
                      (fac [r] (subInt [:r r r:] n
                                       (1 [r] ())));
     }
} in fac [R1#] (5 [R1#] ());;


-- Snip out discriminants of case expressions
:trans..
case (\(x : Int R0#). x) (5 [R0#] ()) of {
        _       -> ()
};;


-- Anonymous witnesses
:trans..
let useWit = \(^ : Const R0#). \(^ : Int R0#).
    addInt [:R0# R0# R0#:] ^0 ^0
in
\(^ : Const R0#). \(^ : Int R0#).
   useWit {^1} (addInt [:R0# R0# R0#:] (1 [R0#] ()) ^0)
;;


-- Drag letregion out of the top-level of a binding
--  using anonymous binders.
-- 
:set trans Anonymize; Snip; Flatten
:set +Indent
:trans..
let foo [r1 r2 : Region] (_ : Unit)
     = let x = 5 [r1] () in
       let y = letregion r3 in
               addInt [:r1 r3 r2:] x (1 [r3] ()) in
       Pr [r1] [Int r1] [Int r2] x y

in  letregion r4 in
    letregion r5 in
    case foo [:r4 r5:] () of {
            Pr _ y -> copyInt [:r5 R0#:] y
    };;

