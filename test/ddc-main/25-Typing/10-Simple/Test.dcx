-- See if we can print out any type.
:check addInt


-- Instantiate the outer forall of the type of add with a region handle.
-- Region handles in the expression are automatically added to the store at
-- startup time.
:check addInt [R1#]


-- Instantiate all the foralls with different region handles.
:check addInt [R1#] [R2#] [R3#]


-- Same as above, but with nicer syntax.
:check addInt [:R1# R2# R3#:]


-- Instantiate all the foralls with the same region handle.
-- The 'add' primop causes the effect (Read R1# + Read R1#) which should be 
-- packed down to just (Read R1#).
:check addInt [:R1# R1# R1#:]


-- Wrap type lambdas around the 'add' primop and use these to rename the 
-- anonymous binders in its type.
:check /\(r1 r2 r3:%).addInt [:r1 r2 r3:]


-- A fully applied integer constructor should cause an alloc effect.
:check (2 [R1#] ())


-- Addition should also read the args, and alloc the result.
:check addInt [:R1# R2# R3#:] (2 [R1#] ()) (3 [R2#] ())


-- Error: cannot shadow spec binders.
-- This breaks progress if we try to run it.
:check..
(/\(r : %). \(x : Int r). /\(r : %). \(y : Int r).
 case x of {
        0       -> x;
        _       -> y;
 }) [R0#] (2 [R0#] ()) [R1#] (3 [R1#] ());;


-- Error: cannot shadow spec binders.
:check..
(/\(r : %). \(x : Int r). /\(r : %). \(_ : Unit). 2 [r] ()) 
        [R1#];;


-- Error: cannot shadow spec binders.
:check..
(/\(r : %). \(x : Int r). /\(r : %). \(_ : Unit). 2 [r] ()) 
        [R1#] 
        (5 [R1#] ()) 
        [R2#];;


-- Error: Type variable not in environment.
:kind a


-- Error: Type constructor not in environment.
:kind Whatever


-- Error: Data constructor not in environment.
:type Whatever


-- Error: Type constructor used as a data constructor.
:type Unit


-- Error: Data constructor used as a type constructor.
:kind ()


-- Error: Type variable used as a value variable.
:check (/\(a : *). \(x : a). a)

