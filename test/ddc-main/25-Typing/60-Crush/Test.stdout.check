-- Check that HeadRead in result effect is crushed.
let xx : List R0# (Int R0#)
      = Nil [R0#] [Int R0#] () in
case xx of {
  Nil  
   -> 0 [R0#] ();
  Cons (x : Int R0#) (xs : List R0# (Int R0#)) 
   -> x
}
:*: Int R0#
:!: Read R0# + Alloc R0#
:$: Use R0#


-- Check that the HeadRead effect is crushed out when
-- the read is on a type with no head region.
caselet ()   = () in
()
:*: Unit
:!: Pure
:$: Empty


-- Check substituted effects are crushed under HeadRead.
\(f : [a : Data].a -(HeadRead a | DeepUse a)> a).
f [Int R0#] (5 [R0#] ())
:*: ([a : Data].a -(HeadRead a | DeepUse a)> a) -(Read R0# + Alloc R0# | Use R0#)> Int R0#
:!: Pure
:$: Use R0#


-- Check substituted effects are crushed under DeepRead
\(f : [a : Data].a -(DeepRead a | DeepUse a)> a).
f [Int R0#] (5 [R0#] ())
:*: ([a : Data].a -(DeepRead a | DeepUse a)> a) -(Read R0# + Alloc R0# | Use R0#)> Int R0#
:!: Pure
:$: Use R0#


-- Check substituted effects are crushed under DeepWrite
\(f : [a : Data].a -(DeepWrite a | DeepUse a)> a).
f [Int R0#] (5 [R0#] ())
:*: ([a : Data].a -(DeepWrite a | DeepUse a)> a) -(Write R0# + Alloc R0# | Use R0#)> Int R0#
:!: Pure
:$: Use R0#


-- Check substituted effects are crushed under DeepAlloc
\(f : [a : Data].a -(DeepAlloc a | DeepUse a)> a).
f [Int R0#] (5 [R0#] ())
:*: ([a : Data].a -(DeepAlloc a | DeepUse a)> a) -(Alloc R0# | Use R0#)> Int R0#
:!: Pure
:$: Use R0#


-- Using a polymorphic addition function requires DeepRead and DeepAlloc
letrec {
  double : [a : Data].(a -> a -(DeepRead a + DeepAlloc a | DeepUse a)> a) -> a -(DeepRead a + DeepAlloc a | Empty)> a
    = /\(a : Data).
       \(add : a -> a -(DeepRead a + DeepAlloc a | DeepUse a)> a).\(x : a). add x x
} in
double [Int R0#] (addInt [R0#] [R0#] [R0#]) (5 [R0#] ())
:*: Int R0#
:!: Read R0# + Alloc R0#
:$: Use R0#
