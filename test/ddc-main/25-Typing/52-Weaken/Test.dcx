-- When choosing between two functions, 
-- use the weakening forms to make the type of the smaller
-- one match the larger.
:check..
/\(r1 r2 : %). \(x : Int r1).
case x of {
        0       -> \(y : Int r2). 
                   weakeff [Read r1 + Read r2 + Alloc r2] in
                   weakclo {x; [r2]} in
                   y;

        _       -> \(y : Int r2). addInt [:r1 r2 r2:] x (1 [r2] ());
};;


-- Error: type supplied to weakeff does not have effect kind
:check..
/\(r1 r2 : %). \(x : Int r1).
case x of {
        0       -> \(y : Int r2). 
                   weakeff [r1] in
                   weakclo {x; [r2]} in
                   y;

        _       -> \(y : Int r2). addInt [:r1 r2 r2:] x (1 [r2] ());
};;


-- Weakens should still evaluate their args
:eval..
let x = weakclo {mulInt} in 5 [R0#] ()
in  addInt [:R0# R0# R0#:] x x
;;

