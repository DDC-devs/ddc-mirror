-- Non-binding let.
let _ : Unit = () in
()
:*: Unit
:!: Pure
:$: Empty


-- Binding let.
let x : Unit = () in
x
:*: Unit
:!: Pure
:$: Empty


-- Let-bound function with full signature.
let f : Unit -> Unit
      = \(x : Unit). x in
()
:*: Unit
:!: Pure
:$: Empty


-- Let using function syntax with a return type.
let f : Unit -> Unit
      = \(x : Unit). x in
f ()
:*: Unit
:!: Pure
:$: Empty


-- Let using function syntax without a return type.
let f : Unit -> Unit
      = \(x : Unit). x in
f ()
:*: Unit
:!: Pure
:$: Empty


-- Lazy using function syntax without a return type.
let f : Unit -> Unit
      = \(x : Unit). x in
f ()
:*: Unit
:!: Pure
:$: Empty


-- Multiple lets.
let x : Unit = () in
let y : Unit = () in
y
:*: Unit
:!: Pure
:$: Empty


-- Mutltiple lets with debruijn indices.
-- If the bound variable is pushed on the stack when checking
-- the right of the non-recursive binding then this is mistyped.
let ^ : Unit = () in
let ^ : Int r0# = 23 [r0#] ^0 in
^0
:*: Int r0#
:!: Alloc r0#
:$: Use r0#

-- Simple letregion.
letregion r in
let x : Int r = 4 [r] () in
addInt [r] [r] [r1#] x x
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Letregion with explicitly empty witness set.
letregion r in
let x : Int r = 4 [r] () in
addInt [r] [r] [r1#] x x
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Simple letregion with letrec using explicit type annotation
letregion r in
letrec {
  f : Unit -(Alloc r | Use r)> Int r
    = \(x : Unit). 4 [r] ()
} in
addInt [r] [r] [r1#] (f ()) (f ())
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Simple letregion with letrec using function syntax.
letregion r in
letrec {
  f : Unit -(Alloc r | Use r)> Int r
    = \(x : Unit). 4 [r] ()
} in
addInt [r] [r] [r1#] (f ()) (f ())
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Letrec with a single binding and no braces around it.
letregion r in
letrec {
  f : Unit -(Alloc r | Use r)> Int r
    = \(x : Unit). 4 [r] ()
} in
addInt [r] [r] [r1#] (f ()) (f ())
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Multiple lets and letregion. 
letregions r1 r2 in
let x1 : Int r1 = 2 [r1] () in
let x2 : Int r2 = 3 [r2] () in
addInt [r1] [r2] [r1#] x1 x2
:*: Int r1#
:!: Alloc r1#
:$: Use r1#

-- As above, but no annots on binders.
letregions r1 r2 in
let x1 : Int r1 = 2 [r1] () in
let x2 : Int r2 = 3 [r2] () in
addInt [r1] [r2] [r1#] x1 x2
:*: Int r1#
:!: Alloc r1#
:$: Use r1#


-- Anonymous witness binders
letregion r with {_ : Const r} in
()
:*: Unit
:!: Pure
:$: Empty

