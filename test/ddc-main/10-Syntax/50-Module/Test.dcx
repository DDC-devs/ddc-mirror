-- Load a module definition.
:load..
module Main
exports {
        main    :: Unit -> Unit;
        double  :: [r : Region]. Int r -(Read r + Alloc r | Use r)> Int r;
}
imports {
        Thing.whatever 
         with two :: [r5 : Region]. Unit -(Alloc r5 | Empty)> Int r5;
}
with
letregion rt with { w1 : Const rt ; w2 : Lazy rt} in

let     one = purify <read [rt] w1> in 
              1 [rt] ()  in

letrec { 
        main (_ : Unit) : Unit
         = letregion r0 in
           ();

        double  [r : Region] (x : Int r) 
                { Read r + Alloc r | Use r } 
         : Int r
         = mulInt [:r r r:] x (two [r] ());

        thing   [r : Region] (x : Int r) 
                { Read r + Read rt + Alloc r | Use r + Use rt} 
         : Int r
         = addInt [:r rt r:] x one;
};;


-- Load the same module using the offside rule.
:load..
module Main
exports
        main    :: Unit -> Unit
        double  :: [r : Region]. Int r -(Read r + Alloc r | Use r)> Int r
imports 
        Thing.whatever
         with two :: [r5 : Region]. Unit -(Alloc r5 | Empty)> Int r5
with
letregion rt with { w1 : Const rt ; w2 : Lazy rt} in

let     one = purify <read [rt] w1> in 
              1 [rt] ()  in

letrec 
        main (_ : Unit) : Unit
         = letregion r0 in
           ()

        double  [r : Region] (x : Int r) 
                { Read r + Alloc r | Use r } 
         : Int r
         = mulInt [:r r r:] x (two [r] ())

        thing   [r : Region] (x : Int r) 
                { Read r + Read rt + Alloc r | Use r + Use rt} 
         : Int r
         = addInt [:r rt r:] x one
;;
