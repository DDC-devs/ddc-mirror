
import Base 
{-
body_forceVec m1 m2 x1 y1 x2 y2
 = do {
 	m1'	= unboxFloat32 m1;
	m2'	= unboxFloat32 m2;
	x1'	= unboxFloat32 x1;
	y1'	= unboxFloat32 y1;
	x2'	= unboxFloat32 x2;
	y2'	= unboxFloat32 y2;

	body_forceVec_work m1' m2' x1' y1' x2' y2';
 };
	

body_forceVec_work 
	:: Float32# -> Float32# 
	-> Float32# -> Float32#
	-> Float32# -> Float32#
	-> Vec2 Float;

body_forceVec_work m1 m2 x1 y1 x2 y2
 = do {
 	dx	= x2 - x1;
	dy	= y2 - y1;
	
 	d2	= dx * dx  +  dy * dy;
	d	= sqrtU d2;

	attract_rangeU	
		= unboxFloat32 attract_range;

	attract_force	= m1 * (m2 / d2);

	forceS		= match {
				|# d `primFloat32U_lt` attract_rangeU
				= 	attract_force * (d / attract_rangeU) 
				   - 	(attract_force * (attract_rangeU / d));
				
				\= attract_force;
			};

	theta	= vec2_angleU dx dy;

	forceX	= forceS * cosU theta;
	forceY	= forceS * sinU theta;
	
	forceV	= Vec2 (boxFloat32 forceX) (boxFloat32 forceY);
	forceV;
 };
-}

{-
draw_force :: Frame -> Array Body -> Int -> Int -> ();
draw_force frame body x y
 = match {
 	| x >= 600	= draw_force frame body 0 	(y + draw_force_step);
	| y >= 600	= ();
	
	\= do {
		forceV	= Vec2 0.0 0.0;

		sumAllForces 
			(unboxFloat32 (toFloat x)) (unboxFloat32 (toFloat y))
			body 0 forceV;

		forceS	= forceV.magnitude;
		fS	= log forceS + 6.0;
		color	= forceColor fS;
				
		frame.point  
			x (frame.sizeY - y)
			color;
			
		draw_force frame body (x + draw_force_step) y;
	};
 };


sumAllForces 
	:: Float32# -> Float32# 
	-> Array Body 
	-> Int
	-> Vec2 Float -> Vec2 Float;

sumAllForces pX pY array ix vForce
 = match {
 	| ix >= array_size array
	= vForce;
	
	\= do {
		body	= array .(ix);
		vForce	+= body_forceVec_work 
				1.0# (unboxFloat32 body.mass)
				pX pY
				(unboxFloat32 body.pos.x) (unboxFloat32 body.pos.y);
		
		sumAllForces pX pY array (ix + 1) vForce;
	};
 };
-}				
