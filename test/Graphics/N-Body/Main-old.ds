
-- Testing out
--	Fix GC for anchored arrays.
--	Use/update of data with multiple alternatives.
--	case of case optimisation.
--	work pi into this somehow, fix up top level regions.
--	have tasty mutable data that the full laziness transform will lift if not careful.
--	Later: unboxed vectors?
--	BUGS: can't use name 'force' locally. Conflicts with thunk forcing function.
--
--	in forceBetween , we're not forcing possible thunks read from body structs.
--	add pass to suspend all possible non-effectful applications.
--
--	When id.field returns 'ambiguous projection'.. should return type conflict.
--	Unbox truncate/toFloat
--

import Graphics.Render;
import Data.Array;
import DDC.Runtime;
import Math.Vec2;


-- time_compression	= 1.0;
attract_range		= 20.0;
draw_force_step		= 4;

pi 			= 3.1415926536;
worldSize		= Vec2 600 600;
newBody pos vel		= Body 100.0 pos vel (Vec2 0.0 0.0);


-- Main -----------------------------------------------------------------------------

-- frameCount		= 0;
-- frameCount_max	= 20;

-----
main ()
 = topHandle nbody;

-----
nbody ()
 = do {	frame	= frame_new "N-Body" 600 600;
	case initBodies () of {
		Tuple2 body0 body1 -> run frame body0 body1;
	};
 };


-- | Main loop.
run :: 	Frame -> Array Body -> Array Body -> ();
run 	frame body0 body1
 = match {
-- 	| frameCount > frameCount_max
--	= ();
	
	\= do {	
		frame.clear (frame_color 0 0 0);
		mapArrayIx_ (\x -> x.update body0) body1;

	
		draw_force frame body1 0 0;

		mapArray_   (\x -> x.clampPos)	body1;
		mapArray_   (\x -> x.draw frame)	body1;

--		frameCount += 1;

	 	frame.update;
		usleep 1#;

		run frame body1 body0;
	};
 };


-- | Initialise world.
initBodies ()
 = do {	
	-- bodies
	bodies 
	 = 	[ newBody (Vec2 200.0 300.0) (Vec2 (0.0 - 0.5)	0.0)
		, newBody (Vec2 280.0 350.0) (Vec2  0.5		0.0)
		, newBody (Vec2 520.0 200.0) (Vec2  0.0         1.0)
	 	, newBody (Vec2 100.0 300.0) (Vec2  0.0        (0.0 - 1.0))
		, newBody (Vec2 280.0 450.0) (Vec2  1.0         1.0)
		, newBody (Vec2 020.0 200.0) (Vec2  0.0         0.0) ];

		
	body0	= array_new (length bodies) (errorNoEff @ "elem not initialised");
	zipWith_ (\b i -> body0 #(i) #= b)
		bodies [0 .. array_size body0 -1];


	-- next positions
	body1	= array_new (length bodies) (errorNoEff @ "elem not initialised");

	map_	(\i -> body1 #(i) #= newBody (Vec2 0.0 0.0) (Vec2 0.0 0.0))
		[0.. array_size body1 - 1];
		

	(body0, body1);
 };


-- | Draw the forces (unoptimised version)
--   Creates an intermediate list of Vec2s and then sums them.
--
draw_force :: Frame -> Array Body -> Int -> Int -> ();
draw_force frame body x y
 = match {
 	| x >= 600	= draw_force frame body 0 	(y + draw_force_step);
	| y >= 600	= ();
	
	\= do {
		forceV	= sum&{Vec2 Float}
			$ mapArrayToList
				(\b -> body_forceVec 
						1.0 (b.mass)
						(toFloat x) (toFloat y)
						b.pos.x     b.pos.y)
			$ body;

		forceS	= forceV.magnitude;
		fS	= log forceS + 6.0;
		color	= forceColor fS;
				
		frame.point  
			x (frame.sizeY - y)
			color;
			
		draw_force frame body (x + draw_force_step) y;
	};
 };


-- | Choose a color to render this force
--
forceColor fS
 = match {
	| fS < 0.0	= frame_color 0 0 0;

	| fS < 1.0	
	= do {	x	= fS;
		c	= truncate (x * 255.0);
		frame_color 0 0 c;
	};
		
	| fS < 2.0
	= do {	x	= fS - 1.0;
		c	= truncate (x * 255.0);
		frame_color 0 c (255 - c);
	};

	| fS < 3.0
	= do {	x	= fS - 2.0;
		c	= truncate (x * 255.0);
		frame_color c (255 - c) 0;
	};

	| fS < 4.0
	= do {	x	= fS - 3.0;
		c	= truncate (x * 255.0);
		frame_color (255 - c) c c;
	};

	| fS < 5.0
	= do {	x	= fS - 4.0;
		c	= truncate (x * 255.0);
		frame_color c (255 - c) c;
	};
		
				
	\= 	frame_color 255 255 255;
 };
					


-- Body -----------------------------------------------------------------------------
data Body %r1 

	-- Bodies move around the world.
	= Body {
		mass	:: Float %r1;
		pos	:: Vec2 %r1 (Float %r1);
		vel	:: Vec2 %r1 (Float %r1);
		acc	:: Vec2 %r1 (Float %r1);
	}

	-- Pillars influence bodies, but don't move themselves.
	| Pillar {
		mass	:: Float %r1;
		pos	:: Vec2 %r1 (Float %r1);
	};


project Body where
{
	force2 :: Body -> Body -> Vec2 Float;
	force2 body0 body1
	 = body_forceVec 
	 	body0.mass body1.mass 
		body0.pos.x body0.pos.y
		body1.pos.x body1.pos.y;

	show b
	 = case b of {
 		Body mass pos vel acc
			-> "Body " 
				% show mass 
				% " (" % pos.show % ")"
				% " (" % vel.show % ")";
 	 };


	pulse :: Body -> ();
	pulse ^body
	 = do {	_vel += _acc;
		_pos += _vel;
	 };


	update :: Body -> Array Body -> Int -> ();
	update	^b1 body0 i
	 = do {

	 	-- copy the old body info
		b0	= body0.(i);
		_mass	:= b0.mass;
	
		-- calculate force on this body.
		fV	= body_sumForces body0 i;
	
		time_compression = 1.0;
		-- acc = force / mass
		_acc 	:= (Vec2 (0.0 - fV.x / b0.mass) (0.0 - fV.y / b0.mass));
		_vel 	:= (b0.vel + (_acc.muls time_compression));
		_pos 	:= (b0.pos + (_vel.muls time_compression));
	 };


	clampPos :: Body -> ();
	clampPos	^b
	 = do {	
	 	when (_pos.x < 0.0) 
			_pos.x += 600.0;
	
	 	when (_pos.x > 600.0)
			_pos.x += 0.0 - 600.0;

	 	when (_pos.y < 0.0)
			_pos.y += 600.0;

	 	when (_pos.y > 600.0)
			_pos.y += 0.0 - 600.0;
	 };


	draw :: Body -> Frame -> ();
	draw body frame
	 = match {
	 	| Body mass pos vel acc	<- body
		, Vec2 pX pY		<- pos
		= if   (truncate pX < 0) || (truncate pX > worldSize.x) 
		    || (truncate pY < 0) || (truncate pY > worldSize.y)
		    then ()
		    else do {
			frame.circle 10
				(truncate pX) (truncate pY)
				20
				(frame_color 255 255 255);
		
		    };
	 };	


}


body_sumForces 
 ::	Array Body -> Int -> Vec2 Float;

body_sumForces body i 
 	= sum&{Vec2 Float}
	$ map (body.(i).force2)
	$ map (index body) 
	$ deleteF (==) [0.. array_size body - 1] i;
	

body_forceVec 
 	:: Float -> Float 
 	-> Float -> Float 
	-> Float -> Float 
	-> Vec2 Float;


body_forceVec m1 m2 x1 y1 x2 y2
 = do {
 	dx	= x2 - x1;
	dy	= y2 - y1;
	
 	d2	= dx * dx  +  dy * dy;
	d	= sqrt d2;

	attract_force	= m1 * (m2 / d2);
	forceS		= if d < attract_range
				then 	attract_force * (d / attract_range) 
				   - 	(attract_force * (attract_range / d))
				else attract_force;

	theta	= (Vec2 dx dy).angle;
	forceV	= Vec2 (forceS * cos theta) (forceS * sin theta);
	forceV;
 };
