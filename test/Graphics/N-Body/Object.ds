
-- Testing out
--	Fix GC for anchored arrays.
--	Use/update of data with multiple alternatives.
--	case of case optimisation.
--	work pi into this somehow, fix up top level regions.
--	have tasty mutable data that the full laziness transform will lift if not careful.
--	Use object syntax.
--	Later: unboxed vectors?
--	Add void types, to avoid having to add region annots to type sigs.
--	BUGS: can't use name 'force' locally. Conflicts with thunk forcing function.
--
--	in forceBetween , we're not forcing possible thunks read from body structs.
--	add pass to suspend all possible non-effectful applications.
--
--	When id.field returns 'ambiguous projection'.. should return type conflict.
--	Unbox truncate/toFloat
--

import Graphics.Render;
import Data.Array;
import DDC.Runtime;

-----
pi 		= 3.1415926536;
worldSize	= Vec2 600 600;
newBody pos vel	= Body 100.0 pos vel (Vec2 0.0 0.0);


main ()
 = topHandle nbody;


initBodies ()
 = do {	
	-- bodies
	bodies 
	 = 	[ newBody (Vec2 200.0 300.0) (Vec2 (0.0 - 0.5)	0.0)
		, newBody (Vec2 280.0 350.0) (Vec2  0.5		0.0)
		, newBody (Vec2 520.0 200.0) (Vec2  0.0         1.0)
	 	, newBody (Vec2 100.0 300.0) (Vec2  0.0        (0.0 - 1.0))
		, newBody (Vec2 280.0 450.0) (Vec2  1.0         1.0)
		, newBody (Vec2 020.0 200.0) (Vec2  0.0         0.0) ];

		
	body0	= array_new (length bodies) (errorNoEff @ "elem not initialised");
	zipWith_ (\b i -> body0 #(i) #= b)
		bodies [0 .. array_size body0 -1];


	-- next positions
	body1	= array_new (length bodies) (errorNoEff @ "elem not initialised");

	map_	(\i -> body1 #(i) #= newBody (Vec2 0.0 0.0) (Vec2 0.0 0.0))
		[0.. array_size body1 - 1];
		

	(body0, body1);
 };


-----
nbody ()
 = do {	frame	= frame_new "N-Body" 600 600;
	case initBodies () of {
		Tuple2 body0 body1 -> run frame body0 body1;
	};
 };

 
-----
frameCount		= 0;
frameCount_max		= 10;
time_compression	= 1.0;
attract_range		= 20.0;

run frame body0 body1
 = match {
-- 	| frameCount > frameCount_max
--	= ();
	
	\= do {	
		frame_clear frame (frame_color 0 0 0);

		mapArrayIx_ body0.update body1;
	
		draw_force frame body1 0 0;

		mapArray_   clampPos&{Body} 	body1;
		mapArray_   (draw_body frame)   body1;

		frameCount += 1;

	 	frame_update frame;
		usleep 1#;

		run frame body1 body0;
	};
 };
	

draw_body frame body
 = match {
 	| Body mass pos vel acc	<- body
	, Vec2 pX pY		<- pos
	= if   (truncate pX < 0) || (truncate pX > worldSize.x) 
	    || (truncate pY < 0) || (truncate pY > worldSize.y)
	    then ()
	    else do {
		frame_circle frame 10
			(truncate pX) (truncate pY)
			20
			(frame_color 255 255 255);
		
	    };
 };	


frame_circle frame ps pX pY r color
 = do {	
	rF	= toFloat r;

 	points	
	 = 	maps 	[0..ps]
			(\x -> do {
				theta	= (toFloat x) / (toFloat ps) * 2.0 * pi;
				(rF * cos theta, rF * sin theta); 
			});
	
	maps_ 	points
		(\case {
			Tuple2 x y 
			 ->  frame_point frame
				(pX + truncate x) (frame.sizeY - (pY + truncate y))
				color; });
 };


draw_force_step	= 4;
draw_force frame body x y
 = match {
 	| x >= 600	= draw_force frame body 0 	(y + draw_force_step);
	| y >= 600	= ();
	
	\= do {
		forceV	= sum&{Vec2 Float}
			$ mapArrayToList
				(\b -> forceVec&{Body}
						1.0 (body_mass b)
						(toFloat x) (toFloat y)
						b.pos.x     b.pos.y)
			$ body;

		forceS	= mag&forceV;
		fS	= log forceS + 6.0;
		color	= forceColor fS;
				
		frame_point frame 
			x (frame.sizeY - y)
			color;
			
		draw_force frame body (x + draw_force_step) y;
	};
 };

				
forceColor fS
 = match {
	| fS < 0.0	= frame_color 0 0 0;

	| fS < 1.0	
	= do {	x	= fS;
		c	= truncate (x * 255.0);
		frame_color 0 0 c;
	};
		
	| fS < 2.0
	= do {	x	= fS - 1.0;
		c	= truncate (x * 255.0);
		frame_color 0 c (255 - c);
	};

	| fS < 3.0
	= do {	x	= fS - 2.0;
		c	= truncate (x * 255.0);
		frame_color c (255 - c) 0;
	};

	| fS < 4.0
	= do {	x	= fS - 3.0;
		c	= truncate (x * 255.0);
		frame_color (255 - c) c c;
	};

	| fS < 5.0
	= do {	x	= fS - 4.0;
		c	= truncate (x * 255.0);
		frame_color c (255 - c) c;
	};
		
				
	\= 	frame_color 255 255 255;
 };
					
 	
mapArrayToList  f array = mapArrayToList' f array 0;
mapArrayToList' f array i
 = if i >= array_size array
 	then []
	else f (array.(i)) : mapArrayToList' f array (i + 1);
	
body_mass :: 	Body -> Float;
body_mass b
 = b.mass;

sumForces 
 ::	Array Body -> Int -> Vec2 Float;

sumForces body i 
 	= sum&{Vec2 Float}
	$ map (force2&{Body} (body.(i)))
	$ map (index body) 
	$ deleteF (==) [0.. array_size body - 1] i;


-----------------------------------------------------------------------------
-- Body
--
data Body %r1 

	-- Bodies move around the world.
	= Body {
		mass	:: Float %r1;
		pos	:: Vec2 %r1 (Float %r1);
		vel	:: Vec2 %r1 (Float %r1);
		acc	:: Vec2 %r1 (Float %r1);
	}

	-- Pillars influence bodies, but don't move themselves.
	| Pillar {
		mass	:: Float %r1;
		pos	:: Vec2 %r1 (Float %r1);
	};


project	Body where 
{
	show :: Body -> String;
	show 
	 = \case {
	 	Body mass pos vel acc
			-> "Body " 
				% showFloat mass 
				% " (" % pos.show	% ")"
				% " (" % pos.show	% ")";
	 };


	clampPos :: Body -> ();
	clampPos ^b
	 = do {	
	 	when (_pos.x < 0.0) 
			_pos.x %:= _pos.x + 600.0;
	
	 	when (_pos.x > 600.0)
			_pos.x %:= _pos.x - 600.0;

	 	when (_pos.y < 0.0)
			_pos.y %:= _pos.y + 600.0;

	 	when (_pos.y > 600.0)
			_pos.y %:= _pos.y - 600.0;
	 };
	

	pulse :: Body -> ();
	pulse ^b 
	 = do {	_vel.acc _acc;
		_pos.acc _vel;
	 };

	force2 
	 ::	Body ->	Body -> Vec2 Float;

	force2	body0	body1
	 = forceVec{Body}
	 	body0.mass body1.mass 
		body0.pos.x body0.pos.y
		body1.pos.x body1.pos.y;


	update :: Body -> Array Body -> Int -> ();
	update	^b1 body0 i
	 = do {

	 	-- copy the old body info
		b0	= body0.(i);
		_mass	%:= b0.mass;
	
		-- calculate force on this body.
		fV	= body_sumForces body0 i;
	
		-- acc = force / mass
		update & _acc (Vec2 (0.0 - fV.x / b0.mass) (0.0 - fV.y / b0.mass));
		update & _vel (b0.vel + (muls & _acc time_compression));
		update & _pos (b0.pos + (muls & _vel time_compression));
	 };


	forceVec 
	 	:: Float -> Float 
	 	-> Float -> Float 
		-> Float -> Float 
		-> Vec2 Float;

	forceVec m1 m2 x1 y1 x2 y2
	 = do {
	 	dx	= x2 - x1;
		dy	= y2 - y1;
	
	 	d2	= dx * dx  +  dy * dy;
		d	= sqrt d2;

		attract_force	= m1 * (m2 / d2);
		forceS	= if d < attract_range
				then 	attract_force * (d / attract_range) 
				   - 	(attract_force * (attract_range / d))
				else attract_force;

		theta	= angle & (Vec2 dx dy);
		forceV	= Vec2 (forceS * cos theta) (forceS * sin theta);
		forceV;
	 };
 };



-------------------------------------------------------------------------
-- Vec2
--

data Vec2 %r1 a
	= Vec2 {
		x	:: a;
		y	:: a;
	};

project Vec2 Float where
{
	show (Vec2 x y)	
	 = "Vec2 " % showFloat x % " " % showFloat y;
	
	angle (Vec2 x y)	
	 = if x < 0.0 
	 	then pi + atan (y / x)
		else atan (y / x);
	
	add 	(Vec2 x1 y1) (Vec2 x2 y2)  	
		= Vec2 (x1 + x2) (y1 + y2);

	muls (Vec2 x1 y1) s
		= Vec2 (s * x1) (s * y1);

	acc 	(Vec2 x1 y1) (Vec2 x2 y2)
	 = do {	
	 	x1	%+= x2;
	 	y1	%+= y2;
	 };

	update (Vec2 x1 y1) (Vec2 x2 y2)
	 = do {	x1	%:= x2;
	 	y1	%:= y2;
	 };

	mag (Vec2 x y)
	 = sqrt (x * x + y * y);
 
	sum xx	
	 = Vec2 (foldl (+) 0.0 $ map (\v -> v.x) xx) 
		(foldl (+) 0.0 $ map (\v -> v.y) xx);
}
 


-----
radToDeg r	= (180.0 / pi) 		* r;
degToRad d	= (pi    / 180.0)	* d;


instance Num (Vec2 Float) where
{
	(+)	= add&{Vec2 Float};
}


-----
(%+=)	x inc	= x %:= x + inc;
(+=)	x inc	= x :=  x + inc;
