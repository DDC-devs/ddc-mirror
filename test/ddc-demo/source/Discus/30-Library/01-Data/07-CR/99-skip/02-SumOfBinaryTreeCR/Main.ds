module Main
import System.IO.Console
import Class.Show
import Class.Numeric
import Class.Ord
import Data.Numeric.Nat
import Data.Function
import Data.Ref
import Data.CompactRegion


import foreign c value
 ddcPerformGC : Unit -> Unit

where

data BinaryTree 
   = Branch BinaryTree Nat BinaryTree
    |Leaf 

-- operations
sumOfTree (t:BinaryTree) : Nat
 = case t of
      Leaf -> 0
      Branch l v r -> sumOfTree l + sumOfTree r + v

headOfTree (t:BinaryTree) : Nat
 = case t of 
      Leaf -> 0
      Branch _ v _ -> v

-- slow Fib
fib (a: Nat) : Nat
 = case a of
    0 -> 1
    1 -> 1
    _ -> (fib (a-1)) + (fib (a-2))

-- allocation functions
allocTree {@r: Region} (cr: CR r) : S (Write r + Console) BinaryTree
 = do allocTreePrim {@r} cr 0 13

allocTreePrim {@r: Region} (cr: CR r) (currLevel : Nat) (maxLevel : Nat) : S (Write r + Console) BinaryTree
 = do case currLevel == maxLevel of
        True  -> Leaf 
        False -> do newL = storeCR cr (allocTreePrim cr (currLevel + 1) maxLevel)
                    newR = storeCR cr (allocTreePrim cr (currLevel + 1) maxLevel)
                    Branch newL 1 newR


main ()
 = mutable r1 in  
    do 
       cr = allocCR {@r1} ()
       t = allocTree cr
       fib 20
       headOfTree t
       deleteCR cr
       writel $ "done"
