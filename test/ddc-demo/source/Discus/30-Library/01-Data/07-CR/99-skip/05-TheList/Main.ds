module Main
import System.IO.Console
import Class.Show
import Class.Numeric
import Class.Ord
import Data.Numeric.Nat
import Data.Function
import Data.Ref
import Data.CompactRegion

import foreign c value

 ddcTraceObj            : [r: Region]. Bool# -> Bool# -> DList -> Unit
 ddcTraceCRByHandle     : [r: Region]. CR r -> Unit


where

data DList = DNil | DCons Nat DList

appendD (arg : DList)  (arg1: DList) : DList
 = do case arg of
        DNil -> arg1
        DCons x xs -> DCons x (appendD xs arg1)

countList {@r: Region} (cr : CR r) (curr : Nat ) (max : Nat) : S (Write r) DList
 = do case curr == max of
        True -> storeCRIgnoreRef cr DNil
        False -> storeCRIgnoreRef cr $ DCons curr (countList cr (curr+1) max)

sumOfList (list : DList) : Nat
 = do case list of
        DNil -> 0
        DCons x xs -> sumOfList xs + x


countListPure (curr : Nat) (max : Nat) : DList
 = do case curr == max of
        True -> DNil
        False -> DCons curr (countListPure (curr+1) max)

-- slow Fib
fib (a: Nat) : Nat
 = case a of
    0 -> 1
    1 -> 1
    _ -> (fib (a-1)) + (fib (a-2))


main ()
 = mutable r1 in  
    do 
       cr = allocCR {@r1} ()
       a = countList cr 0 20000
       b = countList cr 0 20000
       c = appendD a b
      --  ddcTraceObj {@r1} True True l
      --  ddcTraceCRByHandle cr
       writel $ ""
       writel $ "OK, now caulculate the fib."
       fib 10000
      
       
       writel $ "done"


-- main ()
--  = mutable r1 in  
--     do 
--        a = countListPure 0 20000
--        b = countListPure 0 20000
--        c = appendD a b
--        writel $ ""
--        writel $ "OK, now caulculate the fib."
--        fib 10000
      
       
--        writel $ "done"
