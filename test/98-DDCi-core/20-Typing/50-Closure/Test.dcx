
-- The inner function uses a value in region R0#.
:check\
 let x : Int R0# = 5 {R0#} () in\
 \(z:Unit). addInt {:R0# R0# R1#:} x x


-- The inner function uses a value in region R0#.
:check\
 let x : Int R0# = 5 {R0#} () in\
 \(z:Unit). addInt {:R0# R0# R1#:} x x


-- Inner function uses the bound value, but it is not free in the closure.
:check\
 \(x:Int R0#). addInt {:R0# R0# R1#:} x x


-- Inner function uses the bound value, and it is free in the closure.
:check\
 \(x:Int R0#). \(y:Int R1#). addInt {:R0# R1# R2#:} x y


-- Multiple levels of binding.
:check\
 \(x:Int R0#). \(y:Int R1#). \(z: Int R2#).\
   addInt {:R3# R0# R4#:} (addInt {:R1# R2# R3#:} y z) x


-- Inner function has a value in the closure whose type contains
-- a higher kinded type variable.
:check\
 \(a:% ~> *). \(x:a R1#). \(f: a R1# -> a R1#). f x


-- Inner funtion has a value in the clousre whose type contains
-- a closure variable.
:check\
 \(e:!). \(c:$). \(f: Unit -(e | c)> Unit). \(x: Unit). f x


-- Like above, and we've also instantiated the variable with a
-- pre-trimmed closure.
:check\
 (\(e:!). \(c:$). \(f: Unit -(e | c)> Unit). \(x: Unit). f x)\
 {Read R0#} {Use R1#}

-- Like above, and we've also instantiated the variable with a closure that
-- could be trimmed, but because it's explicit in the term we don't do so. 
:check\
 (\(e:!). \(c:$). \(f: Unit -(e | c)> Unit). \(x: Unit). f x)\
 {Read R0#} {DeepUse (Int R1#)}

