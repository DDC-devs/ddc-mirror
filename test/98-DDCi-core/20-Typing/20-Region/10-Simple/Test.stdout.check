-- Parsing of let region with no witnesses
letregion r1 in ()
::  Unit
:!: !0
:$: $0

-- Parsing of let region with some witnesses
letregion r1 with {w1 : Const r1} in ()
::  Unit
:!: !0
:$: $0

letregion r1 with {w1 : Const r1; w2 : Manifest r1} in ()
::  Unit
:!: !0
:$: $0

-- Use the bound region in the body of the expression.
letregion r1 in addInt [r1] [r1] [R2#] (2 [r1] ()) (3 [r1] ())
::  Int R2#
:!: Alloc R2#
:$: Use R2#

-- As above, but with debruijn indices.
letregion ^ in addInt [^0] [^0] [R2#] (2 [^0] ()) (3 [^0] ())
::  Int R2#
:!: Alloc R2#
:$: Use R2#

-- Error: Withregion must contain a region variable or constructor.
Withregion handle does not have region kind.
   Region var or ctor: e
             has kind: !
       but it must be: %
        when checking: withregion e in ()

