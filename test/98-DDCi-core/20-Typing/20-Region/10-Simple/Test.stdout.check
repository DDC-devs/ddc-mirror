-- Parsing of let region with no witnesses
letregion r1 in ()
::  Unit
:!: !0
:$: $0

-- Parsing of let region with some witnesses
letregion r1 with {w1 : Const r1} in ()
::  Unit
:!: !0
:$: $0

letregion r1 with {w1 : Const r1; w2 : Manifest r1} in ()
::  Unit
:!: !0
:$: $0

-- Use the bound region in the body of the expression.
letregion r1 in addInt {r1} {r1} {R2#} (2 {r1} ()) (3 {r1} ())
::  Int R2#
:!: Alloc R2#
:$: Use R2#

-- As above, but with debruijn indices.
letregion ^ in addInt {^0} {^0} {R2#} (2 {^0} ()) (3 {^0} ())
::  Int R2#
:!: Alloc R2#
:$: Use R2#

-- Do the reduction
letregion r1 in addInt {r1} {r1} {R2#} (2 {r1} ()) (3 {r1} ())
withregion R1# in addInt {R1#} {R1#} {R2#} (2 {R1#} ()) (3 {R1#} ())
withregion R1# in addInt {R1#} {R1#} {R2#} L1# (3 {R1#} ())
withregion R1# in addInt {R1#} {R1#} {R2#} L1# L2#
withregion R1# in L3#
L3#
STORE
 NextLoc: 4
 NextRgn: 2
 Regions: {R2#}
 Global:  {}

 Binds:
 L3#:R2# -> OBJ 5

