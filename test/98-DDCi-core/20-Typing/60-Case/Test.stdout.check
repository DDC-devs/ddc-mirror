-- Error: types of alternatives are not identical.
Mismatch in alternative result types.
   Type of alternative: Int R0#
        does not match: Unit
         when checking: case 5 [R0#] () of {0  -> 0 [R0#] (); 1  -> ()}

-- Error: discriminant type is not a data type.
Discriminant of case expression is not algebraic data.
     Discriminant type: Unit -> Unit
         when checking: case \(x : Unit).x of {_ -> ()}

-- Error: pattern and discriminant types don't match.
Cannot instantiate constructor type with discriminant type args.
 Either the constructor has an invalid type,
 or the type of the discriminant does not match the type of the pattern.
      Constructor type: List R0# (Int R0#)
     Discriminant type: Unit
         when checking: case xx1 of {()  -> ()}

-- Error: pattern binds more fields than provided by constructor.
Pattern has more binders than there are fields in the constructor.
     Contructor: Cons
            has: 2 fields
  but there are: 3 binders in the pattern
  when checking: case xx of {Nil  -> (); Cons x xs ys -> ()}

-- Error: annotation on pattern variable does not match field type
--        of constructor.
Annotation on pattern variable does not match type of field.
       Annotation type: Unit
            Field type: Int R0#
         when checking: case xx of {Nil  -> (); Cons (x : Unit) xs -> ()}

-- Ok: check that vars in alts are masked from closure
let xx = Nil [R0#] [Int R0#] () in case xx of {Nil  -> 0 [R0#] (); Cons x xs -> x}
::  Int R0#
:!: Alloc R0#
:$: Use R0#

