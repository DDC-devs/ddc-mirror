{-# OPTIONS -fwarn-unused-imports #-}

-- | Wrappers for compiler stages dealing with LLVM code.
module Main.Llvm
	(compileViaLlvm)
where

-- main stages
import Main.Setup
import Main.Sea
import Main.Util

import DDC.Main.Error
import DDC.Main.Pretty
import DDC.Var

import qualified Module.Scrape		as M
import qualified DDC.Main.Arg		as Arg
import qualified DDC.Config.Version	as Version

import Llvm
import Llvm.Invoke
import Llvm.GhcReplace.Unique

import Sea.Exp
import Sea.Util				(eraseAnnotsTree)
import Sea.Pretty

import Util
import qualified Data.Map		as Map
import qualified Config.Config		as Config

stage = "Main.Llvm"

compileViaLlvm
	:: (?verbose :: Bool, ?pathSourceBase :: FilePath)
	=> Setup			-- ^ Compile setup.
	-> ModuleId			-- ^ Module to compile, must also be in the scrape graph.
	-> Tree ()			-- ^ The Tree for the module.
	-> FilePath			-- ^ FilePath of source file.
	-> [FilePath]			-- ^ C import directories.
	-> [FilePath]			-- ^ C include files.
	-> Map ModuleId [a]		-- ^ Module import map.
	-> Bool				-- ^ Module defines 'main' function.
	-> M.Scrape			-- ^ ScrapeGraph of this Module.
	-> Map ModuleId M.Scrape	-- ^ Scrape graph of all modules reachable from the root.
	-> Bool				-- ^ Whether to treat a 'main' function defined by this module
					--	as the program entry point.
	-> IO Bool

compileViaLlvm
	setup modName eTree pathSource importDirs includeFilesHere importsExp
	modDefinesMainFn sRoot scrapes_noRoot blessMain
 = do
	let ?args		= setupArgs setup

	outVerb $ ppr $ "  * Write C header\n"
	writeFile (?pathSourceBase ++ ".ddc.h")
		$ makeSeaHeader
			eTree
			pathSource
			(map ((\(Just f) -> f) . M.scrapePathHeader)
					$ Map.elems scrapes_noRoot)
			includeFilesHere

	outVerb $ ppr $ "  * Generating LLVM IR code\n"
	llvmSource	<- outLlvm modName eTree pathSource

	writeFile (?pathSourceBase ++ ".ddc.ll")
			$ ppLlvmModule llvmSource

	invokeLlvmCompiler ?pathSourceBase []
	invokeLlvmAssembler ?pathSourceBase []

	return modDefinesMainFn


-- | Create LLVM source files
outLlvm
	:: (?args :: [Arg.Arg])
	=> ModuleId
	-> (Tree ())		-- sea source
	-> FilePath		-- path of the source file
	-> IO LlvmModule

outLlvm moduleName eTree pathThis
 = do
	-- Break up the sea into parts.
	let 	([ 	seaProtos, 		seaSupers
		 , 	seaCafProtos,		seaCafSlots,		seaCafInits
		 ,      seaData
		 , 	seaHashDefs ], junk)

		 = partitionFs
			[ (=@=) PProto{}, 	(=@=) PSuper{}
			, (=@=) PCafProto{},	(=@=) PCafSlot{},	(=@=) PCafInit{}
			, (=@=) PData{}
			, (=@=) PHashDef{} ]
			eTree

	when (not $ null junk)
	 $ panic "Main.Llvm" $ "junk sea bits = " ++ show junk ++ "\n"

	-- Build the LLVM code
	let comments =	[ "-----------------------"
			, "      source: " ++ pathThis
			, "generated by: " ++ Version.ddcName
			, "" ]

	let aliases = [ ("struct.Obj", ddcObjType) ]

	let code = seaCafInits ++ seaSupers

        let fwddecls	= []	-- Need this?

	let globals	= moduleGlobals
			++ (catMap seaToLlvmGlobal $ eraseAnnotsTree seaCafSlots)

        decls		<- catMapM seaToLlvmDecls $ eraseAnnotsTree code

	return $ LlvmModule comments aliases globals fwddecls decls

{-=
seaToLlvm :: Top (Maybe ()) -> IO [LlvmFunction]
seaToLlvm sea
 = do	func <- newUnique
 	blk1 <- newUnique
	return $ [ LlvmFunction
		(LlvmFunctionDecl ("f" ++ (show func)) External CC_Ccc LMVoid FixedArgs [] Nothing)
		[]		-- funcArgs
		[]		-- funcAttrs
		Nothing		-- funcSect
		[ LlvmBlock blk1 [ Return Nothing ] ]	-- funcBody
		]
=-}


seaToLlvmDecls :: Top (Maybe a) -> IO [LlvmFunction]
seaToLlvmDecls (PCafInit v t ss)
 = panic stage "Implement  'seaToLlvmDecls (PCafInit v t ss)'"


seaToLlvmDecls (PSuper v p t ss)
 = do	blk1 <- newUnique
	return $ [ LlvmFunction
		(LlvmFunctionDecl (varSeaName v) External CC_Ccc (toLlvmType t) FixedArgs (map toParams p) Nothing)
		(map (seaVar True . fst) p)	-- funcArgs
		[]			-- funcAttrs
		Nothing			-- funcSect
		[ LlvmBlock blk1 [ Return Nothing ] ]	-- funcBody
		]


toParams :: (Var, Type) -> LlvmParameter
toParams (v, t) = (toLlvmType t, [])


seaToLlvmGlobal :: Top (Maybe a) -> [LMGlobal]
seaToLlvmGlobal (PCafSlot v t)
 =	let	tt = LMPointer (toLlvmType t)
		var = LMGlobalVar
 			("_ddcCAF_" ++ varSeaName v)	-- Variable name
			tt				-- LlvmType
			Internal			-- LlvmLinkageType
			Nothing				-- LMSection
			ptrAlign			-- LMAlign
			False				-- LMConst
	in [(var, Just (LMStaticLit (LMNullLit tt)))]


moduleGlobals :: [LMGlobal]
moduleGlobals
 = [	( LMGlobalVar
 		"_ddcSlotPtr"
		(LMPointer (LMPointer (toLlvmType TObj)))
		External
		Nothing
		ptrAlign
		False
		, Nothing )
	]

    
--------------------------------------------------------------------------------
-- Helpers.

toLlvmType :: Type -> LlvmType
toLlvmType t
 = case t of
	TObj -> LMPointer ddcObj

	_ -> panic stage $ "toLlvmType " ++ show t ++ "\n"


ddcObjType :: LlvmType
ddcObjType = LMStruct [ i32 ]

ddcObj :: LlvmType
ddcObj = LMAlias ("struct.Obj", ddcObjType)

varSeaName :: Var -> String
varSeaName v = seaVar False v

ptrAlign :: Maybe Int
ptrAlign = Just Config.pointerBytes


