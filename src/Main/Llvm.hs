{-# OPTIONS -fwarn-unused-imports #-}

-- | Wrappers for compiler stages dealing with LLVM code.
module Main.Llvm
	(compileViaLlvm)
where

-- main stages
import Main.Setup
import Main.Sea
import Main.Util

import DDC.Main.Error
import DDC.Main.Pretty
import DDC.Var

import qualified Module.Scrape		as M
import qualified DDC.Main.Arg		as Arg
import qualified DDC.Config.Version	as Version

import Llvm
import Llvm.Invoke
import Llvm.GhcReplace.Unique

import Sea.Exp
import Sea.Util				(eraseAnnotsTree)

import Util
import qualified Data.Map		as Map

stage = "Main.Llvm"

compileViaLlvm
	:: (?verbose :: Bool, ?pathSourceBase :: FilePath)
	=> Setup			-- ^ Compile setup.
	-> ModuleId			-- ^ Module to compile, must also be in the scrape graph.
	-> Tree ()			-- ^ The Tree for the module.
	-> FilePath			-- ^ FilePath of source file.
	-> [FilePath]			-- ^ C import directories.
	-> [FilePath]			-- ^ C include files.
	-> Map ModuleId [a]		-- ^ Module import map.
	-> Bool				-- ^ Module defines 'main' function.
	-> M.Scrape			-- ^ ScrapeGraph of this Module.
	-> Map ModuleId M.Scrape	-- ^ Scrape graph of all modules reachable from the root.
	-> Bool				-- ^ Whether to treat a 'main' function defined by this module
					--	as the program entry point.
	-> IO Bool

compileViaLlvm
	setup modName eTree pathSource importDirs includeFilesHere importsExp
	modDefinesMainFn sRoot scrapes_noRoot blessMain
 = do
	let ?args		= setupArgs setup

	outVerb $ ppr $ "  * Write C header\n"
	writeFile (?pathSourceBase ++ ".ddc.h")
		$ makeSeaHeader
			eTree
			pathSource
			(map ((\(Just f) -> f) . M.scrapePathHeader)
					$ Map.elems scrapes_noRoot)
			includeFilesHere

	outVerb $ ppr $ "  * Generating LLVM IR code\n"
	llvmSource	<- outLlvm modName eTree pathSource

	writeFile (?pathSourceBase ++ ".ddc.ll")
			$ ppLlvmModule llvmSource

	invokeLlvmCompiler ?pathSourceBase []
	invokeLlvmAssembler ?pathSourceBase []

	return modDefinesMainFn


-- | Create LLVM source files
outLlvm
	:: (?args :: [Arg.Arg])
	=> ModuleId
	-> (Tree ())		-- sea source
	-> FilePath		-- path of the source file
	-> IO LlvmModule

outLlvm moduleName eTree pathThis
 = do
	-- Break up the sea into parts.
	let 	([ 	seaProtos, 		seaSupers
		 , 	seaCafProtos,		seaCafSlots,		seaCafInits
		 ,      seaData
		 , 	seaHashDefs ], junk)

		 = partitionFs
			[ (=@=) PProto{}, 	(=@=) PSuper{}
			, (=@=) PCafProto{},	(=@=) PCafSlot{},	(=@=) PCafInit{}
			, (=@=) PData{}
			, (=@=) PHashDef{} ]
			eTree

	when (not $ null junk)
	 $ panic "Main.Llvm" $ "junk sea bits = " ++ show junk ++ "\n"

	-- Build the LLVM code
	let comments =	[ "-----------------------"
			, "      source: " ++ pathThis
			, "generated by: " ++ Version.ddcName
			, "" ]

	let code = seaCafInits ++ seaSupers

        let fwddecls	= []	-- Need this?

	globals		<- catMapM seaToLlvmGlobal $ eraseAnnotsTree seaCafSlots

        decls		<- catMapM seaToLlvm $ eraseAnnotsTree code

	return $ LlvmModule comments globals fwddecls decls


seaToLlvm :: Top (Maybe ()) -> IO [LlvmFunction]
seaToLlvm sea
 = do	func <- newUnique
 	blk1 <- newUnique
	return $ [ LlvmFunction
		(LlvmFunctionDecl ("f" ++ (show func)) External CC_Ccc LMVoid FixedArgs [] Nothing)
		[]		-- funcArgs
		[]		-- funcAttrs
		Nothing		-- funcSect
		[ LlvmBlock blk1 [ Return Nothing ] ]	-- funcBody
		]



seaToLlvmGlobal :: Top (Maybe a) -> IO [LMGlobal]
seaToLlvmGlobal (PCafSlot v t)
 = do	-- "Obj** " %>> "_ddcCAF_" % sV v % " = 0;\n"
	let tt = toLlvmType t
	let var = LMGlobalVar
 			("_ddcCAF_" ++ varName v)		-- Variable name
			tt			-- LlvmType
			Internal		-- LlvmLinkageType
			Nothing			-- LMSection
			(Just 4)		-- LMAlign
			False			-- LMConst
	return $! [(var, Just (LMStaticLit (LMNullLit tt)))]


toLlvmType :: Type -> LlvmType
toLlvmType t
 = case t of
	TObj -> LMPointer (LMPointer objectType)

	_ -> panic stage $ "toLlvmType " ++ show t ++ "\n"

objectType :: LlvmType
objectType = LMStruct [ i32 ]
