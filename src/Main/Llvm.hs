{-# LANGUAGE CPP #-}
{-# OPTIONS -fno-warn-unused-binds -fno-warn-type-defaults #-}

-- | Wrappers for compiler stages dealing with LLVM code.
module Main.Llvm
	(compileViaLlvm)
where

-- main stages
import Main.BuildFile
import Main.Setup
import Main.Sea
import Main.Util

import DDC.Base.SourcePos
import DDC.Main.Error
import DDC.Main.Pretty
import DDC.Sea.Exp
import DDC.Sea.Pretty
import DDC.Var

import qualified DDC.Module.Scrape	as M
import qualified DDC.Main.Arg		as Arg
import qualified DDC.Config.Version	as Version

import Llvm
import LlvmM
import Llvm.Assign
import Llvm.Exp
import Llvm.Func
import Llvm.GhcReplace.Unique
import Llvm.Invoke
import Llvm.Runtime
import Llvm.Util
import Llvm.Var

import Sea.Util				(eraseAnnotsTree)

import Util
import qualified Data.Map		as Map

import qualified Debug.Trace		as Debug


stage = "Main.Llvm"

debug = True

_trace s v
 =	if debug
	  then Debug.trace s v
	  else v


compileViaLlvm
	:: (?verbose :: Bool, ?pathSourceBase :: FilePath)
	=> Setup			-- ^ Compile setup.
	-> ModuleId			-- ^ Module to compile, must also be in the scrape graph.
	-> Tree ()			-- ^ The Tree for the module.
	-> Tree ()			-- ^ The constructor tags for imported modules.
	-> FilePath			-- ^ FilePath of source file.
	-> [FilePath]			-- ^ C import directories.
	-> [FilePath]			-- ^ C include files.
	-> Map ModuleId [a]		-- ^ Module import map.
	-> Bool				-- ^ Module defines 'main' function.
	-> M.Scrape			-- ^ ScrapeGraph of this Module.
	-> Map ModuleId M.Scrape	-- ^ Scrape graph of all modules reachable from the root.
	-> Bool				-- ^ Whether to treat a 'main' function defined by this module
					--	as the program entry point.
	-> IO Bool

compileViaLlvm
	setup modName eTree eCtorTags pathSource importDirs includeFilesHere importsExp
	modDefinesMainFn sRoot scrapes_noRoot blessMain
 = do
	let	?args		= setupArgs setup

	let	heapSize	= getValue buildStartHeapSize		sRoot
	let	slotStackSize	= getValue buildStartSlotStackSize	sRoot
	let	ctxStackSize	= getValue buildStartContextStackSize	sRoot

	outVerb $ ppr "  * Write C header\n"
	writeFile (?pathSourceBase ++ ".ddc.h")
		$ makeSeaHeader
			eTree
			pathSource
			(map (fromJust . M.scrapePathHeader) $ Map.elems scrapes_noRoot)
			includeFilesHere

	outVerb $ ppr "  * Generating LLVM IR code\n"

	llvmSource	<- evalStateT
				(outLlvm modName eTree eCtorTags pathSource importsExp modDefinesMainFn heapSize slotStackSize ctxStackSize)
				$ initLlvmState modName

	writeFile (?pathSourceBase ++ ".ddc.ll")
			$ pprStrPlain $ ppLlvmModule llvmSource

	invokeLlvmCompiler ?pathSourceBase []
	invokeLlvmAssembler ?pathSourceBase []

	return modDefinesMainFn


getValue :: (Build -> Maybe Integer) -> M.Scrape -> Integer
getValue func scrape
 = case M.scrapeBuild scrape of
	Nothing -> 0
	Just build -> fromMaybe 0 $ func build


-- | Create LLVM source files
outLlvm
	:: (?args :: [Arg.Arg])
	=> ModuleId
	-> Tree ()		-- sea source
	-> Tree ()		-- import Ctor tags
	-> FilePath		-- path of the source file
	-> Map ModuleId [a]
	-> Bool			-- is main module
	-> Integer
	-> Integer
	-> Integer
	-> LlvmM LlvmModule

outLlvm moduleName eTree eCtorTags pathThis importsExp modDefinesMainFn heapSize slotStackSize ctxStackSize
 = do
	-- Break up the sea into parts.
	let 	([ 	_seaProtos, 		seaSupers,		seaExterns
		 , 	_seaCafProtos,		seaCafSlots,		seaCafInits
		 ,	_seaData
		 , 	seaCtorTags ],		junk)

		 = partitionBy
			[ (=@=) PProto{}, 	(=@=) PSuper{}, 	(=@=) PExtern{}
			, (=@=) PCafProto{},	(=@=) PCafSlot{},	(=@=) PCafInit{}
			, (=@=) PData{}
			, (=@=) PCtorTag{} ]
			eTree

	unless (null junk)
		$ panic stage $ "junk sea bits = " ++ show junk ++ "\n"

	setTags		$ concatMap (\(PData a b) ->
				map (\ (v, c) -> (seaVar False v, ctorDefTag c)) $ Map.toList b)
			$ filter (PData{} =@=) eCtorTags

	setTags		$ map (\(PCtorTag s i) -> (s, i)) seaCtorTags

	-- Build the LLVM code
	let comments =	[ "---------------------------------------------------------------"
			, "      source: " ++ pathThis
			, "generated by: " ++ Version.ddcName
			, "" ]

	addAlias	("struct.File", ddcFile)
	addAlias	("struct.Obj", ddcObj)
	addAlias	("struct.Data", llvmTypeOfStruct ddcData)
	addAlias	("struct.DataRS", llvmTypeOfStruct ddcDataRS)
	addAlias	("struct.Thunk", llvmTypeOfStruct ddcThunk)
	addAlias	("struct.SuspIndir", llvmTypeOfStruct ddcSuspIndir)

	let isTFun x = case x of
			PExtern _ (TFun _ _)	-> True
			_			-> False

	let (funExterns, dataExterns)
			= partition isTFun $ eraseAnnotsTree seaExterns

	mapM_		addGlobalVar
				$ moduleGlobals
				++ map llvmOfSeaGlobal dataExterns
				++ map llvmOfSeaGlobal (eraseAnnotsTree seaCafSlots)

	mapM_		addGlobalFuncDecl $ map funcDeclOfExtern funExterns

	mapM_		llvmOfSeaDecls $ eraseAnnotsTree $ seaCafInits ++ seaSupers

	when modDefinesMainFn
			$ llvmMainModule moduleName (map fst $ Map.toList importsExp) heapSize slotStackSize ctxStackSize

	renderModule	comments


llvmOfSeaDecls :: Top (Maybe a) -> LlvmM ()
llvmOfSeaDecls (PSuper v p t ss)
 = do	startFunction
	mapM_ allocForParam p
	llvmOfFunc ss
	endFunction
		(LlvmFunctionDecl (seaVar False v) External CC_Ccc (toLlvmType t) FixedArgs (map llvmOfParams p) Nothing)
		(map (\ (v, _) -> "_p" ++ seaVar True v) p)	-- funcArgs
		[]				-- funcAttrs
		Nothing				-- funcSect


llvmOfSeaDecls (PCafInit v t ss)
 = panic stage "Implement 'llvmOfSeaDecls (PCafInit v t ss)'"

llvmOfSeaDecls x
 = panic stage $ "Implement 'llvmOfSeaDecls (" ++ show x ++ ")'"



llvmOfParams :: (Var, Type) -> LlvmParameter
llvmOfParams (v, t) = (toLlvmType t, [])


-- All SAuto vars need to be alloca-ed on the stack. There are two reasons for
-- this:
--
--    a) According to the comments in src/Sea/Slot.hs, in compiled tail
--       recursive functions there may be assignments to arguments in the
--       parameter list.
--
--    b) NAuto variables can appear on the LHS of an assignment requiring NAuto
--       vars to be handled differently whether they are on the LHS or RHS of
--       the assignment. Handling them differently would make LLVM code gen
--       difficult.
--
-- The should be no performance penalty to using alloca-ed vars because,
-- fortunately, the LLVM compiler will convert alloca-ed variables into SSA
-- registers on-the-fly early in the optimisation pipeline.
--
-- For a function parameter in the Sea AST called 'X', the variable in the code
-- will be called '_vX' and the function parameter called '_p_vX'. The function
-- allocForParam generates the alloca required for the given variable.

allocForParam :: (Var, Type) -> LlvmM ()
allocForParam (v, t)
 = do	reg		<- newNamedReg ("_p" ++ seaVar True v) $ toLlvmType t
	alloc		<- newNamedReg (seaVar True v) $ toLlvmType t
	addBlock	[ Assignment alloc (Alloca (toLlvmType t) 1)
			, Store reg (pVarLift alloc) ]



llvmOfSeaGlobal :: Top (Maybe a) -> LMGlobal
llvmOfSeaGlobal (PCafSlot v t@(TPtr (TCon TyConObj)))
 =	let	tt = pLift $ toLlvmType t
		var = LMGlobalVar
			(cafVarName $ seaVar False v)	-- Variable name
			tt				-- LlvmType
			ExternallyVisible		-- LlvmLinkageType
			Nothing				-- LMSection
			ptrAlign			-- LMAlign
			False				-- LMConst
	in (var, Just (LMStaticLit (LMNullLit tt)))

llvmOfSeaGlobal (PCafSlot v t@(TCon (TyConUnboxed tv)))
 =	let	tt = toLlvmType t
		var = LMGlobalVar
			(cafVarName $ seaVar False v)
			tt
			ExternallyVisible
			Nothing
			ptrAlign
			False
	in (var, Just (LMStaticLit (initLiteral tt)))

llvmOfSeaGlobal (PExtern v t@TFun{})
 = panic stage $ "\n    Variable '" ++ varName v
		++ "' (Sea name '" ++ seaVar False v ++ "') has incorrect type '"
		++ show t ++ "'.\n"

llvmOfSeaGlobal (PExtern v t)
 =	let	tt = pLift $ toLlvmType t
		var = LMGlobalVar
			(seaVar False v)
			tt
			External
			Nothing
			ptrAlign
			False
	in (var, Nothing)

llvmOfSeaGlobal x
 = panic stage $ "llvmOfSeaGlobal (" ++ show __LINE__ ++ ")\n\n"
		++ show x ++ "\n"


initLiteral :: LlvmType -> LlvmLit
initLiteral t
 = case t of
	LMPointer _	-> LMNullLit t
	LMInt _		-> LMIntLit 0 t
	LMFloat		-> LMFloatLit 0.0 t
	LMDouble	-> LMFloatLit 0.0 t


moduleGlobals :: [LMGlobal]
moduleGlobals
 = 	[ ( ddcSlotPtr	, Nothing )
	, ( ddcSlotMax	, Nothing )
	, ( ddcSlotBase	, Nothing )
	, ( ddcHeapPtr	, Nothing )
	, ( ddcHeapMax	, Nothing ) ]


llvmOfFunc :: [Stmt a] -> LlvmM ()
llvmOfFunc ss
 =	mapM_ llvmOfStmt ss


llvmOfStmt :: Stmt a -> LlvmM ()
llvmOfStmt stmt
 = case stmt of
	SBlank		-> addComment "Blank"
	SEnter n	-> runtimeEnter n
	SLeave n	-> runtimeLeave n
	SComment s	-> addComment s
	SGoto loc	-> addBlock [Branch (LMNLocalVar (seaVar False loc) LMLabel)]
	SAssign v1 t v2 -> llvmOfAssign v1 t v2
	SReturn v	-> llvmOfReturn v
	SSwitch e a	-> llvmSwitch e a
	SLabel l	-> branchLabel (seaVar False l)
	SIf e s		-> llvmOfSIf e s

	-- LLVM is SSA bu SAuto variables can be reused, so we need to Alloca for them.
	SAuto v t	-> llvmSAuto v t
	SStmt exp	-> llvmOfSStmt exp
	SCaseFail pos	-> caseFail pos
	_		-> panic stage $ "llvmOfStmt (" ++ show __LINE__ ++ ")\n\n" ++ show stmt ++ "\n"

--------------------------------------------------------------------------------

llvmSAuto :: Var -> Type -> LlvmM ()
llvmSAuto v t
 = do	reg		<- newNamedReg (seaVar True v) $ toLlvmType t
	addBlock	[ Assignment reg (Alloca (toLlvmType t) 1) ]


llvmOfSStmt :: Exp a -> LlvmM ()
llvmOfSStmt exp
 = do	_		<- llvmOfExp exp
	return		()


caseFail :: SourcePos -> LlvmM ()
caseFail (SourcePos (n,l,c)) = caseDeath n l c

--------------------------------------------------------------------------------

llvmOfSIf :: Exp a -> [Stmt a] -> LlvmM ()
llvmOfSIf exp@XPrim{} stmts
 = do	true	<- llvmOfExp exp
	bTrue	<- newUniqueLabel "bt"
	bFalse	<- newUniqueLabel "bf"
	addBlock
		[ BranchIf true bTrue bFalse
		, MkLabel (uniqueOfLlvmVar bTrue) ]
	llvmOfFunc stmts
	addBlock
		[ MkLabel (uniqueOfLlvmVar bFalse) ]

--------------------------------------------------------------------------------

llvmSwitch :: Exp a -> [Alt a] -> LlvmM ()
llvmSwitch (XTag xv@(XVar _ t)) alt
 | t == TPtr (TCon TyConObj)
 = do	reg		<-llvmOfExp xv
	tag		<- getObjTag reg

	switchEnd	<- newUniqueLabel "switch.end"
	switchDef	<- newUniqueLabel "switch.default"

	let (def, rest)
			= partition (\ s -> s =@= ADefault{} || s =@= ACaseDeath{}) alt

	alts		<- mapM (genAltVars switchEnd) rest
	addBlock	[ Switch tag switchDef (map fst alts) ]
	mapM_		genAltBlock alts

	if null def
	  then	addBlock [ Branch switchEnd ]
	  else	mapM_ (genAltDefault switchDef) def

	addBlock	[ MkLabel (uniqueOfLlvmVar switchEnd) ]


llvmSwitch e _
 = 	panic stage $ "llvmSwitch (" ++ show __LINE__ ++ ") : " ++ show e

--------------------------------------------------------------------------------

genAltVars :: LlvmVar -> Alt a -> LlvmM ((LlvmVar, LlvmVar), Alt a)
genAltVars switchEnd alt@(ASwitch (XLit (LDataTag v)) [])
 = do	value	<- getTag $ seaVar False v
	return	((i32LitVar value, switchEnd), alt)

genAltVars _ alt@(ACaseSusp (XVar _ t) label)
 = do	lab	<- newUniqueLabel "switch.susp"
	return	((tagSusp, lab), alt)

genAltVars _ alt@(ACaseIndir (XVar _ t) label)
 = do	lab	<- newUniqueLabel "switch.indir"
	return	((tagIndir, lab), alt)

genAltVars _ (ADefault _)
 = panic stage $ "getAltVars (" ++ show __LINE__ ++ ") : found ADefault."

genAltVars _ x
 = panic stage $ "getAltVars (" ++ show __LINE__ ++ ") : found " ++ show x


genAltBlock :: ((LlvmVar, LlvmVar), Alt a) -> LlvmM ()
genAltBlock ((_, lab), ACaseSusp (XVar (NSlot v i) t) label)
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar lab) ]
	obj		<- readSlot i
	forced		<- forceObj obj
	writeSlot	forced i
	branchVar	label

genAltBlock ((_, lab), ACaseIndir (XVar (NSlot v i) t) label)
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar lab) ]
	obj		<- readSlot i
	followed	<- followObj obj
	writeSlot	followed i
	branchVar	label

genAltBlock ((_, lab), ACaseSusp exp@(XVar n@NCafPtr{} t) label)
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar lab) ]
	obj		<- llvmOfExp exp
	forced		<- forceObj obj
	cv		<- toLlvmCafVar (varOfName n) t
	dest		<- newUniqueReg $ toLlvmType t
	addBlock	[ Assignment dest (loadAddress (pVarLift cv))
			, Store forced (pVarLift dest) ]
	branchVar	label

genAltBlock ((_, lab), ACaseIndir exp@(XVar n@NCafPtr{} t) label)
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar lab) ]
	obj		<- llvmOfExp exp
	followed	<- followObj obj
	cv		<- toLlvmCafVar (varOfName n) t
	dest		<- newUniqueReg $ toLlvmType t
	addBlock	[ Assignment dest (loadAddress (pVarLift cv))
			, Store followed (pVarLift dest) ]
	branchVar	label

genAltBlock ((_, lab), ASwitch (XLit (LDataTag _)) [])
 =	addBlock	[ Branch lab ]

genAltBlock ((_, lab), x)
 =	panic stage $ "getAltBlock (" ++ show __LINE__ ++ ") : " ++ show x


genAltDefault :: LlvmVar -> Alt a -> LlvmM ()
genAltDefault label (ADefault ss)
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar label) ]
	mapM_		llvmOfStmt ss

genAltDefault label (ACaseDeath s@(SourcePos (n,l,c)))
 = do	addBlock	[ MkLabel (uniqueOfLlvmVar label) ]
	caseDeath	n l c

genAltDefault _ def
 =	panic stage $ "getAltDefault (" ++ show __LINE__ ++ ") : " ++ show def


caseDeath :: String -> Int -> Int -> LlvmM ()
caseDeath file line column
 = do	addGlobalFuncDecl deathCase

	gname	<- newUniqueName "str.src.file"
	let name = LMGlobalVar gname (typeOfString file) Internal Nothing ptrAlign True
	addGlobalVar ( name, Just (LMStaticStr file (typeOfString file)) )
	pstr	<- newUniqueNamedReg "pstr" pChar

	addBlock
		[ Assignment pstr (GetElemPtr True (pVarLift name) [llvmWordLitVar 0, llvmWordLitVar 0])
		, Expr (Call StdCall (funcVarOfDecl deathCase) [pstr, i32LitVar line, i32LitVar column] [])
		, Unreachable
		]

--------------------------------------------------------------------------------

-- LLVM does not allow implicit fall through to a label, so explicitly branch
-- to the label immediately following.
branchLabel :: String -> LlvmM ()
branchLabel name
 = do	let label = fakeUnique name
	addBlock [ Branch (LMLocalVar label LMLabel), MkLabel label ]

branchVar :: Var -> LlvmM ()
branchVar var
 = do	let label	= (LMLocalVar (fakeUnique (seaVar False var)) LMLabel)
	addBlock	[ Branch label ]

--------------------------------------------------------------------------------

llvmOfReturn :: Exp a -> LlvmM ()
llvmOfReturn exp@XVar{}
 = do	reg		<- llvmOfExp exp
	addBlock	[ Return (Just reg) ]

llvmOfReturn x
 = 	panic stage $ "llvmOfReturn (" ++ show __LINE__ ++ ") " ++ takeWhile (/= ' ') (show x)

