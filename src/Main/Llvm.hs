{-# OPTIONS -fwarn-unused-imports #-}

-- | Wrappers for compiler stages dealing with LLVM code.
module Main.Llvm
	(compileViaLlvm)
where

-- main stages
import Main.Setup
import Main.Sea
import Main.Util

import DDC.Main.Error
import DDC.Main.Pretty
import DDC.Var

import qualified Module.Scrape		as M
import qualified DDC.Main.Arg		as Arg
import qualified DDC.Config.Version	as Version

import Llvm
import Llvm.Invoke
import Llvm.GhcReplace.Unique

import Sea.Exp
import Sea.Util				(eraseAnnotsTree)
import Sea.Pretty

import Util
import qualified Data.Map		as Map
import qualified Config.Config		as Config

stage = "Main.Llvm"

compileViaLlvm
	:: (?verbose :: Bool, ?pathSourceBase :: FilePath)
	=> Setup			-- ^ Compile setup.
	-> ModuleId			-- ^ Module to compile, must also be in the scrape graph.
	-> Tree ()			-- ^ The Tree for the module.
	-> FilePath			-- ^ FilePath of source file.
	-> [FilePath]			-- ^ C import directories.
	-> [FilePath]			-- ^ C include files.
	-> Map ModuleId [a]		-- ^ Module import map.
	-> Bool				-- ^ Module defines 'main' function.
	-> M.Scrape			-- ^ ScrapeGraph of this Module.
	-> Map ModuleId M.Scrape	-- ^ Scrape graph of all modules reachable from the root.
	-> Bool				-- ^ Whether to treat a 'main' function defined by this module
					--	as the program entry point.
	-> IO Bool

compileViaLlvm
	setup modName eTree pathSource importDirs includeFilesHere importsExp
	modDefinesMainFn sRoot scrapes_noRoot blessMain
 = do
	let ?args		= setupArgs setup

	outVerb $ ppr $ "  * Write C header\n"
	writeFile (?pathSourceBase ++ ".ddc.h")
		$ makeSeaHeader
			eTree
			pathSource
			(map ((\(Just f) -> f) . M.scrapePathHeader)
					$ Map.elems scrapes_noRoot)
			includeFilesHere

	outVerb $ ppr $ "  * Generating LLVM IR code\n"
	llvmSource	<- outLlvm modName eTree pathSource

	writeFile (?pathSourceBase ++ ".ddc.ll")
			$ ppLlvmModule llvmSource

	invokeLlvmCompiler ?pathSourceBase []
	invokeLlvmAssembler ?pathSourceBase []

	return modDefinesMainFn


-- | Create LLVM source files
outLlvm
	:: (?args :: [Arg.Arg])
	=> ModuleId
	-> (Tree ())		-- sea source
	-> FilePath		-- path of the source file
	-> IO LlvmModule

outLlvm moduleName eTree pathThis
 = do
	-- Break up the sea into parts.
	let 	([ 	seaProtos, 		seaSupers
		 , 	seaCafProtos,		seaCafSlots,		seaCafInits
		 ,	seaData
		 , 	seaHashDefs ], junk)

		 = partitionFs
			[ (=@=) PProto{}, 	(=@=) PSuper{}
			, (=@=) PCafProto{},	(=@=) PCafSlot{},	(=@=) PCafInit{}
			, (=@=) PData{}
			, (=@=) PHashDef{} ]
			eTree

	when (not $ null junk)
	 $ panic "Main.Llvm" $ "junk sea bits = " ++ show junk ++ "\n"

	-- Build the LLVM code
	let comments =	[ "---------------------------------------------------------------"
			, "      source: " ++ pathThis
			, "generated by: " ++ Version.ddcName
			, "" ]

	let aliases = [ ("struct.Obj", ddcObj) ]

	let code = seaCafInits ++ seaSupers

	let fwddecls	= [_panicOutOfSlots, _panicSlotUnderflow]

	let globals	= moduleGlobals
			++ (catMap seaToLlvmGlobal $ eraseAnnotsTree seaCafSlots)

	decls		<- catMapM seaToLlvmDecls $ eraseAnnotsTree code

	return $ LlvmModule comments aliases globals fwddecls decls


seaToLlvmDecls :: Top (Maybe a) -> IO [LlvmFunction]
seaToLlvmDecls (PCafInit v t ss)
 = panic stage "Implement  'seaToLlvmDecls (PCafInit v t ss)'"


seaToLlvmDecls (PSuper v p t ss)
 = do	{-
 	when True -- ("_ddcInitModule_" == take 15 (seaVar False v))
	 $ do	putStrLn "--------------------------------------------------------"
		putStrLn $ seaVar False v
		putStrLn ""
		mapM_ (\s -> putStrLn $ show s) ss
		putStrLn "--------------------------------------------------------"
	-}
	let blocks = catMap seaToLlvm ss
 	return $ [ LlvmFunction
		(LlvmFunctionDecl (seaVar False v) External CC_Ccc (toLlvmType t) FixedArgs (map toParams p) Nothing)
		(map (seaVar True . fst) p)	-- funcArgs
		[]			-- funcAttrs
		Nothing			-- funcSect
		[ LlvmBlock (fakeUnique "entry") (blocks ++ [ Return Nothing ]) ]	-- funcBody
		]


toParams :: (Var, Type) -> LlvmParameter
toParams (v, t) = (toLlvmType t, [])


seaToLlvmGlobal :: Top (Maybe a) -> [LMGlobal]
seaToLlvmGlobal (PCafSlot v t)
 =	let	tt = LMPointer (toLlvmType t)
		var = LMGlobalVar
 			("_ddcCAF_" ++ seaVar False v)	-- Variable name
			tt				-- LlvmType
			Internal			-- LlvmLinkageType
			Nothing				-- LMSection
			ptrAlign			-- LMAlign
			False				-- LMConst
	in [(var, Just (LMStaticLit (LMNullLit tt)))]


moduleGlobals :: [LMGlobal]
moduleGlobals
 = 	[ ( ddcSlotPtr, Nothing )
	, ( ddcSlotMax, Nothing )
	, ( ddcSlotBase, Nothing ) ]


seaToLlvm :: Stmt a -> [LlvmStatement]
seaToLlvm (SEnter n) = runtimeEnter n
seaToLlvm (SLeave n) = runtimeLeave n

seaToLlvm _ = []


--------------------------------------------------------------------------------
-- Runtime hacks.

runtimeEnter :: Int -> [LlvmStatement]
runtimeEnter count
 =	[ Comment ["_ENTER (" ++ show count ++ ")"]
	, Assignment enter0 (Load ddcSlotPtr)
	, Assignment enter1 (GetElemPtr True enter0 [LlvmIndexInt count])
	, Store enter1 ddcSlotPtr

	, Assignment enter2 (Load ddcSlotMax)
	, Assignment enter3 (Compare LM_CMP_Ult enter1 enter2)
	, BranchIf enter3 (LMLocalVar egood LMLabel) (LMLocalVar epanic LMLabel)
	, MkLabel epanic
	, Expr (Call StdCall (LMGlobalVar "_panicOutOfSlots" (LMFunction _panicOutOfSlots) External Nothing Nothing True) [] [NoReturn])
	, Branch (LMLocalVar egood LMLabel)
	, MkLabel egood
	, Comment ["----- Slot initiialization -----"]
	]

	++ slotInit egood count
	++ [ Comment ["---------------------------------------------------------------"] ]
    where
	enter0 = LMLocalVar (fakeUnique "enter.0") ppObj
	enter1 = LMLocalVar (fakeUnique "enter.1") ppObj
	enter2 = LMLocalVar (fakeUnique "enter.2") ppObj
	enter3 = LMLocalVar (fakeUnique "enter.3") i1
	epanic = fakeUnique "enter.panic"
	egood = fakeUnique "enter.good"


runtimeLeave :: Int -> [LlvmStatement]
runtimeLeave count
 =	[ Comment ["---------------------------------------------------------------"]
	, Comment ["_LEAVE (" ++ show count ++ ")"]
	, Assignment leave0 (Load ddcSlotPtr)
	, Assignment leave1 (GetElemPtr True leave0 [LlvmIndexInt (-count)])
	, Store leave1 ddcSlotPtr

	, Assignment leave2 (Load ddcSlotBase)
	, Assignment leave3 (Compare LM_CMP_Ult leave1 leave2)
	, BranchIf leave3 (LMLocalVar lpanic LMLabel) (LMLocalVar lgood LMLabel)
	, MkLabel lpanic
	, Expr (Call StdCall (LMGlobalVar "_panicSlotUnderflow" (LMFunction _panicSlotUnderflow) External Nothing Nothing True) [] [NoReturn])
	, Branch (LMLocalVar lgood LMLabel)
	, MkLabel lgood

	, Comment ["---------------------------------------------------------------"]
	]
    where
	leave0 = LMLocalVar (fakeUnique "leave.0") ppObj
	leave1 = LMLocalVar (fakeUnique "leave.1") ppObj
	leave2 = LMLocalVar (fakeUnique "leave.2") ppObj
	leave3 = LMLocalVar (fakeUnique "leave.3") i1
	lpanic = fakeUnique "leave.panic"
	lgood = fakeUnique "leave.ok"


slotInit :: Unique -> Int -> [LlvmStatement]
slotInit _ count
 | count < 0
 = panic stage $ "Asked for " ++ show count ++ " GC slots."

slotInit _ count
 | count < 8
 =	Assignment init0 (Load ddcSlotPtr) : concatMap build [1 .. count]
    where
	init0 = LMLocalVar (fakeUnique "init.0") ppObj
	build n
	 =	let target = LMLocalVar (fakeUnique ("init.target." ++ show n)) ppObj
		in	[ Assignment target (GetElemPtr False init0 [LlvmIndexInt (-n)])
			, Store nullObj target ]

slotInit initstart n
 | otherwise
 =	[ Assignment init0 (Load ddcSlotPtr)
	, Branch (LMLocalVar initloop LMLabel)

	, MkLabel initloop
	, Assignment index (Phi llvmWord [((LMLitVar (LMIntLit 0 llvmWord)), (LMLocalVar initstart LMLabel)), (indexNext, (LMLocalVar initloop LMLabel))])
	, Assignment tmp (LlvmOp LM_MO_Add index (LMLitVar (LMIntLit (toInteger (-n)) llvmWord)))

	, Assignment target (GetElemPtr False init0 [LlvmIndexVar tmp])
	, Store nullObj target

	, Assignment indexNext (LlvmOp LM_MO_Add index (LMLitVar (LMIntLit 1 llvmWord)))
	, Assignment initdone (Compare LM_CMP_Eq indexNext (LMLitVar (LMIntLit (toInteger n) llvmWord)))
	, BranchIf initdone (LMLocalVar initend LMLabel) (LMLocalVar initloop LMLabel)
	, MkLabel initend
	]
    where
	init0 = LMLocalVar (fakeUnique "init.0") ppObj
	initloop = fakeUnique "init.loop"
	initend = fakeUnique "init.end"
	index = LMLocalVar (fakeUnique "init.index") llvmWord
	indexNext = LMLocalVar (fakeUnique "init.index.next") llvmWord
	initdone = LMLocalVar (fakeUnique "init.done") i1
	tmp = LMLocalVar (fakeUnique "init.tmp") llvmWord
	target = LMLocalVar (fakeUnique "init.target") ppObj

--------------------------------------------------------------------------------
-- Helpers.

toLlvmType :: Type -> LlvmType
toLlvmType TObj = LMPointer structObj
toLlvmType TVoid = LMVoid
toLlvmType t = panic stage $ "toLlvmType " ++ show t ++ "\n"


--------------------------------------------------------------------------------
-- Data types and variables.

_panicOutOfSlots :: LlvmFunctionDecl
_panicOutOfSlots = LlvmFunctionDecl "_panicOutOfSlots" External CC_Ccc LMVoid FixedArgs [] ptrAlign

_panicSlotUnderflow :: LlvmFunctionDecl
_panicSlotUnderflow = LlvmFunctionDecl "_panicSlotUnderflow" External CC_Ccc LMVoid FixedArgs [] ptrAlign


ptrAlign :: Maybe Int
ptrAlign = Just Config.pointerBytes


ddcSlotPtr :: LlvmVar
ddcSlotPtr = pVarLift (LMGlobalVar "_ddcSlotPtr" ppObj External Nothing ptrAlign False)

ddcSlotMax :: LlvmVar
ddcSlotMax = pVarLift (LMGlobalVar "_ddcSlotMax" ppObj External Nothing ptrAlign False)

ddcSlotBase :: LlvmVar
ddcSlotBase = pVarLift (LMGlobalVar "_ddcSlotBase" ppObj External Nothing ptrAlign False)


ddcObj :: LlvmType
ddcObj = LMStruct [ i32 ]

structObj :: LlvmType
structObj = LMAlias ("struct.Obj", ddcObj)

pObj :: LlvmType
pObj = pLift structObj

ppObj :: LlvmType
ppObj = pLift pObj

nullObj :: LlvmVar
nullObj = LMLitVar (LMNullLit pObj)

