{-# OPTIONS -fwarn-unused-imports -fwarn-incomplete-patterns #-}

-- | Wrappers for compiler stages dealing with LLVM code.
module Main.Llvm
	(compileViaLlvm)
where

-- main stages
import Main.Setup
import Main.Sea
import Main.Util

import DDC.Base.DataFormat
import DDC.Base.Literal
import DDC.Main.Error
import DDC.Main.Pretty
import DDC.Var

import qualified Module.Scrape		as M
import qualified DDC.Main.Arg		as Arg
import qualified DDC.Config.Version	as Version

import Llvm
import Llvm.Invoke
import Llvm.GhcReplace.Unique
import Llvm.Runtime
import Llvm.Util

import Sea.Exp
import Sea.Util				(eraseAnnotsTree)
import Sea.Pretty

import Util
import qualified Data.Map		as Map

import qualified Debug.Trace		as Debug

stage = "Main.Llvm"

debug = True

_trace s v
 =	if debug
	  then Debug.trace s v
	  else v


compileViaLlvm
	:: (?verbose :: Bool, ?pathSourceBase :: FilePath)
	=> Setup			-- ^ Compile setup.
	-> ModuleId			-- ^ Module to compile, must also be in the scrape graph.
	-> Tree ()			-- ^ The Tree for the module.
	-> FilePath			-- ^ FilePath of source file.
	-> [FilePath]			-- ^ C import directories.
	-> [FilePath]			-- ^ C include files.
	-> Map ModuleId [a]		-- ^ Module import map.
	-> Bool				-- ^ Module defines 'main' function.
	-> M.Scrape			-- ^ ScrapeGraph of this Module.
	-> Map ModuleId M.Scrape	-- ^ Scrape graph of all modules reachable from the root.
	-> Bool				-- ^ Whether to treat a 'main' function defined by this module
					--	as the program entry point.
	-> IO Bool

compileViaLlvm
	setup modName eTree pathSource importDirs includeFilesHere importsExp
	modDefinesMainFn sRoot scrapes_noRoot blessMain
 = do
	let ?args		= setupArgs setup

	outVerb $ ppr $ "  * Write C header\n"
	writeFile (?pathSourceBase ++ ".ddc.h")
		$ makeSeaHeader
			eTree
			pathSource
			(map ((\(Just f) -> f) . M.scrapePathHeader)
					$ Map.elems scrapes_noRoot)
			includeFilesHere

	outVerb $ ppr $ "  * Generating LLVM IR code\n"
	llvmSource	<- outLlvm modName eTree pathSource

	writeFile (?pathSourceBase ++ ".ddc.ll")
			$ ppLlvmModule llvmSource

	invokeLlvmCompiler ?pathSourceBase []
	invokeLlvmAssembler ?pathSourceBase []

	return modDefinesMainFn


-- | Create LLVM source files
outLlvm
	:: (?args :: [Arg.Arg])
	=> ModuleId
	-> (Tree ())		-- sea source
	-> FilePath		-- path of the source file
	-> IO LlvmModule

outLlvm moduleName eTree pathThis
 = do
	-- Break up the sea into parts.
	let 	([ 	_seaProtos, 		seaSupers
		 , 	_seaCafProtos,		seaCafSlots,		seaCafInits
		 ,	_seaData
		 , 	_seaHashDefs ], junk)

		 = partitionFs
			[ (=@=) PProto{}, 	(=@=) PSuper{}
			, (=@=) PCafProto{},	(=@=) PCafSlot{},	(=@=) PCafInit{}
			, (=@=) PData{}
			, (=@=) PHashDef{} ]
			eTree

	when (not $ null junk)
	 $ panic "Main.Llvm" $ "junk sea bits = " ++ show junk ++ "\n"

	-- Build the LLVM code
	let comments =	[ "---------------------------------------------------------------"
			, "      source: " ++ pathThis
			, "generated by: " ++ Version.ddcName
			, "" ]

	let aliases = [ ("struct.Obj", ddcObj) ]

	let code = seaCafInits ++ seaSupers

	let fwddecls	= [panicOutOfSlots, allocCollect]

	let globals	= moduleGlobals
			++ (catMap llvmOfSeaGlobal $ eraseAnnotsTree seaCafSlots)

	decls		<- catMapM llvmOfSeaDecls $ eraseAnnotsTree code

	return $ LlvmModule comments aliases globals fwddecls decls


llvmOfSeaDecls :: Top (Maybe a) -> IO [LlvmFunction]
llvmOfSeaDecls (PCafInit v t ss)
 = panic stage "Implement 'llvmOfSeaDecls (PCafInit v t ss)'"


llvmOfSeaDecls (PSuper v p t ss)
 = do	when debug
	  $ putStrLn "--------------------------------------------------------"
	blocks <- catMapM llvmOfStmt ss
 	return $ [ LlvmFunction
		(LlvmFunctionDecl (seaVar False v) External CC_Ccc (toLlvmType t) FixedArgs (map llvmOfParams p) Nothing)
		(map (seaVar True . fst) p)	-- funcArgs
		[]				-- funcAttrs
		Nothing				-- funcSect
		[ LlvmBlock (fakeUnique "entry") (blocks ++ [ Return Nothing ]) ]	-- funcBody
		]

llvmOfSeaDecls x
 = panic stage $ "Implement 'llvmOfSeaDecls (" ++ show x ++ ")'"


llvmOfParams :: (Var, Type) -> LlvmParameter
llvmOfParams (v, t) = (toLlvmType t, [])


llvmOfSeaGlobal :: Top (Maybe a) -> [LMGlobal]
llvmOfSeaGlobal (PCafSlot v t)
 | t == TPtr (TPtr TObj) 
 =	let	tt = toLlvmType t
		var = LMGlobalVar
 			("_ddcCAF_" ++ seaVar False v)	-- Variable name
			tt				-- LlvmType
			ExternallyVisible		-- LlvmLinkageType
			Nothing				-- LMSection
			ptrAlign			-- LMAlign
			False				-- LMConst
	in [(var, Just (LMStaticLit (LMNullLit tt)))]

 | otherwise
 = panic stage $ "llvmOfSeaGlobal on : \n\tVar  : " ++ seaVar False v ++ "\n\tType : " ++ show t

llvmOfSeaGlobal x
 = panic stage $ "llvmOfSeaGlobal on : " ++ show x

moduleGlobals :: [LMGlobal]
moduleGlobals
 = 	[ ( ddcSlotPtr	, Nothing )
	, ( ddcSlotMax	, Nothing )
	, ( ddcSlotBase	, Nothing )
	, ( ddcHeapPtr	, Nothing )
	, ( ddcHeapMax	, Nothing ) ]


llvmOfStmt :: Stmt a -> IO [LlvmStatement]
llvmOfStmt stmt
 = case stmt of
	SBlank		-> return $ [Comment [""]]
	SEnter n	-> runtimeEnter n
	SLeave n	-> return $ runtimeLeave n
	SComment s	-> return $ [Comment [s]]
	SGoto loc	-> return $ [Branch (LMNLocalVar (seaVar False loc) LMLabel)]
	SAssign v1 t v2 -> llvmOfAssign v1 t v2

	SReturn v	-> llvmOfReturn v

	SAuto v t
	  ->	-- LLVM is SSA so auto variables do not need to be declared.
		return [Comment ["SAuto " ++ seaVar True v ++ " " ++ show t]]

	SLabel l
	  ->	-- LLVM does not allow implicit fall through to a label, so
		-- explicitly branch to the label immediately following.
		return $ branchLabel (seaVar False l)

	_
	  -> do	when debug
		  $ putStrLn $ take 150 $ show stmt
		return []


--------------------------------------------------------------------------------

llvmOfAssign :: Exp a -> Type -> Exp a -> IO [LlvmStatement]
llvmOfAssign (XVar v1 t1) t (XVar v2 t2)
 | t1 == TPtr (TPtr TObj) && t2 == TPtr (TPtr TObj) && t == TPtr (TPtr TObj)
	&& isGlobalVar v1 && isGlobalVar v2
 = do	src	<- newUniqueReg (toLlvmType t1)
	return	$ [ Assignment src (loadAddress (toLlvmVar v2 t2))
		  , Store src (pVarLift (toLlvmVar v1 t1)) ]


llvmOfAssign (XVar v1 t1) t x@(XPrim op args)
 | t1 == TPtr (TPtr TObj) && t == TPtr (TPtr TObj)
 = do	(dstreg, oplist) <- llvmOfXPrim (toLlvmType t) op args
	return	$ reverse oplist ++ [ Store dstreg (pVarLift (toLlvmVar v1 t1)) ]


llvmOfAssign (XSlot v1 t1 i) t (XVar v2 t2)
 | t1 == TPtr TObj && t2 == TPtr TObj && t == TPtr TObj
 = do	src	<- newUniqueReg (toLlvmType t1)
	dst	<- newUniqueReg (toLlvmType t1)
	return	$ [ Comment ["XSlot " ++ show i ++ " <- " ++ seaVar True v1]
		  , Assignment dst (GetElemPtr True localSlotBase [llvmWordLitVar i])
		  , Store (toLlvmVar v2 t2) (pVarLift dst) ]


llvmOfAssign (XVar v1 t1) t (XSlot v2 t2 i)
 | t1 == TPtr TObj && t2 == TPtr TObj && t == TPtr TObj
 = do	addr	<- newUniqueReg (pLift (toLlvmType t1))
	let dst	= toLlvmVar v1 t1
	return	$ [ Comment ["XVar " ++ seaVar True v1 ++ " <- XSlot " ++ show i]
		  , Assignment addr (GetElemPtr True localSlotBase [llvmWordLitVar i])
		  , Assignment dst (Load addr) ]


---- Working on this!
llvmOfAssign a@((XSlot v1 t1 i)) t c@(XBox t2 exp)
 | t1 == TPtr TObj && t == TPtr TObj
 = do	when debug
	 $ do	putStrLn $ "--------------------------\nXSlot "  ++ show i ++ " <- XBox "
			++ "\n    " ++ show a
			++ "\n    " ++ show t
			++ "\n    " ++ show c ++ "\n"

	(boxed, boxCode)	<- boxExp exp
	storeCode		<- storeToSlot i boxed
	return	$ [ Comment [ "" , "XSlot " ++ show i ++ " <- XBox" ] ]
		  ++ boxCode
		  ++ storeCode


llvmOfAssign a b c
 = do	when debug
	 $ do	putStrLn $ "--------------------------\nUnhandled Assign"
			++ "\n    " ++ show a
			++ "\n    " ++ show b
			++ "\n    " ++ show c ++ "\n"
	return []


varOfXLit :: Exp a -> LlvmVar
varOfXLit (XLit x) = llvmIntLitVar x

varOfXLit x = panic stage $ "varOfXLit " ++ show x



boxExp :: Exp a -> IO (LlvmVar, [LlvmStatement])
boxExp (XLit lit@(LiteralFmt (LInt value) (UnboxedBits 32)))
 = do	r0	<- newUniqueNamedReg "r0" pChar
	r1	<- newUniqueNamedReg "r1" pChar
	r2	<- newUniqueNamedReg "r2" pChar
	r3	<- newUniqueNamedReg "r3" i1
	r4	<- newUniqueNamedReg "r4" pChar
	r5	<- newUniqueNamedReg "r5" (pLift i32)
	r6	<- newUniqueNamedReg "r6" pChar
	r7	<- newUniqueNamedReg "r7" pChar
	r8	<- newUniqueNamedReg "r8" (pLift i32)
	pre	<- newUniqueNamedReg "pre" pChar
	result	<- newUniqueNamedReg "boxed" pObj

	entry	<- newUniqueLabel "entry"
	bb	<- newUniqueLabel "bb"
	bb1	<- newUniqueLabel "bb1"

	let allocSize = i32LitVar (8::Int)
	return	$ (result,
		[ Comment ["boxInt32 start"]
		, Branch entry
		, MkLabel (uniqueOfLlvmVar entry)
		, Assignment r0 (Load ddcHeapPtr)
		, Assignment r1 (GetElemPtr True r0 [allocSize])
		, Assignment r2 (Load ddcHeapMax)
		, Assignment r3 (Compare LM_CMP_Ugt r1 r2)
		, BranchIf r3 bb bb1

		, MkLabel (uniqueOfLlvmVar bb)
		, Expr (Call StdCall (LMGlobalVar "_allocCollect" (LMFunction allocCollect) External Nothing Nothing True) [allocSize] [])
		, Assignment pre (Load ddcHeapPtr)
		, Branch bb1

		, MkLabel (uniqueOfLlvmVar bb1)
		, Assignment r4 (Phi pChar [(pre, bb), (r0 , entry)])

		, Assignment r5 (Cast LM_Bitcast r4 (pLift i32))
		, Assignment r6 (GetElemPtr True r4 [allocSize])
		, Store r6 ddcHeapPtr


		, Store (i32LitVar 19) r5
		, Assignment r7 (GetElemPtr True r4 [llvmWordLitVar 4])
		, Assignment r8 (Cast LM_Bitcast r7 (pLift i32))
		, Store (i32LitVar value) r8
		, Assignment result (Cast LM_Bitcast r4 pObj)
		, Comment ["boxInt32 end"]
		])


boxExp x
 = do	result	<- newUniqueNamedReg "boxed" ppObj
	return	$ (result, [ Comment ["boxExp " ++ takeWhile (/= ' ') (show x)] ])

--------------------------------------------------------------------------------

storeToSlot :: Int -> LlvmVar -> IO [LlvmStatement]
storeToSlot 0 var
 = return [ Store var localSlotBase ]

storeToSlot n var
 | n > 0
 = do	dst	<- newUniqueNamedReg ("slot" ++ show n) pObj
	return	$ []
--	return	$ [ Assignment dst (GetElemPtr True localSlotBase [llvmWordLitVar n])
--		  , Store var dst ]


storeToSlot n _ = panic stage $ "storeToSlot in slot " ++ show n

--------------------------------------------------------------------------------

branchLabel :: String -> [LlvmStatement]
branchLabel name
 =	let label = fakeUnique name
	in [Branch (LMLocalVar label LMLabel), MkLabel label]

--------------------------------------------------------------------------------

llvmOfReturn :: Exp a -> IO [LlvmStatement]
llvmOfReturn (XVar v t)
 | t == TPtr TObj
 =	return [ Return (Just (toLlvmVar v t)) ]


llvmOfReturn x
 = do	return	$ [ Comment ["Return (" ++ (takeWhile (/= ' ') (show x)) ++ ")"]
		  , Return Nothing ]

--------------------------------------------------------------------------------

primFoldFunc
	:: LlvmType
	-> (LlvmVar -> LlvmVar -> LlvmExpression)
	-> (LlvmVar, [LlvmStatement])
	-> Exp a
	-> IO (LlvmVar, [LlvmStatement])

primFoldFunc t build (left, ss) exp
 = do	dst <- newUniqueReg t
	return $ (dst, Assignment dst (build left (llvmVarOfExp exp)) : ss)


llvmOfXPrim :: LlvmType -> Prim -> [Exp a] -> IO (LlvmVar, [LlvmStatement])
llvmOfXPrim t op args
 = case args of
	[]			-> panic stage "llvmOfXPrim : empty list"
	[x]			-> panic stage "llvmOfXPrim : singleton list"

	[XVar v t, XInt i]	-> llvmPtrOp v t op i

	x : xs
	  -> do		reg <- newUniqueReg t
			foldM (primFoldFunc t (llvmOpOfPrim op)) (reg, [Assignment reg (Load (llvmVarOfExp x))]) xs

llvmPtrOp :: Var -> Type -> Prim -> Int -> IO (LlvmVar, [LlvmStatement])
llvmPtrOp v t op i
 = do	src	<- newUniqueReg (toLlvmType t)
	dst	<- newUniqueReg (toLlvmType t)
	return	$ (dst, [ Assignment dst (GetElemPtr False src [llvmWordLitVar i])
			, Assignment src (Load (pVarLift (toLlvmVar v t))) ])

llvmVarOfExp :: Exp a -> LlvmVar
llvmVarOfExp x
 = case x of
	XVar v t	-> toLlvmVar v t
	XInt i		-> llvmWordLitVar i
	_ -> panic stage $ "llvmVarOfExp " ++ show x

llvmOpOfPrim :: Prim -> (LlvmVar -> LlvmVar -> LlvmExpression)
llvmOpOfPrim p
 = case p of
	FAdd -> LlvmOp LM_MO_Add
	FSub -> LlvmOp LM_MO_Sub
	_ -> panic stage $ "llvmOpOfPrim : Unhandled op : " ++ show p


-- | Convert a Sea type to an LlvmType.
toLlvmType :: Type -> LlvmType
toLlvmType (TPtr t)	= LMPointer (toLlvmType t)
toLlvmType TObj		= structObj
toLlvmType TVoid	= LMVoid
toLlvmType t		= panic stage $ "toLlvmType " ++ show t ++ "\n"


-- | Convert a Sea Var (wit a Type) to a typed LlvmVar.
toLlvmVar :: Var -> Type -> LlvmVar
toLlvmVar v t
 = case isGlobalVar v of
	True -> LMGlobalVar (seaVar False v) (toLlvmType t) External Nothing Nothing False
	False -> LMNLocalVar (seaVar True v) (toLlvmType t)


-- | Does the given Sea variable have global scope? TODO: Move this to the Sea stuff.
isGlobalVar :: Var -> Bool
isGlobalVar v 
 -- If the variable is explicitly set as global use the given name.
 | bool : _	<- [global | ISeaGlobal global <- varInfo v]
 = bool

 | otherwise
 = False


llvmIntLitVar :: LiteralFmt -> LlvmVar
llvmIntLitVar (LiteralFmt (LInt i) (UnboxedBits 32)) = i32LitVar i
llvmIntLitVar (LiteralFmt (LInt i) (UnboxedBits 64)) = i64LitVar i

llvmIntLitVar _ = panic stage $ "llvmIntLitVar : unhandled case."

