
module Control.Exception
export try; throw; fail; error
export ddcHookHandleTopLevel
import System.IO.Console
import Data.Text

import foreign c value
 ddcPrimExceptionTry
        :  {@eff1 eff2: Effect} -> {@a: Data}
        -> S eff1 a -> (Exception -> S eff2 a) -> S (eff1 + eff2) a

 ddcPrimExceptionThrow
        :  {@eff: Effect} -> {@a: Data}
        -> Exception -> S eff a

import foreign abstract type
 Error : Effect

where

-------------------------------------------------------------------------------
-- | Wrapper for 'ddcPrimTry' so we can say just 'try'.
try     {@eff1 eff2: Effect} {@a: Data}
        (susp: S eff1 a) (handler: Exception -> S eff2 a): S (eff1 + eff2) a
 = ddcPrimExceptionTry susp handler


-------------------------------------------------------------------------------
-- | Type that represents every exception that can be thrown.
data Exception where
        -- Generic exceptions.
        ExceptionFail           : Text -> Exception
        ExceptionError          : Text -> Exception

        -- System IO Exceptions.
        -- These have a message as well as the value of 'errno' if available.
        ExceptionSystemFile     : Text -> Int -> Exception
        ExceptionSystemSocket   : Text -> Int -> Exception


-- | Throw a named exception.
throw {@a: Data} (ex: Exception): a
 = ddcPrimExceptionThrow {@Pure} {@a} ex


-- | Throw an exception from a pure computation to end the program.
--
--   This is intended for unrecoverable "program on fire" cases such
--   as when we detect an internal invariant has been violated.
--
--   The fact that this function is not assigned an effec type means that the
--   optimiser may reorder calls to is, but that doesn't matter if the program
--   is really on fire.
--
fail {@a: Data} (tx: Text): a
 = ddcPrimExceptionThrow {@Pure} {@a} (ExceptionFail tx)


-- | Throw an generic exception with the 'Error' effect.
--   This is intended for generic user program exceptions.
error (tx: Text): S Error Unit
 = ddcPrimExceptionThrow {@Error} {@Unit} (ExceptionError tx)


-------------------------------------------------------------------------------
-- | Hook for to handle exceptions that get propagated to top-level.
--   For Discus Source programs the desugarer wraps the 'main' function
--   with this handler.
ddcHookHandleTopLevel (comp: S e Unit): S (e + Console) Unit
 =  try comp $ \ex
 -> case ex of
        ExceptionFail tx
         -> writel $ "*** Fail:"  %% tx

        ExceptionError tx
         -> writel $ "*** Error:" %% tx

        ExceptionSystemFile tx _
         -> writel $ "*** File IO Error:" %% tx

        ExceptionSystemSocket tx _
         -> writel $ "*** Socket IO Error:" %% tx


-- | Hook for the runtime primitive code to throw a file exception.
ddcHookErrorSystemFile (tx: TextLit#) (errno: Int): S Error Unit
 = weakeff Error in throw $ ExceptionSystemFile (textLit tx) errno


-- | Hook for the runtime primitive code to throw a socket exception.
ddcHookErrorSystemSocket (tx: TextLit#) (errno: Int): S Error Unit
 = weakeff Error in throw $ ExceptionSystemSocket (textLit tx) errno

