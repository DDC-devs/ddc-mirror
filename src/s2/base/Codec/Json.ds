
module Codec.Json
export {
        parseJson;
        show_Json;
        show_JsonParseError;
        show_JsonParseContext;
}
import Class.Show
import Data.Text
import Data.Numeric
where


---------------------------------------------------------------------------------------------------
data Json where
        JsonNull        : Json
        JsonBool        : Bool                  -> Json
        JsonString      : Text                  -> Json
        JsonNumber      : Float64               -> Json
        JsonList        : List Json             -> Json
        JsonObject      : List (Text, Json)     -> Json


---------------------------------------------------------------------------------------------------
show_Json: Show Json
 = Show sh
 where
        sh (jj: Json): Text
         = case jj of
                JsonNull        -> "null"
                JsonBool True   -> "true"
                JsonBool False  -> "false"

                -- TODO: excape this as required by JSON spec.
                JsonString str  -> show str

                JsonNumber num  -> show num
                JsonList   xs   -> "[" % showElems  xs % "]"
                JsonObject fs   -> "{" % showFields fs % "}"

        showElems   Nil                 = ""
        showElems  (Cons e Nil)         = sh e
        showElems  (Cons e es)          = sh e % "," % showElems es

        -- TODO: excape chars in label.
        showFields  Nil                 = ""
        showFields (Cons (l, e) Nil)    = show l % ":" % sh e
        showFields (Cons (l, e) es)     = show l % ":" % sh e % "," % showFields es


---------------------------------------------------------------------------------------------------
-- | Things that can go wrong when parsing JSON.
data JsonParseError where

        JsonParseEnd
         : JsonParseContext -> JsonParseError

        JsonParsePos
         : Nat -> JsonParseContext -> JsonParseError


-- | Context in which a parse error can occur.
data JsonParseContext where
        JsonParseValue   : JsonParseContext
        JsonParseObject  : JsonParseContext
        JsonParseList    : JsonParseContext
        JsonParseField   : JsonParseContext
        JsonParseString  : JsonParseContext
        JsonParseKeyword : JsonParseContext
        JsonParseNumber  : JsonParseContext


show_JsonParseError: Show JsonParseError
 = Show sh
 where sh (err: JsonParseError): Text
        = case err of
                JsonParseEnd ctx
                 -> parens $ "JsonParseEnd" %% show ctx

                JsonParsePos pos ctx
                 -> parens $ "JsonParsePos" %% show pos %% show ctx


show_JsonParseContext: Show JsonParseContext
 = Show sh
 where sh (ctx: JsonParseContext): Text
        = case ctx of
                JsonParseValue   -> "JsonParseValue"
                JsonParseObject  -> "JsonParseObject"
                JsonParseList    -> "JsonParseList"
                JsonParseField   -> "JsonParseField"
                JsonParseString  -> "JsonParseString"
                JsonParseKeyword -> "JsonParseKeyword"
                JsonParseNumber  -> "JsonParseNumber"


---------------------------------------------------------------------------------------------------
data JsonState (r: Region) where
        JsonState
         :  TextSource r
         -> Ref r (List JsonParseError)
         -> JsonState r

pullChar  (state: JsonState r)
        : S (Read r + Write r) (Maybe Char)
 | JsonState source _ <- state
 = textSource_pullChar source

peekChar  (state: JsonState r)
        : S (Read r + Write r) (Maybe Char)
 | JsonState source _ <- state
 = textSource_peekChar source

matchChar (c: Char) (state: JsonState r)
        : S (Read r + Write r) Bool
 | JsonState source _ <- state
 = textSource_matchChar source c

pushError (state: JsonState r) (err: JsonParseError)
        : S (Read r + Write r) Unit
 | JsonState _ refErrs   <- state
 = do   errs    = readRef refErrs
        writeRef refErrs errs

parseFail (state: JsonState r) (err: JsonParseError)
        : S (Read r + Write r) (Maybe a)
 = do   pushError state err
        Nothing

skipSpace (state: JsonState r)
        : S (Read r + Write r) Bool
 | JsonState source _ <- state
 = case peekChar state of
        Just c
         |  isSpace c
         ,  Just _       <- pullChar state
         -> skipSpace state

         | otherwise    -> True

        Nothing         -> True


data JsonToken where
        JsonTokenCBra   : JsonToken
        JsonTokenCKet   : JsonToken


---------------------------------------------------------------------------------------------------
-- TODO: check that we've parsed the complete string.
parseJson (tx: Text): Either JsonParseError Json
 = private r with { Read r; Write r; Alloc r} in
   do   source  = textSource_fromText {@r} tx
        refErr  = allocRef {@r} Nil
        state   = JsonState source refErr
        case pullJsonValue state of
         Just v  -> Right v
         Nothing -> Left $ JsonParsePos 0 JsonParseValue


---------------------------------------------------------------------------------------------------
pullJsonValue (state: JsonState r)
        : S (Read r + Write r) (Maybe Json)
 = case do { skipSpace state; peekChar state } of
        Just c
         | isDigit c ∨ c == '-'
         -> pullJsonNumber state

         | c == 'n'     -> matchKeyword (charListOfText "null")  state JsonNull
         | c == 'f'     -> matchKeyword (charListOfText "false") state (JsonBool False)
         | c == 't'     -> matchKeyword (charListOfText "true")  state (JsonBool True)
         | c == '"'     -> pullJsonString state
         | c == '['     -> pullJsonList state
         | c == '{'     -> pullJsonObject state

        _ -> Nothing


---------------------------------------------------------------------------------------------------
-- | Match a keyword from the source stream.
matchKeyword (cc: List Char) (state: JsonState r) (v: Json)
        : S (Read r + Write r) (Maybe Json)
 = case cc of
        Nil
          -> Just v

        Cons c cs
          |  matchChar    c  state
          -> matchKeyword cs state v

        _ -> parseFail state $ JsonParsePos 0 JsonParseKeyword


---------------------------------------------------------------------------------------------------
pullJsonNumber (state: JsonState r)
        : S (Read r + Write r) (Maybe Json)
 | Just c1       <- peekChar state
 = (match
        | isDigit c1
        , Just f  <- pullNumberPos state
        = Just (JsonNumber f)

        | c1 == '-'
        , Just _  <- pullChar state
        , Just c2 <- peekChar state
        , isDigit c2
        , Just f  <- pullNumberPos state
        = Just (JsonNumber (0.0f64 - f))

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseNumber)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseNumber


pullNumberPos (state: JsonState r)
        : S (Read r + Write r) (Maybe Float64)
 | Just ds1  <- takeDigits state
 , Cons _ _  <- ds1

 -- TODO Parser disaster with nested matches, the following guard
 --      gets stuck to these ones, same as in above function.
 = (match
        | Just cd       <- peekChar state
        , cd  == '.'
        , Just _        <- pullChar state
        , Just ds2      <- takeDigits state
        , Cons _ _      <- ds2
        , Just f        <- parseFloat64 $  textOfCharList (append ds1 (Cons '.' ds2))
        = case takeNumberExponent state of
                Just Nothing    -> Just f
                Just (Just ex)  -> Just (f * float64_pow 10.0f64 (truncate# ex))
                Nothing         -> parseFail state $ JsonParsePos 0 JsonParseNumber

        | Just f        <- parseFloat64 $  textOfCharList ds1
        = Just f

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseNumber)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseNumber


takeNumberExponent (state: JsonState r)
        : S (Read r + Write r) (Maybe (Maybe Int))
 | Just ce      <- peekChar state
 , ce == 'e' ∨ ce == 'E'
 , Just _       <- pullChar state
 = (match
        | Just cn      <- peekChar state
        , isDigit cn
        , Just ex       <- pullNumberExponentPos state
        = Just (Just (promote# ex))

        | Just cn      <- peekChar state
        , cn == '+'
        , Just _        <- pullChar state
        , Just ex       <- pullNumberExponentPos state
        = Just (Just (promote# ex))

        | Just cn      <- peekChar state
        , cn == '-'
        , Just _        <- pullChar state
        , Just ex       <- pullNumberExponentPos state
        = Just (Just (0i - promote# ex))

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseNumber)

 | otherwise
 = Just Nothing


pullNumberExponentPos (state: JsonState r)
        : S (Read r + Write r) (Maybe Nat)
 | Just ds      <- takeDigits state
 , Cons _ _     <- ds
 = parseNat $ textOfCharList ds

 | otherwise
 = Nothing


-- | Take a list of digit characters from the source stream.
takeDigits (state: JsonState r)
        : S (Read r + Write r) (Maybe (List Char))
 | Just c  <- peekChar state
 = case isDigit c of
        False                   -> Just Nil
        True
         | Just _ <- pullChar state
         -> case takeDigits state of
                Nothing         -> Just (Cons c Nil)
                Just cs         -> Just (Cons c cs)

         | otherwise
         -> Nothing

 | otherwise
 = Nothing


---------------------------------------------------------------------------------------------------
-- TODO: handle escape characters.

-- | Pull a JSON string from the source.
pullJsonString (state: JsonState r)
        : S (Read r + Write r) (Maybe Json)
 | Just tx      <- pullString state
 = Just (JsonString tx)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseString


-- | Pull a quoted string from the source.
pullString (state: JsonState r)
        : S (Read r + Write r) (Maybe Text)
 | matchChar '"' state
 , Just cs      <- takeStringChars state
 , matchChar '"' state
 = Just (textOfCharList cs)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseString


-- | Take string characters from the source,
--   not including the final '"' char.
takeStringChars (state: JsonState r)
        : S (Read r + Write r) (Maybe (List Char))
 | Just c <- peekChar state
 = match
        | c == '"'      = Just Nil

        | Just _        <- pullChar state
        , Just cs       <- takeStringChars state
        = Just (Cons c cs)

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseString


---------------------------------------------------------------------------------------------------
-- | Pull a JSON list from the source.
pullJsonList (state: JsonState r)
        : S (Read r + Write r) (Maybe Json)
 | matchChar '[' state
 , Just es <- takeListElems state
 , matchChar ']' state
 = Just (JsonList es)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseList


-- | Take JSON list elements from the source,
--   not including the final ']' char.
takeListElems (state: JsonState r)
        : S (Read r + Write r) (Maybe (List Json))
 | Just c  <- do { skipSpace state; peekChar state }
 = match
        | c == ']'
        = Just Nil

        | Just e        <- pullJsonValue state
        , Just es       <- takeCommaListElems state
        = Just (Cons e es)

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseList


-- | Take comma prefixed JSON list fields from the source,
--   not including the final ']' char.
takeCommaListElems (state: JsonState r)
        : S (Read r + Write r) (Maybe (List Json))
 | Just c <- do { skipSpace state; peekChar state }
 = (match
        | c == ']'
        = Just Nil

        | c == ','
        , Just _        <- pullChar state
        , Just e        <- pullJsonValue state
        , Just es       <- takeCommaListElems state
        = Just (Cons e es)

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseList)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseList


---------------------------------------------------------------------------------------------------
-- | Pull a JSON object from the source.
pullJsonObject (state: JsonState r)
        : S (Read r + Write r) (Maybe Json)
 | matchChar '{' state
 , Just fs <- takeObjectFields state
 , matchChar '}' state
 = Just (JsonObject fs)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseObject


-- | Take JSON object fields from the source,
--   not including the final '}' char.
takeObjectFields (state: JsonState r)
        : S (Read r + Write r) (Maybe (List (Text, Json)))
 | Just c  <- do { skipSpace state; peekChar state }
 = match
        | c == '}'
        = Just Nil

        | Just f        <- pullField state
        , Just fs       <- takeCommaObjectFields state
        = Just (Cons f fs)

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseObject


-- | Take comma prefixed JSON object fields from the source,
--   not including the final '}' char.
takeCommaObjectFields (state: JsonState r)
        : S (Read r + Write r) (Maybe (List (Text, Json)))
 | Just c  <- do { skipSpace state; peekChar state }
 = (match
        | c == '}'
        = Just Nil

        | c == ','
        , Just _  <- do { skipSpace state; pullChar state }
        , Just f  <- pullField state
        , Just fs <- takeCommaObjectFields state
        = Just (Cons f fs)

        | otherwise
        = parseFail state $ JsonParsePos 0 JsonParseObject)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseObject


-- | Pull a single object field from the source.
pullField (state: JsonState r)
        : S (Read r + Write r) (Maybe (Text, Json))
 | Just f <- do { skipSpace state; pullString state }
 , do { skipSpace state; matchChar ':' state }
 , Just v <- pullJsonValue state
 = Just (f, v)

 | otherwise
 = parseFail state $ JsonParsePos 0 JsonParseField

