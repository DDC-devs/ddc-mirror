
module System.Runtime.Reflect
export  show_ValueFormat
        show_Value
        reflect_toValue
        reflect_formatOfValue

import Control.Exception
import System.IO.Console
import System.Runtime.Info
import Data.Numeric

import foreign abstract type
 -- Effect of computations that use the Reflection system.
 -- This includes both the
 --        *reification* of objects into generic values (a -> Value)
 --    and *reflection*  of generic values back into objects (Value -> a)
 Reflect : Effect

import foreign boxed type
 Value   : Data


-- Import primitive object functions from the runtime system.
--
-- Some of these need to be given different names as the Discus -> Salt
-- code generator also imports the same primitives, but at different types,
-- and we can't have the two imports conflicting in the generated Salt code.
--
import foreign c value
 ddcPrimReifyValue    : {@a: Data} -> a -> S Reflect Value

 ddcObjectFormat                                 : Value -> Nat
 ddcObjectInfoIndex_value  "ddcObjectInfoIndex"  : Value -> Word32

 ddcThunkParams_value      "ddcThunkParams"      : Value -> Nat
 ddcThunkBoxes_value       "ddcThunkBoxes"       : Value -> Nat
 ddcThunkArgs_value        "ddcThunkArgs"        : Value -> Nat
 ddcThunkRuns_value        "ddcThunkRuns"        : Value -> Nat

 ddcBoxedFields                                  : Value -> Nat
 ddcBoxedTag_value         "ddcBoxedTag"         : Value -> Nat
 ddcBoxedGetField_value    "ddcBoxedGetField"    : Value -> Nat -> Value

 ddcSmallPayloadSize_value "ddcSmallPayloadSize" : Value -> Nat

where

-------------------------------------------------------------------------------
data ValueFormat where
        -- | Format of a Thunk heap object.
        ValueFormatThunk
         : Nat -> Nat -> Nat -> Nat -> ValueFormat

        -- | Format of a Boxed heap object.
        ValueFormatBoxed
         :  Text   -- ^ Module name of definition.
         -> Text   -- ^ Constructor name.
         -> Nat    -- ^ Data contructor tag.
         -> Nat    -- ^ Number of fields in object.
         -> ValueFormat

        -- | Format of an Array heap object.
        ValueFormatArray
         : ValueFormat

        -- | Format of a Raw heap object.
        ValueFormatRaw
         : ValueFormat

        -- | Format of a Small heap object.
        ValueFormatSmall
         :  Text   -- ^ Module name of definition ("Base" for builtin types)
         -> Text   -- ^ Contructor name ("Nat", Word16 etc for builtin types)
         -> Nat    -- ^ Size of payload.
         -> ValueFormat


show_ValueFormat: Show ValueFormat
 = Show reflect_showValueFormat

reflect_showValueFormat (f: ValueFormat): Text
 = case f of
        ValueFormatThunk
         -> "THUNK"

        ValueFormatBoxed moduleName ctorName tag nFields
         -> "BOXED" %% moduleName %% ctorName %% show tag %% show nFields

        ValueFormatArray
         -> "ARRAY"

        ValueFormatRaw
         -> "RAW"

        ValueFormatSmall nModule nCtor nSize
         -> "SMALL" %% show nModule %% show nCtor %% show nSize


-------------------------------------------------------------------------------
-- | Throw a reflection failure exception.
reflect_fail (tx: Text): a
 = ddcPrimExceptionThrow {@Pure}
 $ ExceptionSystemReflect tx


-------------------------------------------------------------------------------
-- | Reify the runtime representation of a value.
--
--   Operationally this is a no-op, but in the source language we assign it
--   an effectful type to track the fact that we're looking at the runtime
--   representation.
--
--   The representation may change when we recompile the program,
--   but it will not change at runtime after we have casted it to a generic
--   value.
--
reflect_toValue (x: a): S Reflect Value
 = ddcPrimReifyValue x


-- | Get the runtime representation format of a value.
reflect_formatOfValue (v: Value): ValueFormat
 = case ddcObjectFormat v of
        2 -> do nParams = ddcThunkParams_value v
                nBoxes  = ddcThunkBoxes_value  v
                nArgs   = ddcThunkArgs_value   v
                nRuns   = ddcThunkRuns_value   v
                ValueFormatThunk nParams nBoxes nArgs nRuns

        3 -> do tag     = ddcBoxedTag_value v
                nFields = ddcBoxedFields v
                infoIdx = ddcObjectInfoIndex_value v
                aEntry  = info_lookup infoIdx
                nModule = info_getModuleName aEntry
                nCtor   = info_getCtorName aEntry
                ValueFormatBoxed nModule nCtor tag nFields

        4 -> ValueFormatRaw

        5 -> ValueFormatArray

        6 -> do nSize   = ddcSmallPayloadSize_value v
                infoIdx = ddcObjectInfoIndex_value v
                aEntry  = info_lookup infoIdx
                nModule = info_getModuleName aEntry
                nCtor   = info_getCtorName aEntry
                ValueFormatSmall nModule nCtor nSize

        _ -> reflect_fail "formatOfValue"


-------------------------------------------------------------------------------
-- | Show dictionary for a Value.
show_Value: Show Value
 = Show reflect_showValue

-- | Show a generic Value.
--   Values build via the info table mechanism have enough information
--   to print them out in a human readable way.
reflect_showValue (v: Value): Text
 = case reflect_formatOfValue v of
        ValueFormatThunk nParams nBoxes nArgs nRuns
         -> parens
         $ "THUNK" %% show nParams %% show nBoxes %% show nArgs %% show nRuns

        ValueFormatBoxed txModuleName txCtorName nTag nFields
         |  nFields == 0
         -> txModuleName % "." % txCtorName

         | otherwise
         -> parens
          $ txModuleName % "." % txCtorName
          % foldl pastes ""
                (map (\n -> reflect_showValue (ddcBoxedGetField_value v n))
                     (generate nFields id))
        ValueFormatRaw
         -> "RAW"

        ValueFormatArray
         -> "ARRAY"

        ValueFormatSmall nModule nCtor nSize
         -> parens $ "SMALL" %% show nModule %% show nCtor %% show nSize

