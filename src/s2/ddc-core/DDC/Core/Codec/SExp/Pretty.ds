
-- | S-expression pretty printer for core expressions.
module DDC.Core.Codec.SExp.Pretty
export  { pretty_Nat;   pretty_Name
        ; pretty_Bound; pretty_Bind
        ; pretty_Term;  pretty_TermAtom; pretty_TermParam; pretty_TermArg; pretty_TermPrim
        ; pretty_Lets;  pretty_Alt;      pretty_Pat;       pretty_Cast
        }
import DDC.Core.Codec.SExp.Pretty.Base
import DDC.Core.Exp
import Class.Show
import Data.Text
where


pretty_Nat: Pretty Nat
 =  Pretty $ \n
 -> sexp1 "nat" (showNat n)


pretty_Name: Pretty Name
 =  Pretty $ \(Name n)
 -> sexp1 "name"("\"" % n % "\"")


pretty_Bound: Pretty Bound
 =  Pretty $ \(Bound n i)
 -> sexp2 "bound" (ppr n) (ppr i)


pretty_Bind: Pretty Bind
 =  Pretty $ \(Bind n)
 -> sexp1 "bind" (ppr n)


        -- Type constructors.
--        MPrimTyVoid     -> "ty_Void"
--        MPrimTyUnit     -> "ty_Unit"
--        MPrimTyArr      -> "ty_Arr"


-------------------------------------------------------------------------------
pretty_Term      {Pretty a} {Pretty p}: Pretty (Term a p)
 =  Pretty $ \xx
 -> case xx of
        MAnn a x        -> sexp2 "%mann"  (ppr a)   (ppr x)
        MVar   b        -> sexp1 "%mvar"  (ppr b)
        MAbs   m x      -> sexp2 "%mabs"  (ppr m)   (ppr x)
        MApp   x a      -> sexp2 "%mapp"  (ppr x)   (ppr a)
        MLet   lts x    -> sexp2 "%mlet"  (ppr lts) (ppr x)
        MCase  x as xd  -> sexp3 "%mcase" (ppr x)   (ppr as) (ppr xd)
        MCast  c x      -> sexp2 "%mcast" (ppr c)   (ppr x)
        MAtom  m        -> ppr m


pretty_TermAtom  {Pretty p}: Pretty (TermAtom p)
 =  Pretty $ \atom
 -> case atom of
        MAPrim m        -> sexp1 "%mprim" (ppr m)
        MACtor n        -> sexp1 "%mctor" (ppr n)
        MAFrag p        -> sexp1 "%mfrag" (ppr p)


pretty_TermParam {Pretty a} {Pretty p}: Pretty (TermParam a p)
 =  Pretty $ \mm
 -> case mm of
        MPTermX b t     -> "mpx" -- sexp1 "mpx"  (ppr x)
        MPTermI b t     -> "mpi" -- sexp1 "mpi"  (ppr x)


pretty_TermArg   {Pretty a} {Pretty p}: Pretty (TermArg a p)
 =  Pretty $ \arg
 -> case arg of
        MRTermX x       -> sexp1 "mrx"  (ppr x)
        MRTermI x       -> sexp1 "mri"  (ppr x)


pretty_TermPrim: Pretty TermPrim
 =  Pretty $ \pp
 -> case pp of
        -- Data constructors.
        MPConUnit       -> "mp-con-unit"


pretty_Lets  {Pretty a} {Pretty p}: Pretty (Lets a p)
 =  Pretty $ \lts
 -> case lts of
        LLet b x
         -> sexp2 "let"     (ppr b) (ppr x)

        LRec bxs
         -> sexp1 "rec"     (ppr bxs)

        LPrivate bs mt bxs
         -> sexp3 "private" (ppr bs) (ppr mt) (ppr bxs)


pretty_Alt  {Pretty a} {Pretty p}: Pretty (Alt a p)
 =  Pretty $ \alt
 -> case alt of
        AAlt w x        -> sexp2 "alt"    (ppr w) (ppr x)


pretty_Pat: Pretty (Pat a p)
 =  Pretty $ \pat
 -> case pat of
        AData n bs      -> sexp2 "data"   (ppr n) (ppr bs)


pretty_Cast {Pretty a} {Pretty p}: Pretty (Cast a p)
 =  Pretty $ \cc
 -> case cc of
        CEffect x       -> sexp1 "effect" (ppr x)
        CBox            -> "box"
        CRun            -> "run"



