module Runtime.Prim.CRegion

export foreign c value
 ddcPrimCompactRegionAlloc    : Nat# -> Nat#
 ddcPrimCompactRegionStore    : [r1  r2: Region]. Nat# -> Ptr# r1 Obj -> Ptr# r2 Obj
 ddcPrimCompactRegionMarkDead : Nat# -> Void#

 ddcCompactRegionIsLive: Addr# -> Bool#

import foreign c value
 malloc           : Nat#  -> Addr#
 free             : Addr# -> Void#
 ddcBoxedAlloc    : [r1    : Region]. Tag# -> Word32# -> Nat# -> Ptr# r1 Obj
 ddcBoxedGetField : [r1 r2 : Region]. Ptr# r1 Obj  -> Nat# -> Ptr# r2 Obj
 ddcBoxedSetField : [r1 r2 : Region]. Ptr# r1 Obj  -> Nat# -> Ptr# r2 Obj -> Void#
 ddcObjectSize    : [r1    : Region]. Ptr# r1 Obj  -> Nat#
 ddcPrimStdoutPutNat : Nat# -> Void#
 ddcPrimStdoutPutAddr : Addr# -> Void#
 ddcPrimStdoutPutTextLit : TextLit#   -> Void#
 ddcPerformGC : Unit -> Unit

with letrec

-- return a region handle
ddcPrimCompactRegionAlloc (initSize : Nat#) : Nat#
 = do   
      -- create CR and header
      rawBase = malloc initSize
      -- HEADER SIZE
      ddcCompactRegionConstructHeader 
                        rawBase 
                        (plusAddr# rawBase 17#)  -- top
                        (plusAddr# rawBase initSize) -- max
                        0b10000000w8# -- flags


      -- insert into the table
      ddcCompactRegionInsertTable rawBase

-- insert the CRTable
ddcCompactRegionInsertTable (rawBase : Addr#): Nat#
 = do
      tableMax = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
      tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
      freeAddr = ddcCompactRegionFindFreeRegionTableSlot tableBase tableMax

      -- ddcPrimStdoutPutTextLit "freeAddr: "#
      -- ddcPrimStdoutPutNat (truncate# [Nat#] freeAddr)

      -- ddcPrimStdoutPutTextLit "\n"#

      case eq# (truncate# [Nat#] freeAddr) 0# of
        True#  -> do  
                      ddcCompactRegionExtendsTable ()
                      ddcCompactRegionInsertTable rawBase
        False# -> do  handle = sub# freeAddr tableBase
                      write# freeAddr 0# rawBase 
                      handleNat = (truncate# [Nat#] handle)
                      -- ddcPrimStdoutPutNat handleNat
                      handleNat

-- extends the CRTable
ddcCompactRegionExtendsTable (u : Unit): Void#
 = do
      tableBaseOld = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
      tableMaxOld = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
      oldSize = truncate# [Nat#] (sub# tableMaxOld tableBaseOld)
      newSize = add# oldSize (read# (global# [Nat#] "ddcCRTableSize"#) 0#)
      -- ddcPrimStdoutPutTextLit "newSize:"#
      -- ddcPrimStdoutPutNat newSize
      -- ddcPrimStdoutPutTextLit "\n"#
      tableBaseNew = malloc newSize
      tableMaxNew = plusAddr# tableBaseNew (sub# newSize 1#)
 
      copy# tableBaseNew tableBaseOld oldSize
      free tableBaseOld
      write# (global# [Addr#] "ddcCRTableBase"#) 0# tableBaseNew
      write# (global# [Addr#] "ddcCRTableMax"#) 0# tableMaxNew
      
      

-- return -1 when table is full
-- otherwise return the address of the slot
ddcCompactRegionFindFreeRegionTableSlot (acc : Addr#) (max : Addr#) : Addr#
 = do 
      case gt# acc max of
        True# -> do (promote# [Addr#] 0#)
        False# -> do
                    slotVal = read# [Addr#] acc 0#
                    case eq# slotVal (promote# [Addr#] 0#) of
                      True# -> acc
                      False# -> ddcCompactRegionFindFreeRegionTableSlot (plusAddr# acc 8#) max


ddcPrimCompactRegionStore [r1 r2: Region] (handle : Nat#) (pVal : Ptr# r1 Obj) :  Ptr# r2 Obj
 = do
        -- handle validation
        handleValid = ddcCompactRegionHandleValidation handle
        case handleValid of
          False# 
            -> do fail# --invalid handle
          True#
            -> do tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
                  regionRawBase = read# [Addr#] tableBase handle
                  isDead = ddcCompactRegionIsLive regionRawBase
                  case isDead of
                    True#  -> fail# 
                    False# -> do  regionMax = read# [Addr#] regionRawBase 8#
                                  regionTop = read# [Addr#] regionRawBase 0#
                                  makePtr# (ddcCompactRegionResizeStore handle regionRawBase regionMax regionTop pVal)

-- set the flag to mark compact region dead
ddcPrimCompactRegionMarkDead (handle : Nat#) : Void#
 = do handleValid = ddcCompactRegionHandleValidation handle
      case handleValid of
        False# 
          -> do fail# --invalid handle
        True#
          -> do tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
                regionRawBase = read# [Addr#] tableBase handle
                flag8  = truncate# [Word8#] (read# [Addr#] regionRawBase 0#)
                write# regionRawBase 0# (band# flag8 0b01111111w8#) 
                


ddcCompactRegionResizeStore [r1 : Region] 
                              (handle : Nat#)
                              (rawBase : Addr#)
                              (top  : Addr#)
                              (max  : Addr#)
                              (pVal : Ptr# r1 Obj )
                              : Addr#
  = do  freeSize = sub# max top
        case lt# (ddcObjectSize pVal) (truncate# [Nat#] freeSize) of
          False# 
            -> do newSize = mul# (truncate# [Nat#] (sub# max rawBase)) 2# --TODO: a better strategy
                  rawBaseNew = malloc newSize

                  -- copy old data and old header
                  usedSize = truncate# [Nat#] (sub# top rawBase)
                  copy# rawBaseNew rawBase usedSize
                  -- update header
                  topNew = plusAddr# rawBaseNew usedSize
                  maxNew = plusAddr# rawBaseNew newSize
                  write# rawBaseNew 0# topNew
                  write# rawBaseNew 8# maxNew
                  free rawBase
                  -- trick, find another solution to this if possible.
                  ddcCompactRegionResizeStore handle rawBaseNew topNew maxNew pVal
          True#
            -> do -- store the object to the compact region
                  objAddrNew = ddcCompactRegionUnsafeDirectStore rawBase pVal 
                  -- update the address in the compact region table
                  tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0# 
                  write# tableBase handle rawBase
                  -- return the addr of object in the compact region
                  objAddrNew

ddcCompactRegionUnsafeDirectStore [r1 : Region]
                                    (rawBase : Addr#)
                                    (pVal    : Ptr# r1 Obj)
                                    : Addr#
  = do 
      -- make it addr
      rawObjAddr = takePtr# pVal
      -- get curr top
      top = read# rawBase 0#
      -- do the copy
      copy# top rawObjAddr (ddcObjectSize pVal)
      -- update top
      write# rawBase 0# (plusAddr# top (ddcObjectSize pVal))
      top

-- macro to write a header
ddcCompactRegionConstructHeader 
                  (rawBase : Addr#) 
                  (top : Addr#) 
                  (max : Addr#) 
                  (flags : Word8#) 
                  : Void#
  = do  write# rawBase 0# top
        write# rawBase 8# max
        write# rawBase 16# flags

-- TODO ask Ben how to define a constant
ddcCompactRegionRawBaseToBase (rawBase : Addr#) : Addr#
  = do 
      -- HEADER SIZE
      plusAddr# rawBase 17#


-- return true if the compact region is live
-- otherwise false
ddcCompactRegionIsLive (regionBase : Addr#) : Bool#
 = do   case eq# (truncate# [Nat#] regionBase) 0# of
          True#  -> False#
          False# -> do
                flag8  = truncate# [Word8#] (read# [Addr#] regionBase 0#)
                case band# flag8 0b10000000w8# of
                  0b10000000w8# -> True#
                  _             -> False#

-- return true if handle is valid
-- otherwise, false   
ddcCompactRegionHandleValidation (handle : Nat#) : Bool#
 = do
        tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
        tableMax = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
        tableSize = truncate# [Nat#] (sub# tableMax tableBase)
        lt# handle tableSize


-- iteratingOverRegionList (base : Addr#) (max : Addr#) (target : Addr#) : Unit
--  = do    
--         case ge# base max of 
--           True#
--             -> ()
--           False#
--             -> do 
--                   offset = read# [Nat#] base 8# 
--                   case gt# target base  of
--                     True#
--                       -> do
--                             case le# target (plusAddr# base offset) of
--                               True#
--                                 -> do
--                                       write# [Word8#] base 16# (bor# 0b10000000w8# (read# [Word8#] base 16#))
--                                       ()
--                               False#
--                                 -> iteratingOverRegionList (plusAddr# base 17#) max target
--                     False#
--                       -> do iteratingOverRegionList (plusAddr# base 17#) max target