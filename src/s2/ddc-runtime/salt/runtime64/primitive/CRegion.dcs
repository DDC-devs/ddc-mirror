module Runtime.Prim.CRegion

export foreign c value
 ddcPrimCompactRegionAlloc    : [r1 :Region]. Unit -> Nat#
 ddcPrimCompactRegionStore    : [r1  r2: Region]. Nat# -> Ptr# r1 Obj  -> Bool# -> Ptr# r2 Obj
 ddcPrimCompactRegionMarkDead : [r1 : Region]. Nat# -> Unit

 ddcCompactRegionDestroy      : Addr# -> Unit
 ddcCompactRegionGetNext      : Addr# -> Addr#
 ddcCompactRegionGetRefList   : Addr# -> Addr#
 ddcCompactRegionGetTail      : Addr# -> Addr#
 ddcCompactRegionGetData      : Addr# -> Addr#


 ddcCompactRegionIsLive       : Addr# -> Bool#
 ddcCompactRegionDebugPrint   : TextLit# -> Unit
 ddcPrintCompactRegionHeader  : Addr# -> Unit
 ddcCompactRegionDebug        : Unit -> Bool#

 traceCR : Addr# -> Unit
 ddcTraceCRByHandle : Nat# -> Unit
 ddcAllocTestRaw : [r1: Region]. Nat# -> Ptr# r1 Obj

import foreign c value
 malloc           : Nat#  -> Addr#
 free             : Addr# -> Void#
 ddcBoxedAlloc    : [r1    : Region]. Tag# -> Word32# -> Nat# -> Ptr# r1 Obj
 ddcBoxedGetField : Addr#  -> Nat# -> Addr#
 ddcBoxedSetField : [r1 r2 : Region]. Ptr# r1 Obj  -> Nat# -> Ptr# r2 Obj -> Void#
 ddcBoxedFields         : [r1:    Region]. Ptr# r1 Obj -> Nat#

 ddcObjectSize    : Addr#  -> Nat#
 ddcObjectFormat  : Addr# -> Nat#
 ddcObjectSetCompactRegionFlag : [r: Region]. Ptr# r Obj -> Bool# -> Unit
 
 ddcObjectIsInCompactRegion : [r: Region]. Ptr# r Obj -> Bool#
 ddcPrimStdoutPutNat : Nat# -> Void#
 ddcPrimStderrPutNat : Nat# -> Void#
 ddcPrimStdoutPutAddr : Addr# -> Void#
 ddcPrimStderrPutAddr : Addr# -> Void#
 ddcPrimStdoutPutTextLit : TextLit#   -> Void#
 ddcPrimStderrPutTextLit : TextLit#   -> Void#
 ddcPrimShowNat          : Nat#     -> TextLit#
 ddcTraceObj            : [r: Region]. Bool# -> Bool# -> Ptr# r Obj -> Ptr# r Obj

 ddcRawAlloc            : [r1:    Region]. Word32# -> Nat# -> Ptr# r1 Obj


with letrec

ddcCompactRegionDebug (u : Unit) : Bool#
 = do 
      False#

crLength (node: Addr#) : Nat#
 = do next = ddcCompactRegionGetNext node 
      case eq# next node of
        True#  -> 1#
        False# -> add# 1# (crLength next)

ddcTraceCRByHandle ( handle : Nat# ) : Unit
 = do tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
      slot = plusAddr# tableBase handle
      traceCR (read# slot 0#)

traceCR (head : Addr#) : Unit
 = do 
    case True# of
      True# -> do ddcPrimStderrPutTextLit "Trace CR @ "#
                  ddcPrimStderrPutAddr head
                  ddcPrimStderrPutTextLit " "#
                  ddcPrintCompactRegionHeader head
                  ddcPrimStderrPutTextLit "[ \n"#
                  (case eq# head (ddcCompactRegionGetTail head) of
                    True# -> ()
                    False# -> do traceCR_iter (ddcCompactRegionGetNext head) (ddcCompactRegionGetTail head)
                                 ()
                  )
                  ddcPrimStderrPutTextLit "]"#
                  ddcPrimStderrPutTextLit "\n"#
                  refList = (ddcCompactRegionGetRefList head)
                  ddcPrimStderrPutTextLit "[ \n"#
                  (case eq# refList (ddcCompactRegionGetTail refList) of
                    True# -> ()
                    False# -> do traceRefList_iter (ddcCompactRegionGetNext refList) (ddcCompactRegionGetTail refList)
                                 ()
                  )
                  ddcPrimStderrPutTextLit "]"#
                  ddcPrimStderrPutTextLit "\n"#

                  ()
      _ -> ()

traceRefList_iter (curr : Addr#) (tail: Addr#): Unit
 = do 
      ddcPrimStderrPutTextLit " R: "#
      ddcPrimStderrPutAddr curr
      ddcPrimStderrPutTextLit "| Data: "#
      ddcPrimStderrPutAddr (ddcCompactRegionGetData curr)
      ddcPrimStderrPutTextLit " ->: "#
      real =  (read# (ddcCompactRegionGetData curr) 0#)
      ddcPrimStderrPutAddr real
      ddcPrimStderrPutTextLit "| Format: "#
      ddcPrimStderrPutNat (ddcObjectFormat real)
      ddcPrimStderrPutTextLit "| Size: "#
      ddcPrimStderrPutNat (ddcObjectSize real)
      ddcPrimStderrPutTextLit "\n"#
      case eq# curr tail of
        True#  -> ()
        False# -> traceRefList_iter (ddcCompactRegionGetNext curr) tail


traceCR_iter (curr : Addr#) (tail: Addr#): Unit
 = do 
      ddcPrimStderrPutTextLit " N: "#
      ddcPrimStderrPutAddr curr
      ddcPrimStderrPutTextLit "| Data: "#
      ddcPrimStderrPutAddr (ddcCompactRegionGetData curr)
      ddcPrimStderrPutTextLit "| Format: "#
      ddcPrimStderrPutNat (ddcObjectFormat (ddcCompactRegionGetData curr))
      ddcPrimStderrPutTextLit "| Size: "#
      ddcPrimStderrPutNat (ddcObjectSize (ddcCompactRegionGetData curr))
      ddcPrimStderrPutTextLit "\n"#
      case eq# curr tail of
        True#  -> ()
        False# -> traceCR_iter (ddcCompactRegionGetNext curr) tail


ddcCompactRegionDebugPrint (msg : TextLit#) : Unit
  = do
      case ddcCompactRegionDebug () of
        True# -> do ddcPrimStderrPutTextLit msg
                    ()
        False# -> ()

ddcPrintCompactRegionHeader (rawBase : Addr#) : Unit
  = do 
      case ddcCompactRegionDebug () of
        True# -> do ddcPrimStderrPutTextLit "CR-> Base: "#
                    ddcPrimStderrPutAddr rawBase
                    ddcPrimStderrPutTextLit "| Next: "#
                    ddcPrimStderrPutAddr (read# [Addr#] rawBase 0#)
                    ddcPrimStderrPutTextLit "| Tail: "#
                    ddcPrimStderrPutAddr (read# [Addr#] rawBase 8#)
                    ddcPrimStderrPutTextLit "| Flag: "#
                    ddcPrimStderrPutAddr (promote# [Addr#] (truncate# [Word8#] (read# [Addr#] rawBase 16#)))
                    ddcPrimStderrPutTextLit "| RefList: "#
                    ddcPrimStderrPutAddr (read# [Addr#] rawBase 17#)
                    ddcPrimStderrPutTextLit "| Length: "#
                    ddcPrimStderrPutNat (crLength rawBase)
                    (case eq# (truncate# [Nat#] (read# [Addr#] rawBase 17#)) 0# of 
                        True#  -> ()
                        False# -> do ddcPrimStderrPutTextLit "| RefList Length: "#
                                     ddcPrimStderrPutNat (crLength (read# [Addr#] rawBase 17#))
                                     ()
                    )
                    ddcPrimStderrPutTextLit "\n"#

                    ()
        _ -> ()



-- Ref List is the list of object compact region keeps live on the heap.
--| Compact Region Allocation
ddcPrimCompactRegionAlloc [r1 : Region] (u : Unit) : Nat#
 = do 
      regionRawBase = ddcCompactRegionAllocHead ()
      refListBase = ddcCompactRegionAllocHead ()
      ddcCompactRegionSetRefList regionRawBase refListBase

      ddcCompactRegionDebugPrint "Alloc| "#
      ddcPrintCompactRegionHeader regionRawBase

      ddcCompactRegionDebugPrint "Alloc RefList| "#
      ddcPrintCompactRegionHeader refListBase

      ddcCompactRegionInsertTable regionRawBase

-- head:   |next|tail|flags(live|x|x|x|x|x|x|x|)|RefList|
-- data:   |next|xxxx|xxxx|xxxx|
-- size:     8    8    1    8
-- offset:   0    8    16   17
ddcCompactRegionAllocHead (u : Unit) : Addr#
 = do
      headBase = malloc 32#
      ddcCompactRegionSetNext headBase headBase
      ddcCompactRegionSetTail headBase headBase
      ddcCompactRegionSetLive headBase True#
      headBase
      
-- setters
ddcCompactRegionSetNext (node : Addr#) (next : Addr#): Unit
 = do write# node 0# next
      ()

ddcCompactRegionSetTail (node : Addr#) (tail : Addr#): Unit
 = do write# node 8# tail
      ()

ddcCompactRegionSetLive (head : Addr#) (isLive : Bool#): Unit
 = do (case isLive of
        True# -> do write# head 16# 0b11111111w8#
                    ()
        False# -> do write# head 16# 0b11111110w8#
                     ()
        )
      ()

ddcCompactRegionSetRefList (head : Addr#) (refList : Addr#) : Unit
 = do write# head 17# refList
      ()
  
-- getters
ddcCompactRegionGetNext (node : Addr#) : Addr#
 = do r = read# node 0#
      r

ddcCompactRegionGetTail (node : Addr#) : Addr#
 = do r = read# node 8#
      r

ddcCompactRegionIsLive (head : Addr#) : Bool#
 = do   case eq# (truncate# [Nat#] head) 0# of
          True#  -> do False#
          False# -> do
                flag8  = truncate# [Word8#] (read# [Addr#] head 16#)
                case band# flag8 0b0000001w8# of
                  0b00000001w8# -> True#
                  _             -> False#

ddcCompactRegionGetRefList (head : Addr#) : Addr#
 = do r = read# head 17#
      r

ddcCompactRegionGetData (node : Addr#) : Addr#
 = do r = plusAddr# node 32#
      r

-- free compact region list
ddcCompactRegionDestroy (head : Addr#) : Unit
 = do refList = ddcCompactRegionGetRefList head
      ddcCompactRegionDestroyPrim refList (ddcCompactRegionGetTail refList)
      ddcCompactRegionDestroyPrim head (ddcCompactRegionGetTail head)
      ()

ddcCompactRegionDestroyPrim (curr : Addr#) (max : Addr#) : Unit
 = do case eq# curr max of
        True#  -> do free curr
                     ()
        False# -> do next = ddcCompactRegionGetNext curr
                     ddcCompactRegionDestroyPrim next max
                     free curr
                     ()

-- procedure to insert into global table, should be inlined.
ddcCompactRegionInsertTable (rawBase : Addr#): Nat#
 = do
      -- read the address of the CR Table
      tableMax = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
      tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
      freeAddr = ddcCompactRegionFindFreeRegionTableSlot tableBase tableMax

      case eq# (truncate# [Nat#] freeAddr) 0# of
        True#  -> do  -- the table is full, extend the table and try itself again.
                      ddcCompactRegionExtendsTable ()
                      ddcCompactRegionInsertTable rawBase -- TODO: infinit loop?
        False# -> do  handle = sub# freeAddr tableBase
                      write# freeAddr 0# rawBase 
                      handleNat = (promote# [Nat#] handle)
                      handleNat

-- extends the CRTable
ddcCompactRegionExtendsTable (u : Unit): Void#
 = do
      -- read from globals
      tableBaseOld = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
      tableMaxOld = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
      oldSize = truncate# [Nat#] (sub# tableMaxOld tableBaseOld)

      -- create new table
      newSize = add# oldSize (read# (global# [Nat#] "ddcCRTableSize"#) 0#)
      tableBaseNew = malloc newSize
      tableMaxNew = plusAddr# tableBaseNew (sub# newSize 1#)
      -- copy and Destroy old one
      copy# tableBaseNew tableBaseOld oldSize
      free tableBaseOld

      -- update globals
      write# (global# [Addr#] "ddcCRTableBase"#) 0# tableBaseNew
      write# (global# [Addr#] "ddcCRTableMax"#) 0# tableMaxNew

-- return 0# when table is full
-- otherwise return the address of the slot
ddcCompactRegionFindFreeRegionTableSlot (acc : Addr#) (max : Addr#) : Addr#
 = do 
      case gt# acc max of
        True# -> do (promote# [Addr#] 0#)
        False# -> do
                    slotVal = read# [Addr#] acc 0#
                    case eq# slotVal (promote# [Addr#] 0#) of
                      True# -> acc
                      False# -> ddcCompactRegionFindFreeRegionTableSlot (plusAddr# acc 8#) max

--| Store object into the compact region (append)
ddcPrimCompactRegionStore [r1 r2: Region] (handle : Nat#) (pVal : Ptr# r1 Obj) (ignoreRef : Bool#):  Ptr# r2 Obj
 = do
        -- handle validation
        handleValid = ddcCompactRegionHandleValidation handle
        case handleValid of
          False# 
            ->  do ddcCompactRegionDebugPrint "Invalid Region handle!"#
                   fail# --invalid handle
          True#
            -> do tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
                  slot = plusAddr# tableBase handle
                  obj = ddcCompactRegionStore (read# slot 0#) pVal ignoreRef
                  -- traceCR (read# slot 0#)
                  obj
                  


ddcCompactRegionStore [r1 r2 : Region] (head : Addr#) (pVal : Ptr# r1 Obj) (ignoreRef : Bool#) : Ptr# r2 Obj
 = do 
      tail = ddcCompactRegionGetTail head
      isLive = ddcCompactRegionIsLive head
      
      (case isLive of
        False# -> do ddcCompactRegionDebugPrint "Access dead region\n"#
                     fail#
        True#  -> ())
      -- store the obj into next node
      node = ddcCompactRegionCreateDataNode pVal
      ddcCompactRegionSetNext tail node
      ddcCompactRegionSetTail head node
      objInRegion = makePtr# (ddcCompactRegionGetData node)
      -- store obj with ref on the heap to refList
      (case ignoreRef of 
        True# -> ()
        False# -> do ddcCompactRegionUpdateRefList head objInRegion
                     ()
      )

      -- ddcTraceObj True# True# objInRegion

      

      -- ddcCompactRegionDebugPrint "objInRegion: "#
      -- ddcPrimStderrPutAddr (ddcCompactRegionGetData node)
      -- ddcCompactRegionDebugPrint "\n "#

      ddcCompactRegionDebugPrint "Post Store| "#
      ddcPrintCompactRegionHeader head
      
      objInRegion

ddcCompactRegionCreateDataNode [r1 : Region] (pVal : Ptr# r1 Obj) : Addr#
 = do size = ddcObjectSize (takePtr# pVal)
      node = malloc (add# size 32#)
      ddcCompactRegionSetNext node node
      ddcCompactRegionSetTail node node
      top = plusAddr# node 32#
      -- ddcCompactRegionDebugPrint "dataNodeTop: "#
      -- ddcPrimStderrPutAddr top
      -- ddcCompactRegionDebugPrint "Size: "#
      -- ddcPrimStderrPutNat size
      -- ddcCompactRegionDebugPrint "\n"#

      -- do the copy
      copy# top (takePtr# pVal) size
      -- set the CR flag
      ddcObjectSetCompactRegionFlag [r1] (makePtr# top) True#
      node

-- check object type
ddcCompactRegionUpdateRefList [r1 : Region]
                        (head : Addr#)
                        (pVal    : Ptr# r1 Obj)
                        : Unit
  = do case ddcObjectFormat (takePtr# pVal) of
          2# -> do ddcCompactRegionUpdateReflistPrim head pVal --thunk
                   ()
          3# -> do ddcCompactRegionUpdateReflistPrim head pVal --boxed
                   ()
          4# -> do () --raw
          5# -> do () --array TODO: what to do? 
          _  -> do () --mhm...


-- optimization attempts to only put object with ref to heap
-- to the ref list
-- need a write barrier to keep the ref safe.
ddcCompactRegionBoxed_opt [r1 : Region] 
        (head : Addr#) 
        (pVal : Ptr# r1 Obj) -- original object
        (iArg           : Nat#)
        (nArgs          : Nat#)
        : Unit
 = case ge# iArg nArgs of
    True#  -> ()
    False# -> do
        aArgFrom  = ddcBoxedGetField (takePtr# pVal) iArg
        case eq# (truncate# aArgFrom) 0# of
         True#  -> ddcCompactRegionBoxed_opt head pVal (add# iArg 1#) nArgs
         False# -> do
                case (ddcObjectIsInCompactRegion [r1] (makePtr# aArgFrom)) of
                  True# -> do ddcCompactRegionBoxed_opt head pVal (add# iArg 1#) nArgs
                  False# -> do ddcCompactRegionUpdateReflistPrim [r1] head (makePtr# aArgFrom) 
                               ddcCompactRegionBoxed_opt head pVal (add# iArg 1#) nArgs


ddcCompactRegionUpdateReflistPrim [r1 : Region]
                            (head : Addr#)
                            (pVal    : Ptr# r1 Obj)
                            : Unit
  = do  
        objBase = takePtr# pVal

        refList = ddcCompactRegionGetRefList head
        refListTail = ddcCompactRegionGetTail refList
        case eq# (promote# [Nat#] refList) 0# of
          False# -> do node = malloc (add# 8# 32#) -- pointer size + header size
                       ddcCompactRegionSetNext node node
                       ddcCompactRegionSetTail node node

                       ddcCompactRegionSetNext refListTail node
                       ddcCompactRegionSetTail refList node
                       write# node 32# objBase
                       ()
          True# -> do ()
        


--| set the flag to mark compact region dead
ddcPrimCompactRegionMarkDead [r1 : Region]  (handle : Nat#) : Unit
 = do handleValid = ddcCompactRegionHandleValidation handle
      case handleValid of
        False# 
          -> do ddcCompactRegionDebugPrint "invalid handle!"#
                fail# --invalid handle
        True#
          -> do tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
                regionRawBase = read# [Addr#] tableBase handle
                
                flag8  = truncate# [Word8#] (read# [Addr#] regionRawBase 16#) --TODO: 

                -- mark compact region dead by set the flag
                write# regionRawBase 16# (band# flag8 0b11111110w8#) 
                -- mark each object 'free' from life cycle constraints
               
                (case eq# regionRawBase (ddcCompactRegionGetTail regionRawBase) of
                  True#  -> ()
                  False# -> ddcCompactRegionMarkObjectFree [r1] (ddcCompactRegionGetNext regionRawBase) (ddcCompactRegionGetTail regionRawBase)
                )
                ddcCompactRegionDebugPrint "MarkDead| "#
                ddcPrintCompactRegionHeader regionRawBase
                ()

ddcCompactRegionMarkObjectFree [r1 : Region] (curr : Addr#) (last : Addr#) : Unit
 = do  currData = ddcCompactRegionGetData curr
      --  ddcCompactRegionDebugPrint "Free Obj from CR| "#
      --  ddcPrimStderrPutAddr currData
      --  ddcCompactRegionDebugPrint " | flag before "#

      --  (case (ddcObjectIsInCompactRegion [r1] (makePtr# currData)) of 
      --   True# -> do ddcPrimStderrPutNat 1#
      --               ()
      --   False# -> do ddcPrimStderrPutNat 0#
      --                ()
      --  )
      --  ddcPrimStderrPutAddr (read# currData 0#)

       -- mark current obj free
       ddcObjectSetCompactRegionFlag [r1] (makePtr# currData) False#

      --  ddcCompactRegionDebugPrint " | flag "#
      --  (case (ddcObjectIsInCompactRegion [r1] (makePtr# currData)) of 
      --   True# -> do ddcPrimStderrPutNat 1#
      --               ()
      --   False# -> do ddcPrimStderrPutNat 0#
      --                ()
      --  )
      --  ddcPrimStderrPutAddr (read# currData 0#)

      --  ddcCompactRegionDebugPrint "\n"#

       case eq# curr last of 
         True#  -> do ()
         False# -> do ddcCompactRegionMarkObjectFree [r1] (ddcCompactRegionGetNext curr) last      
                

-- return true if handle is valid
-- otherwise, false   
ddcCompactRegionHandleValidation (handle : Nat#) : Bool#
 = do
        tableBase = read# [Addr#] (global# [Addr#] "ddcCRTableBase"#) 0#
        tableMax = read# [Addr#] (global# [Addr#] "ddcCRTableMax"#) 0#
        tableSize = truncate# [Nat#] (sub# tableMax tableBase)
        lt# handle tableSize



ddcAllocTestRaw [r1: Region] (size : Nat#) : Ptr# r1 Obj
 = do
      ddcRawAlloc [r1] (truncate# 2#) size
