
module SMR.Prim.Op.Smr
export makePrimOpsSmr
import SMR.Prim.Op.Base
import SMR.Transform.Combinate
where


-------------------------------------------------------------------------------
-- | Shimmer expression functions reflected back as primops.
--   TODO: shouldn't need to supply dictionary here.
makePrimOpsSmr {eqs: Eq s} (_ : Unit): List (PrimEval s Prim)
 = Cons (primOpSmrExpEqual {eqs})
 $ Cons primOpSmrEvalCbv
 $ Cons primOpSmrEvalFail
 $ Cons primOpSmrCombinateSKI
 $ Nil


-------------------------------------------------------------------------------
-- | Equality on expressions.
primOpSmrExpEqual {Eq s}: PrimEval s Prim
 = PrimEval (PrimOp "smr-exp-equal") "syntactic equality of expressions"
            (Cons Exp (Cons Exp Nil)) fn'
 where fn'  (Cons xA (Cons xB Nil))
        = Just $ makeXBool (xA == xB)


-------------------------------------------------------------------------------
-- | Evaluate call-by-value.
primOpSmrEvalCbv: PrimEval s Prim
 = PrimEval (PrimOp "smr-eval-cbv") "call-by-value evaluation"
            (Cons Val Nil) fn'
 where fn'  (Cons xF  Nil)
        = do    str     = StepStrength False False
                ctx     = StepContext  Nil Nil
                case xF of
                 XKey KBox xF'
                     -> case steps str ctx xF' of
                         Left err   -> Just $ XRef (RPrm (PrimOp "smr-eval-fail"))
                         Right xF'  -> Just $ XKey KBox xF'

                 xF' -> case steps str ctx xF' of
                         Left  err  -> Just $ XRef (RPrm (PrimOp "smr-eval-fail"))
                         Right xF'  -> Just $ XKey KBox xF'


-- | Indicate evaluation failure.
primOpSmrEvalFail: PrimEval s Prim
 = PrimEval (PrimOp "smr-eval-fail") "indicate evaluation failure"
            Nil fn'
 where  fn' _ = Nothing


-------------------------------------------------------------------------------
-- TODO: don't require all the combs to be specified in the public interface,
-- though can still have that config internally.
primOpSmrCombinateSKI: PrimEval s Prim
 = PrimEval
        (PrimOp "smr-combinate-ski")
        "Convert expression to SKI combinator form."
        (Cons Val (Cons Val (Cons Val                   -- s k i
        (Cons Val (Cons Val                             -- b c
        (Cons Val (Cons Val (Cons Val                   -- sp bs cp
        (Cons Val Nil)))))))))                          -- exp
        fn'
 where
        fn' as0
         | Just (xS,   as1) <- takeArgExp as0
         , Just (xK,   as2) <- takeArgExp as1
         , Just (xI,   as3) <- takeArgExp as2
         , Just (xB,   as4) <- takeArgExp as3
         , Just (xC,   as5) <- takeArgExp as4
         , Just (xSp,  as6) <- takeArgExp as5
         , Just (xBs,  as7) <- takeArgExp as6
         , Just (xCp,  as8) <- takeArgExp as7
         , Just (xExp, Nil) <- takeArgExp as8
         = Just $ XKey KBox
                $ combinate
                        { Combinate
                                (fromBox xS)  (fromBox xK)  (fromBox xI)
                                (fromBox xB)  (fromBox xC)
                                (fromBox xSp) (fromBox xBs) (fromBox xCp)
                        }
                        (fromBox xExp)

         | otherwise
         = Nothing


-- | If this is a boxed expression then unwrap one level of boxing,
--   otherwise return the original expression.
fromBox (xx: Exp s Prim): Exp s Prim
 = case xx of
        XKey KBox x'    -> x'
        _               -> xx
