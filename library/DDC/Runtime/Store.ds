{-# OPTIONS -no-implicit-prelude #-}

-- Hooks onto DDC's runtime primitives.
--	This gives direct access to the store.
--	Sooo many ways to crash and burn
--
module	DDC.Runtime.Store
import	Base

-- DataR -------------------------------------------------------------------------------------------
-- | Get the size of this entire DataR object.
foreign import "primStore_peekDataR_size"
 peekDataR_size	
 	:: forall a. a -> Int32#

	
-- | Get a pointer to the payload of this DataR object.
foreign import "primStore_peekDataR_payload"
 peekDataR_payload
 	:: forall a. a -> Ptr# Word8#


-- | Get a pointer to the payload of this DataR object.
foreign import "primStore_peekDataRS_payload"
 peekDataRS_payload
 	:: forall a. a -> Ptr# Word8#
	

-- Ptr ---------------------------------------------------------------------------------------------
-- | Advances the pointer by the given offset in bytes
foreign import "_PLUSPTR"
 plusPtr	:: Ptr# Word8# -> Int# -> Ptr# Word8#


-- | Read a value from the address given by a pointer.
foreign import "_PEEK"
 peek		:: forall a. Ptr# a -> a


-- | Like `peek` but assign a read effect to the region holding the given object.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_PEEKON"
 peekOn	:: forall (t :: % -> *) a
	.  t %r1 -> Ptr# a -(!e1)> a
	:- !e1 = !Read %r1
	:$ Obj -> Obj -> Obj


-- | Write a value to the address given by a pointer.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_POKE"
 poke		:: forall a. Ptr# a -> a -> Void#


-- | Like `poke` but assign a write effect to the region holding the given object.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_POKEON"
 pokeOn	:: forall (t :: % -> *) a
	.  t %r1 -> Ptr# a -> a -(!e1)> ()
	:- !e1 = !Write %r1
	:$ Obj -> Obj -> Obj -> Obj


-- Taste -------------------------------------------------------------------------------------------
-- | Phantom type used to carry around a region constraint.
data Taste %r

-- | Sample the right-most region variable in a type.
--   This can be useful when contraining the region to be the same as another, 
--   or causing a read or write effect on it separate from the actual objects
--   contained in the region.
foreign import 
 taste	:: forall (t :: % -> *). t %r1 -> Taste %r1
	:$ Data -> Data


-- Poke --------------------------------------------------------------------------------------------
foreign import "primStore_pokeInt32"
 pokeInt32 	:: Ptr# Int32# -> Int32# -> Void#


-- Casting -----------------------------------------------------------------------------------------
-- These should go somewhere else
--
foreign import "(Word8 *)"
 castToPtrWord8
 	:: forall a
	.  Ptr# a -> Ptr# Word8#

foreign import "(Word32 *)"
 castToPtrWord32
 	:: forall a
	.  Ptr# a -> Ptr# Word32#

foreign import "(Int32 *)"
 castToPtrInt32
 	:: forall a
	.  Ptr# a -> Ptr# Int32#

foreign import "(Int64 *)"
 castToPtrInt64
 	:: forall a
	.  Ptr# a -> Ptr# Int64#

foreign import "(Float32 *)"
 castToPtrFloat32
 	:: forall a
	.  Ptr# a -> Ptr# Float32#

foreign import "(Float64 *)"
 castToPtrFloat64
 	:: forall a
	.  Ptr# a -> Ptr# Float64#

foreign import "(Char32 *)"
 castToPtrChar32
 	:: forall a 
 	.  Ptr# a -> Ptr# Char32#


-- TODO: redo these as peek/poke functions.
foreign import "primInt32U_read"
 primInt32U_read
 	:: forall a 
	.  a -> Int32# -> Int32#		-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Int32#
	
foreign import "primInt32U_write"
 primInt32U_write
 	:: forall a
	.  a -> Int32# -> Int32# -> Void#	-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Int32# -> Void#

foreign import "primFloat32U_read"
 primFloat32U_read
 	:: forall a
	.  a -> Int32# -> Float32#		-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Float32#
	
foreign import "primFloat32U_write"
 primFloat32U_write
 	:: forall a
	.  a -> Int32# -> Float32# -> Void#	-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Float32# -> Void#
