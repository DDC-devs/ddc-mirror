{-# OPTIONS -no-implicit-prelude #-}

-- Hooks onto DDC's runtime primitives.
--	This gives direct access to the store.
--	Sooo many ways to crash and burn
--
module	DDC.Runtime.Store
import	Base


-- Raw Data Internals ---------------------------------------------------------
-- | Get the size of this entire DataR object.
foreign import "primStore_peekDataR_size"
 peekDataR_size	
 	:: forall a. a -> Int32#

	
-- | Get a pointer to the payload of this DataR object.
foreign import "primStore_peekDataR_payload"
 peekDataR_payload
 	:: forall a. a -> Ptr# Word8#


-- | Get a pointer to the payload of this DataR object.
foreign import "primStore_peekDataRS_payload"
 peekDataRS_payload
 	:: forall a. a -> Ptr# Word8#
	

-- Ptr ------------------------------------------------------------------------
-- | Advances the pointer by the given offset in bytes
foreign import "_PLUSPTR"
 plusPtr :: Ptr# Word8# -> Int# -> Ptr# Word8#


-- | Read a value from the address given by a pointer.
foreign import "_PEEK"
 peek	:: forall a. Ptr# a -> a


-- | Like `peek` but assign a read effect to the region holding the given object.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_PEEKON"
 peekOn	:: forall (t :: % -> *) a
	.  t %r1 -> Ptr# a -(!e1)> a
	:- !e1 = !Read %r1
	:$ Obj -> Obj -> Obj


-- | Write a value to the address given by a pointer.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_POKE"
 poke	:: forall a. Ptr# a -> a -> Void#


-- | Like `poke` but assign a write effect to the region holding the given object.
--   TODO: This is just a macro in C land, so we can't partially apply it.
foreign import "_POKEON"
 pokeOn	:: forall (t :: % -> *) a
	.  t %r1 -> Ptr# a -> a -(!e1)> ()
	:- !e1 = !Write %r1
	,  Mutable %r1
	:$ Obj -> Obj -> Obj -> Obj


-- Taste ----------------------------------------------------------------------
-- | Phantom type used to carry around a region variable.
data Taste %r

-- | Sample the right-most region variable in a type.
--   This can be useful when contraining a region variable to be the same as another, 
--   or causing a read or write effect on it separate from the actual objects
--   contained in the region.
foreign import 
 taste	:: forall (t :: % -> *). t %r1 -> Taste %r1
	:$ Data -> Data


-- Casting --------------------------------------------------------------------
-- TODO: If we had better support for inline type annots then we
--       wouldn't need these.

foreign import "(Word8 *)"
 castToPtrWord8
 	:: forall a
	.  Ptr# a -> Ptr# Word8#

foreign import "(Word32 *)"
 castToPtrWord32
 	:: forall a
	.  Ptr# a -> Ptr# Word32#

foreign import "(Word64 *)"
 castToPtrWord64
 	:: forall a
	.  Ptr# a -> Ptr# Word64#

foreign import "(Int32 *)"
 castToPtrInt32
 	:: forall a
	.  Ptr# a -> Ptr# Int32#

foreign import "(Int64 *)"
 castToPtrInt64
 	:: forall a
	.  Ptr# a -> Ptr# Int64#

foreign import "(Float32 *)"
 castToPtrFloat32
 	:: forall a
	.  Ptr# a -> Ptr# Float32#

foreign import "(Float64 *)"
 castToPtrFloat64
 	:: forall a
	.  Ptr# a -> Ptr# Float64#

foreign import "(Char32 *)"
 castToPtrChar32
 	:: forall a 
 	.  Ptr# a -> Ptr# Char32#
