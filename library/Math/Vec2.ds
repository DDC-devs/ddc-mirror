
import Prelude;

-- A polymorphic vector of dimension 2;
data Vec2 %r1 a
	= Vec2 {
		x	:: a;
		y	:: a;
	};

-- Operations on float vectors
project Vec2 Float where
{
	-- Update a vector.
	update :: Vec2 Float -> Vec2 Float -> ();
	update (Vec2 x1 y1) (Vec2 x2 y2)
	 = do {	x1	:= x2;
	 	y1	:= y2;
	 };


	-- Compute the angle of a vector (in radians)
	angle :: Vec2 Float -> Float;
	angle (Vec2 x y)	
	 = do {
		pi 		= 3.1415926536;
	 	if x < 0.0 
		 	then pi + atan (y / x)
			else atan (y / x);
	 };

	-- | Take the magnitute of a vector.
	magnitude (Vec2 x y)
	 	= sqrt (x * x + y * y);


	-- | Multiply a vector by a scalar.
	muls :: Vec2 Float -> Float -> Vec2 Float;
	muls (Vec2 x1 y1) s
	 	= Vec2 (s * x1) (s * y1);

	-- | Add two vectors component wise.
	add :: Vec2 Float -> Vec2 Float -> Vec2 Float;
	add (Vec2 x1 y1) (Vec2 x2 y2)  	
		= Vec2 (x1 + x2) (y1 + y2);

	-- | Show a vector as a string.
	show :: Vec2 Float -> String;
	show (Vec2 x y)	
	 	= "Vec2 " % showFloat x % " " % showFloat y;

	-- | Accumulate a vector component-wise.
	acc :: Vec2 Float -> Vec2 Float -> ();
	acc (Vec2 x1 y1) (Vec2 x2 y2)
	 = do {	x1	+= x2;
	 	y1	+= y2;
	 };

	-- | Sum up a list of vectors component wise
	sum :: [Vec2 Float] -> Vec2 Float;
	sum xx 
	 = Vec2 (foldl (+) 0.0 $ map (\v -> v.x) xx) 
		(foldl (+) 0.0 $ map (\v -> v.y) xx);

}

{-
vec2_angleU :: Float32# -> Float32# -> Float32#;
vec2_angleU x y
 = do {
 	pi	= 3.1415926536#;
	match {
		|# x `primFloat32U_lt` 0.0#
		= pi + atanU (y / x);
		
		\= atanU (y / x);
	};
 };
-}


vec2_update 	= update&{Vec2 Float};
vec2_acc 	= acc	&{Vec2 Float};
vec2_add 	= add	&{Vec2 Float};
vec2_show	= show	&{Vec2 Float};

instance Num (Vec2 Float) where
{
	(+) 	= vec2_add;
}

instance Update (Vec2 Float) where
{
	(:=)	= vec2_update;

}

instance Accum (Vec2 Float) where
{
	(+=)	= vec2_acc;
}

instance Show (Vec2 Float) where
{	
	show	= vec2_show;
}
