{-# OPTIONS -no-implicit-prelude #-}

import	Base
import	Data.Int
import	Data.String
import	System.Console
import	Control.Imperative

-- Functions which might throw a user exception have the Throw effect.
--	Non-exhaustive pattern match, and array bounds exceptions are not included
--	in this. These effects should always be fatal.
effect !Throw	:: !


foreign import "primException_init"
 primExceptionInit
	:: forall %r1
	.  Int %r1 -> ()
	:$ Obj -> Obj

foreign import "primException_try"	
 primTry
	:: forall a %r !e1 !e2 $c1
	.  (() -(!e1 $c1)> a) -> (Exception %r -(!e2)> a) -(!e3 $c3)> a
	:- !e3 = !{ !e1; !e2 }
	,  $c3 = f : $c1
	:$ Obj -> Obj -> Obj
		
foreign import "primException_throw"
 primThrow
	:: forall a %r
	.  Exception %r -(!e1)> a
	:- !e1 = !{ !Throw }
	:$ Obj -> Obj

foreign import "primException_throw"
 primThrow_silent
	:: forall a %r
	.  Exception %r -> a
	:$ Obj -> Obj


foreign import "primException_handleUncaught"
 primHandleUncaught
	:: forall a %r
	.  Exception %r -> a
	:$ Obj -> Obj


foreign import "exit"
 exitU :: Int32# -> a
 
error  ss 	= throw Exception ss
errorL ss	= primThrow_silent @ (Exception ss)

exit code	
 = do	exitU (unboxInt32 code)
 	()
	

		
-- | This is the top level exception handler which wraps the main function.
--	It catches unhandled exceptions from the user program and prints a nice error message.
topHandle :: (() -> a) -> a
topHandle f
 = 	try f ()
	catch 
		Exception msg	
		 -> 	print	$ "*** DDC RTS: Caught exception - " % msg % "\n"

		ExceptionIO	
		 -> 	print	$ "*** DDC RTS: Caught IO exception.\n"
		 		% "\n"

		ExceptionCaseNoMatch name line column
		 -> 	print	$ "*** DDC RTS: Non-exhaustive patterns in "
		 		% name	
				-- file position info is broken (ticket #119)
				-- % ":" % show line % ":" % show column % "\n"
				% "\n\n"

		ExceptionArrayBounds size ix
		 ->	print	$ "*** DDC RTS: Array bounds exception.\n"
				% "      Tried to access array at index: " % string_Int32 ix	% "\n"
				% "           which is outside of range: [0 .. " % string_Int32 (size - 1) % "]\n"
				% "\n"
	with exit 1


-- A break gate.
--	Evaluate this function
--	if it throws a break exception then return normally.
gate :: (() -> ()) -> ()
gate f	
 = 	try f ()
 	catch	ExceptionBreak	-> ()


-- A looping break gate.
--	Evaluate this function endlessly
--	if it throws a break exception then return normally. 
gateLoop :: (() -> ()) -> ()
gateLoop f 
 = 	try loop f
 	catch	ExceptionBreak	-> ()


