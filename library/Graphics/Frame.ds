
import	Graphics.TinyPTC
import	Graphics.Raster.Bresenham

-- A frame of pixels that can be drawn on the screen.
--	Allow the pixels to be mutable while the sizeX, sizeY is constant.
data Frame %r1 %r2
	= Frame {
		sizeX	:: Int %r1;
		sizeY	:: Int %r1;
		array	:: ArrayU %r1 (Int %r2);
	};

project Frame where
	-- create a new frame of this size
	new :: String -> Int -> Int -> Frame
	new name sizeX sizeY
	 = do	sizeX'		= unboxInt32 sizeX
		sizeY'		= unboxInt32 sizeY
		name_flat	= name.flatten

	 	ptcOpen (dangerUnboxString name_flat) sizeX' sizeY'
	 	array	= arrayUI_new 1 (400 * 400 * 4)
		Frame sizeX sizeY array

	-- make a color from these RGB components.
	--	components should be in the range [0..255]
	color :: Int -> Int -> Int -> Int
	color r g b
		= b
		+ (256 * g)
		+ (256 * 256 * r)
	
	-- write this frame to the screen
	update :: Frame -> ()
	update frame
	 = do 	ptcUpdate (arrayUI_getBufPtr frame.array)
	 	()

	-- clear the frame
	clear ::  Frame -> Int -> ()
	clear frame color
		= arrayUI_fill frame.array color

	-- draw a single point
	point :: Frame -> Int -> Int -> Int -> ()
	point frame x y c
	 = match 
	 	| x > 0, x < frame.sizeX
		, y > 0, y < frame.sizeY
		= arrayUI_set 
	 		frame.array
			(x + y * frame.sizeX)
			c
		
		\= ()

	-- draw a line
	line ::	 Frame -> Int -> Int -> Int -> Int -> Int -> ()
	line frame x0 y0 x1 y1 c
	 = 	drawBresenhamLine 
		frame.array 
		frame.sizeX 
		frame.sizeY
		c
		x0 y0
		x1 y1

	-- draw a line through all these points
	lines :: Frame -> [(Int, Int)] -> Int -> ()
	lines frame xx color
	 = match 
		| ((x1, y1) : (x2, y2) : xs)	<- xx
		= do	frame.line x1 y1 x2 y2 color
			frame.lines ((x2, y2) : xs) color
			
		\= ()

	-- draw a circle
	circle :: Frame -> Int -> Int -> Int -> Int -> Int -> ()
	circle frame ps pX pY r color
	 = do 	pi 	= 3.1415926536
		rF	= toFloat r

	 	points	
		 = 	maps 	[0..ps]
			(\x -> do {
				theta	= (toFloat x) / (toFloat ps) * 2.0 * pi;
				(rF * cos theta, rF * sin theta); 
			})
		
		points'
		 = 	maps	points
		 	(\case { (x, y) -> (pX + truncate x, frame.sizeY - (pY + truncate y)); })

		frame.lines points' color
