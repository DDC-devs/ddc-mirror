{-# OPTIONS -no-implicit-prelude #-}

import Base
import Data.String
import Data.Ptr
import Data.Maybe

-- the foreign file type
foreign import data "FILE" File# :: *

-- The effect of functions that poke the file system
effect !File	:: !;

-- The standard streams
foreign import "stdout" stdout :: Ptr# File#
foreign import "stdin"  stdin  :: Ptr# File#
foreign import "stderr" stderr :: Ptr# File#

-- The position constants
foreign import "SEEK_SET"
 file_SEEK_SET :: Int32#

foreign import "SEEK_CUR" 
 file_SEEK_CUR :: Int32#

foreign import "SEEK_END" 
 file_SEEK_END :: Int32#

----------------------------------------------------------------------------------------------------
foreign import "fopen"
 fopenU ::  	String# {read} 		-- fileName 
	-> 	String# {read}		-- mode
	-(!e1)> Ptr# File#
 	:- !e1 = !File

foreign import "fread"
 freadU :: 	String# 	{write}	-- buffer to write into 
	-> 	Int32# 		{read}	-- size of member
	-> 	Int32# 		{read}	-- number of members to read
	-> 	Ptr# File#  	{read}	-- file to read from
	-(!e)>	Int32#	 		-- number of members read
	:- !e = !File
	


foreign import "fseek"
 fseekU	:: Ptr# File# 		{read}	-- file
	-> 	Int32#		{read}	-- offset
	-> 	Int32#		{read}	-- whence SEEK_SET, SEEK_END or SEEK_CUR
	-(!e)> 	Int32#			-- 0 on success, -1 on fail and set errno
	:- !e = !File


foreign import  "ftell"
 ftellU	:: 	Ptr# File#	{read}	-- file
	-(!e)>	Int32#			-- position in file
	:- !e = !File


foreign import	"fputs"
 fputsU ::	String#		{read}	-- string to write to file
 	-> 	Ptr# File#	{read} 	-- file handle
 	-(!e)>	Int
	:- !e = !File



--- move along, nothing to see here...
foreign import  "(Int32)"
 unsafe_castToInt32U 
 	:: forall a
	.  a -> Int32#;


-- | open a file
file_open 
	:: String 		-- ^ file name
	-> String 		-- ^ fopen mode string
	-> Ptr# File#

file_open name mode
 | SChunk name_flat	<- (copy name).flatten
 , SChunk mode_flat	<- (copy mode).flatten  
 = do	
 	file	= fopenU (name_flat.danger_string) (mode_flat.danger_string)

	case castToVoidPtr file `primPtrVoid_eq` primPtrVoid_null of
--		true#	-> error ("file_open: Can't open file " % name)
--		recurisve modules through Control.Exception, sigh

		false#	-> ()
		
	file


-- | return the length of the file with this path
file_length :: String -> Int
file_length name
 = do 	file	= file_open name "r+"

 	fseekU file 0# file_SEEK_END
	boxInt32 (ftellU file)
 
 
-- | read the contents of the file at this path
file_read :: String -> Maybe String
file_read name
 = do 	len	= file_length name
 	fs	= new&{FlatString} len
		
	file	= file_open name "r+"
	
	len'	= freadU (fs.danger_string) (unboxInt32 len) 1# file

	if (boxInt32 len') /= 1
	 then Nothing
	 else do
		fs.setLength len
		Just (SChunk fs)
		


