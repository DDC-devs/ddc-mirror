{-# OPTIONS -no-implicit-prelude #-}

import Base
import Data.Numeric.Addr
import Data.String
import Data.Maybe
import Foreign.Ptr
import Foreign.C.StdIO


-- | Open a file.
openFile
	:: String 		-- ^ File name.
	-> String 		-- ^ fopen mode string.
	-> Ptr# File#

openFile name mode 
 = do	addr	= openFile_addr name mode

	case primAddrU_isZero addr of
--		true#	-> error ("file_open: Can't open file " % name)
--		recurisve modules through Control.Exception, sigh

		false#	-> ()

	coerceAddrToPtr addr

openFile_addr :: String -> String -> Addr#
openFile_addr name mode
	| SChunk name_flat	<- (copy name).force
	, SChunk mode_flat	<- (copy mode).force
	= fopenU (name_flat.unsafeUnbox) (mode_flat.unsafeUnbox)


-- | Get the length of the file with this path.
file_length :: String -> Int
file_length name
 = do 	file	= openFile name "r+"

 	fseekU file 0# file_SEEK_END
	boxInt32 (ftellU file)


-- | Read the contents of the file at this path.
file_read :: String -> Maybe String
file_read name
 = do	file	= openFile name "r+"

	fseekU file 0# file_SEEK_END
	len 	= boxInt32 (ftellU file)
		
	fs	= new&{FlatString} len
	fseekU file 0# file_SEEK_SET
	len'	= freadU (fs.unsafeUnbox) (unboxInt32 len) 1# file

	if (boxInt32 len') /= 1 && boxInt32 (feofU file) /= 0
	 then Nothing
	 else do
		fs.setLength len
		Just (SChunk fs)

