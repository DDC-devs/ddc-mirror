{-# OPTIONS -no-implicit-prelude #-}

import Base
import Data.String
import Data.Ptr
import Data.Maybe

-- the foreign file type
foreign import data "FILE" File# :: *

-- The effect of functions that poke the file system
effect !File	:: !

-- The standard streams
foreign import "stdout" stdout :: Ptr# File#
foreign import "stdin"  stdin  :: Ptr# File#
foreign import "stderr" stderr :: Ptr# File#

-- The position constants
foreign import "SEEK_SET"
 file_SEEK_SET :: Int32#

foreign import "SEEK_CUR" 
 file_SEEK_CUR :: Int32#

foreign import "SEEK_END" 
 file_SEEK_END :: Int32#

----------------------------------------------------------------------------------------------------
foreign import "fopen"
 fopenU ::  	String# {read} 		-- fileName 
	-> 	String# {read}		-- mode
	-(!e1)> Ptr# File#
 	:- !e1 = !File

foreign import "fread"
 freadU :: 	String# 	{write}	-- buffer to write into 
	-> 	Int32# 		{read}	-- size of member
	-> 	Int32# 		{read}	-- number of members to read
	-> 	Ptr# File#  	{read}	-- file to read from
	-(!e)>	Int32#	 		-- number of members read
	:- !e = !File
	


foreign import "fseek"
 fseekU	:: Ptr# File# 		{read}	-- file
	-> 	Int32#		{read}	-- offset
	-> 	Int32#		{read}	-- whence SEEK_SET, SEEK_END or SEEK_CUR
	-(!e)> 	Int32#			-- 0 on success, -1 on fail and set errno
	:- !e = !File


foreign import  "ftell"
 ftellU	:: 	Ptr# File#	{read}	-- file
	-(!e)>	Int32#			-- position in file
	:- !e = !File


foreign import	"fputs"
 fputsU ::	String#		{read}	-- string to write to file
 	-> 	Ptr# File#	{read} 	-- file handle
 	-(!e)>	Int
	:- !e = !File

foreign import "feof"
 feofU :: Ptr# File# {read} -- file
  -(!e)> Int32#             -- nonzero if at EOF
  :- !e = !File



-- Don't use this for casting pointers as its guaranteed to be
-- wrong for 64 bit systems (from Captain Obvious).

foreign import  "(Int32)"
 unsafe_castToInt32U 
 	:: forall a
	.  a -> Int32#;

--------------------------------------------------------------------------------
-- Function that can actually be used in Disciple programs.

-- | open a file
try_file_open 
	:: String 		-- ^ file name
	-> String 		-- ^ fopen mode string
	-> Ptr# File#

try_file_open name mode
 | SChunk name_flat	<- (copy name).force
 , SChunk mode_flat	<- (copy mode).force
 = fopenU (name_flat.danger_string) (mode_flat.danger_string)

file_open 
	:: String 		-- ^ file name
	-> String 		-- ^ fopen mode string
	-> Ptr# File#
file_open name mode = do
	file = try_file_open name mode
	case castToVoidPtr file `primPtrVoid_eq` primPtrVoid_null of
--		true#	-> error ("file_open: Can't open file " % name)
--		recurisve modules through Control.Exception, sigh

		false#	-> ()
		
	file


-- | return the length of the file with this path
file_length :: String -> Int
file_length name
 = do 	file	= file_open name "r+"

 	fseekU file 0# file_SEEK_END
	boxInt32 (ftellU file)
 
 
-- | read the contents of the file at this path
file_read :: String -> Maybe String
file_read name = do
  file = try_file_open name "r+"
  case castToVoidPtr file `primPtrVoid_eq` primPtrVoid_null of
    true# -> Nothing
    false# -> do
	fseekU file 0# file_SEEK_END
	len = boxInt32 (ftellU file)

	fs	= new&{FlatString} len
	fseekU file 0# file_SEEK_SET
	len'	= freadU (fs.danger_string) (unboxInt32 len) 1# file

	if (boxInt32 len') /= 1 && boxInt32 (feofU file) /= 0
	 then Nothing
	 else do
		fs.setLength len
		Just (SChunk fs)
