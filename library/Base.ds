{-# OPTIONS -no-implicit-prelude #-}

-- Wordsize Config --------------------------------------------------------------------------------
-- | An unsigned word big enough to hold the offset from
--	the start of the store to the last byte in it.
--	This can be used as size_t when interfacing with C functions.

-- these should really be type synonyms, but for now the rewrite is hacked 
--	together by VarPrim.defaultTypeVar 
foreign import data "Word32"    Word#
foreign import data "Int32"     Int#
foreign import data "Float32"	Float#
foreign import data "Char32"	Char#

data	Word
data	Int
data	Float
data	Char

-- Abstract operational types.
data	Obj
data	Data
data	Thunk

-- Unboxed Data types ------------------------------------------------------------------------------
--	Single elements of unboxed type are passed by value, so they
--	don't need region annotations.
--
--	Functions which update data via a ptr like (Ptr# Word8#) will
--	have top level !Store effects which will ensure synchronisation 
--	when writing low level code.

-- The empty type
data	Void#
data	Ptr# a

-- | An unboxed boolean value, usually represented as a Word# at runtime.
foreign import data "Bool"   Bool#

-- unboxed, unsigned words
foreign import data "Word64" Word64#
foreign import data "Word32" Word32#
foreign import data "Word16" Word16#
foreign import data "Word8"  Word8#

-- unboxed, signed integers
foreign import data "Int64" Int64#
foreign import data "Int32" Int32#
foreign import data "Int16" Int16#
foreign import data "Int8"  Int8#

-- unboxed, floating point numbers
foreign import data "Float64" Float64#
foreign import data "Float32" Float32#

-- unboxed, unicode point.
foreign import data "Char32"  Char32#

-- unboxed strings are pointers to null-terminated blocks of utf8 characters. 
--	These blocks can be updated, so we give the string a region.
foreign import data "String"  String# :: % -> *

-- Boxed Data Types -------------------------------------------------------------------------------
data	Unit	
	= Unit

-- unsigned words
data 	Word64	%r
data	Word32	%r
data	Word16	%r
data 	Word8	%r

-- signed integers
data	Int64	%r
data	Int32	%r
data	Int16	%r
data	Int8	%r

-- floating point numbers
data	Float64 %r
data	Float32 %r

-- boxed characters
data	Char32	%r

-- boxed strings
-- are defined in Data.String

data 	Ref %r1 a
	= Ref { x :: a }

-- Region Classes ----------------------------------------------------------------------------------
class	Const		:: % -> +
class	Mutable		:: % -> +
class	Lazy		:: % -> +
class	Direct		:: % -> +

-- Effect Classes ----------------------------------------------------------------------------------
class	Pure		:: ! -> +

-- Value Type Classes ------------------------------------------------------------------------------
class	ConstT		:: * -> +
class	MutableT	:: * -> +
class	DirectT		:: * -> +

class	LazyT		:: * -> +
class	LazyH		:: * -> +

class	Shape2		:: * -> * -> +
class	Shape3		:: * -> * -> * -> +
class	Shape4		:: * -> * -> * -> * -> +
class	Shape5		:: * -> * -> * -> * -> * -> +
class	Shape6		:: * -> * -> * -> * -> * -> * -> +


-- Effects -----------------------------------------------------------------------------------------
effect	!Sync		:: !		-- Total synchronisation.

effect	!Read		:: % -> !	-- Read of some region.
effect	!ReadT		:: * -> !	-- Deep read of an object.
effect	!ReadH		:: * -> !	-- Read of top level constructor of an object.

effect	!Write		:: % -> !	-- Write to some region.
effect	!WriteT		:: * -> !	-- Write to whole object.


-- Projection Functions ----------------------------------------------------------------------------
-- primProj*
--	These functions are used by the desugarer to make default data projections.
--
--	As they stand they are certainly not typesafe, and they must be passed a
--	forced object (ie, not a suspension).
--
--	The desugarer adds the required type sig and forcing constructs to ensure
--	that the resulting projection functions are sound.
--
foreign import "primProjField"
 primProjField	
 	:: forall a b
	.  a -> Int32# -(!e1)> b
	:- !e1 = !ReadH a
	:$ Data -> Int32# -> Obj
 
foreign import "primProjFieldR"
 primProjFieldR 
 	:: forall a b
	.  a -> Int32# -(!e1)> b
	:- !e1 = !ReadH a
	:$ Data -> Int32# -> Obj

-----
-- BUGS: dodgy conversion of Int32# to Word32#

foreign import "_allocDataM"
 primAlloc_dataM
 	:: forall a 
	.  Int32# -> Int32# -> Int32# -> a			-- tag, ptrCount, dataSize (in bytes).
	:$ Word32# -> Word32# -> Word32# -> Data

-----
-- primAlloc_unsafe_dataR
--	Allocate an object on the heap to contain raw (unboxed) data.
--	Data size /must/ be a multiple of 4 bytes.

foreign import "_allocDataR"
 primAlloc_dataR
 	:: forall a
	.  Int32# -> Int32# -> a				-- tag, dataSize (in bytes).
	:$ Word32# -> Word32# -> Data

-----
foreign import "primInt32U_read"
 primInt32U_read
 	:: forall a 
	.  a -> Int32# -> Int32#				-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Int32#
	
foreign import "primInt32U_write"
 primInt32U_write
 	:: forall a
	.  a -> Int32# -> Int32# -> Void#			-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Int32# -> Void#

-----
foreign import "primFloat32U_read"
 primFloat32U_read
 	:: forall a
	.  a -> Int32# -> Float32#				-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Float32#
	
foreign import "primFloat32U_write"
 primFloat32U_write
 	:: forall a
	.  a -> Int32# -> Float32# -> Void#			-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Float32# -> Void#

