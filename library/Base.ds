{-# OPTIONS -no-implicit-prelude #-}

-- Wordsize Config --------------------------------------------------------------------------------
-- | An unsigned word big enough to hold the offset from
--	the start of the store to the last byte in it.
--	This can be used as size_t when interfacing with C functions.

-- these should really be type synonyms, but for now the rewrite is hacked 
--	together by VarPrim.defaultTypeVar 
foreign import data "Word32"    Word#
foreign import data "Int32"     Int#
foreign import data "Float32"	Float#
foreign import data "Char32"	Char#

data	Word
data	Int
data	Float
data	Char

-- Abstract operational types.
data	Obj
data	Data
data	Thunk

-- Unboxed Data types ------------------------------------------------------------------------------
--	Single elements of unboxed type are passed by value, so they
--	don't need region annotations.
--
--	Functions which update data via a ptr like (Ptr# Word8#) will
--	have top level !Store effects which will ensure synchronisation 
--	when writing low level code.

-- The empty type
data	Void#
data	Ptr# a

-- | An unboxed boolean value, usually represented as a Word# at runtime.
foreign import data "Bool"   Bool#

-- unboxed, unsigned words
foreign import data "Word64" Word64#
foreign import data "Word32" Word32#
foreign import data "Word16" Word16#
foreign import data "Word8"  Word8#

-- unboxed, signed integers
foreign import data "Int64" Int64#
foreign import data "Int32" Int32#
foreign import data "Int16" Int16#
foreign import data "Int8"  Int8#

-- unboxed, floating point numbers
foreign import data "Float64" Float64#
foreign import data "Float32" Float32#

-- unboxed, unicode point.
foreign import data "Char32"  Char32#


-- Boxed Data Types -------------------------------------------------------------------------------
data	Unit	
	= Unit

-- unsigned words
data 	Word64	%r	= Word64
data	Word32	%r	= Word32
data	Word16	%r	= Word16
data 	Word8	%r	= Word8

-- signed integers
data	Int64	%r	= Int64
data	Int32	%r	= Int32
data	Int16	%r	= Int16
data	Int8	%r	= Int8

-- floating point numbers
data	Float64 %r	= Float64
data	Float32 %r	= Float32

-- boxed characters
data	Char32	%r	= Char32

-- boxed strings
-- are defined in Data.String

data 	Ref %r1 a
	= Ref { x :: a }

-- Region Classes ----------------------------------------------------------------------------------
class	Const		:: % -> +
class	Mutable		:: % -> +
class	Lazy		:: % -> +
class	Direct		:: % -> +

-- Effect Classes ----------------------------------------------------------------------------------
class	Pure		:: ! -> +

-- Value Type Classes ------------------------------------------------------------------------------
class	ConstT		:: * -> +
class	MutableT	:: * -> +
class	DirectT		:: * -> +

class	LazyT		:: * -> +
class	LazyH		:: * -> +

class	Shape2		:: * -> * -> +
class	Shape3		:: * -> * -> * -> +
class	Shape4		:: * -> * -> * -> * -> +
class	Shape5		:: * -> * -> * -> * -> * -> +
class	Shape6		:: * -> * -> * -> * -> * -> * -> +


-- Effects -----------------------------------------------------------------------------------------
effect	!Sync		:: !		-- Total synchronisation.

effect	!Read		:: % -> !	-- Read of some region.
effect	!ReadT		:: * -> !	-- Deep read of an object.
effect	!ReadH		:: * -> !	-- Read of top level constructor of an object.

effect	!Write		:: % -> !	-- Write to some region.
effect	!WriteT		:: * -> !	-- Write to whole object.


-- Strings -----------------------------------------------------------------------------------------

-- This stuff is here to break module recursion.

-- | A FlatString contains a flat C string.
--   Layout:
--	0 maxLength :: Int32		-- max number of chars this string will hold.
--	4 length    :: Int32		-- number of chars currently used.
--	8 string    :: Word8.. 		-- string chars

data 	FlatString %r
	= FlatString

-- | A string type which supports fast append (paste)
data	String %r1 
	= SChunk (FlatString %r1)
	| SAppend (String %r1) (String %r1)

-- Exceptions --------------------------------------------------------------------------------------

-- The Exception type carries information about what caused a particular exception.
--	All modules need to be able to create an exception,
--	but we leave the exception handling stuff in Control.Exception
--
data Exception

	-- | some user defined string.
	= Exception String 

	-- | generated by the break keyword, to break out of an enclosing block.
	| ExceptionBreak

	-- | a generic IO exception. 
	| ExceptionIO String	

	-- | thrown when pattern matching fails.
	| ExceptionCaseNoMatch
		String 		-- the qualified name of the function we were evaluating
				--	(or supercombinator?? ticket #119)
		Int 		-- line number
		Int		-- column number

	-- | thrown when an array is accessed out of bounds:
	--	DANGER: runtime/Prim/Array.c makes assumptions
	--		about this constructor's type.
	| ExceptionArrayBounds
		Int		-- the actual size of the array
		Int		-- the requested index


-- Projection Functions ----------------------------------------------------------------------------
-- primProj*
--	These functions are used by the desugarer to make default data projections.
--
--	As they stand they are certainly not typesafe, and they must be passed a
--	forced object (ie, not a suspension).
--
--	The desugarer adds the required type sig and forcing constructs to ensure
--	that the resulting projection functions are sound.
--
foreign import "primProjField"
 primProjField	
 	:: forall a b
	.  a -> Int32# -(!e1)> b
	:- !e1 = !ReadH a
	:$ Data -> Int32# -> Obj
 
foreign import "primProjFieldR"
 primProjFieldR 
 	:: forall a b
	.  a -> Int32# -(!e1)> b
	:- !e1 = !ReadH a
	:$ Data -> Int32# -> Obj

-----
-- BUGS: dodgy conversion of Int32# to Word32#

foreign import "_allocDataM"
 primAlloc_dataM
 	:: forall a 
	.  Int32# -> Int32# -> Int32# -> a			-- tag, ptrCount, dataSize (in bytes).
	:$ Word32# -> Word32# -> Word32# -> Data

-----
-- primAlloc_unsafe_dataR
--	Allocate an object on the heap to contain raw (unboxed) data.
--	Data size /must/ be a multiple of 4 bytes.

foreign import "_allocDataR"
 primAlloc_dataR
 	:: forall a
	.  Int32# -> Int32# -> a				-- tag, dataSize (in bytes).
	:$ Word32# -> Word32# -> Data

-----
foreign import "primInt32U_read"
 primInt32U_read
 	:: forall a 
	.  a -> Int32# -> Int32#				-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Int32#
	
foreign import "primInt32U_write"
 primInt32U_write
 	:: forall a
	.  a -> Int32# -> Int32# -> Void#			-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Int32# -> Void#

-----
foreign import "primFloat32U_read"
 primFloat32U_read
 	:: forall a
	.  a -> Int32# -> Float32#				-- obj, offset (in bytes), result.
	:$ Data -> Int32# -> Float32#
	
foreign import "primFloat32U_write"
 primFloat32U_write
 	:: forall a
	.  a -> Int32# -> Float32# -> Void#			-- obj, offset (in bytes), data.
	:$ Data -> Int32# -> Float32# -> Void#

