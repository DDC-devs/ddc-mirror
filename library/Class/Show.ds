{-# OPTIONS -no-implicit-prelude #-}

import	Base.Thunk
import	Data.List
import 	System.Console
import	Class.Out

----------------------------------------------------------------------------------------------------
-- The show class for converting things to string
class Show a where 

 -- strict show which demands the entire structure
 show 	:: forall %r
	.  a -(!e1)> String %r
	:- !e1	= !{ !ReadT a }

 -- lazy show which works for infinite structures,
 --	but requires its argument to be const
 showL	:: forall %r
	.  a -> String %r
	:- ConstT a

-- The string paste operator
infixr 7 %;
infixr 7 %%;

(%)  a b	= SAppend a b
(%%) a b	= a % " " % b


-- Strict Show -------------------------------------------------------------------------------------
-- These instances are defined here instead of in Data.* so we don't 
--	have to worry about recursive module definitions.

instance Show Unit where
 show  ss  	= "()"
 showL ss 	= "()"
 
instance Show Char where
 show  ss 	= "'" % stringOfChar ss % "'"
 showL ss 	= "'" % stringOfChar @ ss % "'"

-- We need to copy shown strings because the returned
--	string might have a different mutability.
instance Show String where
 show  ss 	= "'" % copy ss % "'"
 showL ss	= "'" % copy @ ss % "'"

instance Show Int where
 show  ss	= stringOfInt ss
 showL ss	= stringOfInt @ ss

instance Show Float where
 show  ss	= stringOfFloat32 ss
 showL ss	= stringOfFloat32 @ ss

instance Show Bool where
 show  True	= "True"
 show  False	= "False"

 showL True	= "True"
 showL False	= "False"
 
instance Show [Int] where
 show  ss	= showList  @ show  ss
 showL ss	= showListL @ showL  ss

instance Show [Char] where
 show  ss	= showList  @ show   ss
 showL ss	= showListL @ showL  ss


-- Show a list strictly
--	this demands the entire list
showList  showX xx
 = "[" % showList2 showX xx;
 
showList2 showX xx
 = case xx of 
 	Nil		-> "]"
	Cons x xs	-> showX x % showList3 showX xs
	 
 
showList3 showX xx
 = case xx of  	
 	Nil 		-> "]"
	Cons x xs	-> ", " % showX x % showList3 showX xs

-- Show a list lazilly
--	this works for infinite data structures, but requires
--	the list and elements to be constant.
showListL showX xx
 = case xx of 
	Nil 		-> "[]"
	Cons x xs	-> "[" % showX x % showListL2 @ showX xs

showListL2 showX xx
 = case xx of 
 	Nil 		-> "]"
	Cons x xs 	-> ", " % showX x % showListL2 @ showX xs

-- | Print a string to the console
putStr :: String -> ()
putStr ss = print ss


-- | Print a string to the console.
--	This will become polymorphic when type classes are finished
print :: String -> ()
print xx
 = case xx of 
 	SChunk x	
	-> primPrintStringChunk xx

	SAppend s1 s2	
	-> do 	print s1
		print s2


-- | Print a string to the console followed by a newline.
println :: String -> ();
println s	= print (s % "\n");


-- | Contatenate some strings
concats :: [String] -> String
concats xx
 = case xx of
	Nil		-> ""
 	Cons x xs	-> SAppend x (concats xs)


-- | Wrap a string in parens
parens :: String -> String
parens ss	= "(" % ss % ")"


-- Out ---------------------------------------------------------------------------------------------
-- We're using the Out class until dictionary passing comes online and we can
--	make 'print' polymoprhic.
instance Out Int where
 out x	= println $ show x

instance Out Float where
 out x	= println $ show x

instance Out String where
 out x	= println x

instance Out [Int] where
 out x	= println $ show x
