{-# OPTIONS -no-implicit-prelude #-}

-- Primitive functions for unboxed Int32 operations.
--	There are no actual C functions associated with these.
--	We define them so the type inferencer has a schemes for them.
--
import Class.Eq
import Class.Num
import Class.Ord

-- math
foreign import "primInt32U_neg"
 primInt32U_neg :: Int32# -> Int32#

foreign import "primInt32U_add"
 primInt32U_add	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_sub"
 primInt32U_sub	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_mul"
 primInt32U_mul	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_div"
 primInt32U_div	:: Int32# -> Int32# -> Int32#
 
foreign import "primInt32U_mod"
 primInt32U_mod	:: Int32# -> Int32# -> Int32#
 
foreign import "primInt32U_eq"	
 primInt32U_eq	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_neq"	
 primInt32U_neq	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_gt"	
 primInt32U_gt	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_ge"	
 primInt32U_ge	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_lt"	
 primInt32U_lt	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_le"	
 primInt32U_le	:: Int32# -> Int32# -> Int32#


-----
instance Eq Int32# where
	(#==)		= primInt32U_eq
	(#/=)		= primInt32U_neq


instance Ord Int32# where
	(>)		= primInt32U_gt
	(<)		= primInt32U_lt
	(>=)		= primInt32U_ge
	(<=)		= primInt32U_le


instance Num Int32# where 
 	(+) 		= primInt32U_add
	(-) 		= primInt32U_sub
	(*) 		= primInt32U_mul
	(/) 		= primInt32U_div
	mod		= primInt32U_mod
	negate		= primInt32U_neg
