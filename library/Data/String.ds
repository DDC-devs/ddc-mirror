
import	Base;

import	Data.Int32U;
import 	Class.Eq;

pragma	Include ["string.h"];

data	String  %r1 
	= SChunk  (String# %r1)
	| SAppend {
		left	:: String %r1;
		right	:: String %r1;
	};

-- boxing
foreign import extern "_boxString"
 boxString	:: forall %r1 %r2
 		.  String# %r1 -> String %r2
		:$ String# -> Obj;
		
		
-- unboxing a string returns a pointer to the string
--	inside the heap allocated object		
foreign import extern "_unboxString"
 unboxString	:: forall %r1
 		.  String %r1 -> String# %r1
		:$ Obj -> String#;
		
foreign import extern "strcmp"
 strcmpU	:: elaborate String# -> String# -> Int32#;
 primString_eq	s1 s2	
  = do {
 	s1M	= string_merge s1;
	s2M	= string_merge s2;
	
	case primInt32U_eq (strcmpU (unboxString s1M) (unboxString s2M))  0# of {
  		1#	-> True;
		0#	-> False;
	};
  };

foreign import extern "strlen"
 strlenU	:: elaborate String# -> Int32#;
 string_length ss
  = case ss of {
	SAppend l r	-> string_length l + string_length r;
	_		-> boxInt32 (strlenU (unboxString ss));
 };
  

foreign import extern "strcat"
 unsafe_strcatU	:: elaborate (mutable String#) -> String# -> String#;
 string_unsafe_concat s1 s2
  = do { 
  	unsafe_strcatU (unboxString s1) (unboxString s2);
	s1;
 };
  	
foreign import extern "memset"
 unsafe_memsetU	:: elaborate (mutable String#) -> Int32# -> Int32# -> String#;

foreign import extern "primString_heads"
 string_char	:: elaborate String -> String;
 
foreign import extern "primString_tails"
 string_rest	:: elaborate String -> String;

foreign import extern "primString_isNul"
 string_isNul	:: elaborate String -> Bool;

foreign import extern "primString_ord"
 string_ord	:: elaborate String -> Int;


instance Eq (String %_) where
{
	(==) 	= primString_eq;

}


newString :: Int -> String;
newString length
 = do {	
	-- make sure to include space for the nul char on the end.
 	len	= unboxInt32 length + 1#;

	-- round length up to 4 byte word boundary for the DataR object.
	spill	= mod len 4#;
	lenS	= case spill #== 0# of {
				1#	-> len;
				0#	-> len + (4# - spill);
			};		

	-- alloc the object.
	str	= primAlloc_dataR 0# lenS;
 
 	-- grab a ptr to the raw string from the new object.
	strU	= unboxString str;
	
	-- set the string to all nul chars;
	unsafe_memsetU strU 0# len;
	
	str;
 }; 



string_isFlat :: String -> Bool;
string_isFlat ss
 = case ss of {
 	SAppend left right 	-> False;
	_ 			-> True;
 };


string_join :: String -> String -> String;
string_join  s1 s2
 = do {	len	= string_length s1 + string_length s2;
 	s3	= newString len;
	
	string_unsafe_concat s3 s1;
	string_unsafe_concat s3 s2;
	s3;
 };


string_merge :: String -> String;
string_merge ss
 = case ss of {
 	SAppend left right
	 -> do {
	 	len	= string_length ss;
 		sDest	= newString len;
	
		string_unsafe_concats sDest ss;
 		sDest;
	 };
	 
	_ -> ss;
 };
 
string_unsafe_concats :: String -> String -> String;
string_unsafe_concats sDest ss
 = case ss of {
 	SAppend left right	
	 -> do { 
	 	string_unsafe_concats sDest left;
		string_unsafe_concats sDest right;
	 };
	 
	_ -> string_unsafe_concat sDest ss;
 };


project String where
{
	unbox x		= unboxString x;
	length x	= string_length x;
	merge x		= string_merge x;
	isFloat x	= string_isFlat x;
	char x		= string_char x;
	rest x		= string_rest x;
	isNul x		= string_isNul x;	
	ord x		= string_ord x;
}



