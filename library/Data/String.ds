{-# OPTIONS -no-implicit-prelude #-}

import	Base

import	Data.Int
import	Data.Int32U
import 	Class.Eq
import	Class.Copy

pragma	cc_includes ["string.h"]

-- | A string type which supports fast append (paste)
data	String %r1 
	= SChunk (String# %r1)
	| SAppend {
		left	:: String %r1;
		right	:: String %r1;
	}

----------------------------------------------------------------------------------------------------
-- Primitive functions operating on strings

-- | Create a new string.
--	This creates a new heap object and copies the source string into it.
--
foreign import "_boxString"
 boxString	:: forall %r1 %r2
 		.  String# %r1 -(!Read %r1)> String %r2
		:$ String# -> Obj;
		
-- | Unboxing a string returns a pointer to a C string. 
--	
--    * The returned pointer will point inside a heap allocated object. 
--	Unless the string is anchored, this pointer will become invalid during 
--	the next GC cycle.
--
--    *	It /must/ be an SChunk, not an SAppend else badness.
--
--	The unboxed string data shares the region with the data constructor.
--
foreign import "_unboxString"
 dangerUnboxStringChunk
 	:: forall %r1
 	.  String %r1 -(!Read %r1)> String# %r1
	:$ Obj -> String#;


-- | Compare two strings for equality.
foreign import "strcmp"
 strcmpU	:: String#{read} -> String#{read} -> Int32#;

-- | Return the length of this string.
foreign import "strlen"
 strlenU	:: String#{read} -> Int32#;

-- | Append the src string to the dest string by overwriting the dest
--	* The destination string must be large enough to hold the result, else badness.
foreign import "strcat"
 dangerStrcatU	:: String#{write} -> String#{read} -> String#

-- | Write some characters into this string.
--	* number of bytes must be < length of string else badness.
foreign import "memset"
 dangerMemsetU	
 	:: String#{write} 	-- destination string
	-> Int32# 		-- byte to use
	-> Int32# 		-- number of bytes to set
	-> String#		-- same as desination string

dangerConcat s1 s2
  = do 	dangerStrcatU (dangerUnboxStringChunk s1) (dangerUnboxStringChunk s2)
	s1

-- | Pack this string into the destination
--	* the desination must be big enough else badness.
dangerPack :: String -> String -> String
dangerPack sDest ss
 = case ss of 
 	SAppend left right	
	 -> do 	dangerPack sDest left
		dangerPack sDest right
	 
	_ -> dangerConcat sDest ss


----------------------------------------------------------------------------------------------------
-- These have custom C functions in the runtime system
--

-- | Get the first character of a string as a new string
foreign import "primString_heads"
 primString_char	:: String{read} -> String;
 
-- | Get the tail of a string as a new string
foreign import "primString_tails"
 primString_rest	:: String{read} -> String;

-- | Check whether a string is empty
foreign import "primString_isNul"
 primString_isNul	:: String{read} -> Bool;

-- | Return the ASCII code of the first character in this string
foreign import "primString_ord"
 primString_ord		:: String{read} -> Int;

-- | Copy a string
foreign import "primString_copy"
 primString_copy	:: String{read} -> String;

----------------------------------------------------------------------------------------------------

-- | Create a new string with this length on the heap
newString :: Int -> String
newString length
 = do 
	-- make sure to include space for the nul char on the end.
 	len	= unboxInt32 length + 1#

	-- round length up to 4 byte word boundary for the DataR object.
	spill	= mod len 4#
	lenS	= case spill #== 0# of
			true#	-> len
			false#	-> len + (4# - spill)

	-- alloc the object.
	str 	:: String %r
	str	= primAlloc_dataR 0# lenS
 
 	-- grab a ptr to the raw string from the new object.
	strU	= dangerUnboxStringChunk str
	
	-- set the string to all nul chars;
	dangerMemsetU strU 0# len
	
	str

-- | Return how many characters are in this string
string_length :: String -> Int
string_length ss
  = case ss of 
	SAppend l r	-> string_length l + string_length r
	_		-> boxInt32 (strlenU (dangerUnboxStringChunk ss))


-- | Check whether this string is flat, ie is a single SChink and contains
--	contains no SAppend constructors.
string_isFlat :: String -> Bool
string_isFlat ss
 = case ss of 
 	SAppend left right 	-> False
	_ 			-> True


-- | Flatten a string so that is contains no SAppend constructors.
string_flatten :: String -> String
string_flatten ss
 = case ss of 
 	SAppend left right
	 -> do 	len	= string_length ss
 		sDest	= newString len
	
		dangerPack sDest ss
 		sDest
	 
	_ -> copy ss


-- | Join two strings.
string_join :: String -> String -> String
string_join  s1 s2
 = do 	len	= string_length s1 + string_length s2
 	s3	= newString len
	
	dangerConcat s3 s1
	dangerConcat s3 s2
	s3


-- | String equality
primString_eq :: String -> String -> Bool
primString_eq	s1 s2	
  = do 
 	s1M	= string_flatten (copy s1)
	s2M	= string_flatten (copy s2)
	
	case strcmpU (dangerUnboxStringChunk s1M) (dangerUnboxStringChunk s2M) `primInt32U_eq` 0# of
  		true#	-> True
		false#	-> False

-- | Get the first character of a string as a new string.
-- FIXME: This should return a Char, not a String
string_char :: String -> String
string_char s
 = case s of
        SAppend left _ -> string_char left
        _              -> primString_char s

-- | Get the tail of a string as a new string.
string_rest :: String -> String
string_rest s
 = case s of
        SAppend left right ->
            let leftRest = string_rest left
            in  if (string_isNul leftRest)
                    then right
                    else SAppend leftRest right
        _ -> primString_rest s

-- | Check whether a string is empty.
string_isNul :: String -> Bool
string_isNul s
 = case s of
        SAppend _ _ -> False
        _           -> primString_isNul s

-- | Return the ASCII code of the first character in this string
string_ord :: String -> Int
string_ord s
 = case s of
        SAppend left _ -> string_ord left
        _              -> primString_ord s

-- | Copy a string, preserving its shape.
string_copy :: String -> String
string_copy s
 = case s of
        SAppend left right -> SAppend (string_copy left) (string_copy right)
        _                  -> primString_copy s



infixr 7 %
infixr 7 %%

-- | Append one string to another.
--   TODO:	
--	It would be better if (%) avoided allocating an SAppend constructor
--	when either of its arguments was empty. However, this was make (%) have
--	a read effect, which interacts badly with the Show class because
--	the show fn isn't supposed include an effect which reads its return
--	string
--
--	This can be fixed once we can mask effects on fresh data.
--
--	To see the problem, change to the alternative definition and
--	compile library/Class/Show.ds with -O
--	
-- (%) a b   
--    | a.isNul = b
--    | b.isNul = a
--             \= SAppend a b
(%) a b
	= SAppend a b
	

-- | Append one string to another separated by a space.
(%%) a b = a % " " % b

-- | Unbox a string, flattening if necessary
--	The String# returned is a pointer into the string object in the heap.
--	This object will move on the next GC, so don't hold onto the pointer
--	across an allocation - else badness.
--
dangerUnboxString :: String -> String#
dangerUnboxString s
 = case s of
        SAppend _ _ -> dangerUnboxStringChunk (string_flatten s)
        _           -> dangerUnboxStringChunk s

-- Instances ---------------------------------------------------------------------------------------
instance Eq String where
	(==) 		= primString_eq
	(/=) s1 s2	= not (primString_eq s1 s2)

instance Copy String where	
	copy		= string_copy

project String where
	length x	= string_length x
	flatten x	= string_flatten x
	isFlat x	= string_isFlat x
	char x		= string_char x
	rest x		= string_rest x
	isNul x		= string_isNul x
	ord x		= string_ord x


