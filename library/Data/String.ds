{-# OPTIONS -no-implicit-prelude #-}

module	Data.String 

export	string_copy
	string_eq
	string_Int32
	string_Float32
	string_Char32
	boxString
	(%)
	(%%)

import	Base
	Data.FlatString
	Data.Numeric.Int32
	Data.Numeric.Float32
	Data.Char
	Class.Eq
	Class.Copy


project String 
 with	{ box; isFlat; isNul; length; flatten; head }


instance Eq String where
	(==) 		= string_eq
	(/=) s1 s2	= not (string_eq s1 s2)


instance Copy String where	
	copy		= string_copy

-- Conversions -------------------------------------------------------------------------------------
foreign import "snprintf"
	show_danger_snprintf :: String# -> Int32# -> String# -> a -> ()

string_Int32 :: Int32 -> String
string_Int32 i
 = do	maxLen	= 20
 	maxLenU	= unboxInt32 maxLen
	iU	= unboxInt32 i

 	fs	= new&{FlatString} maxLen
	strU	= fs.danger_string

 	show_danger_snprintf strU maxLenU "%d"# iU
	fs.setLengthU (stringU_length strU)
	
	SChunk fs


string_Float32 :: Float32 -> String
string_Float32 f
 = do	maxLen	= 20
 	maxLenU	= unboxInt32 maxLen
	fU	= unboxFloat32 f
	
	fs	= new&{FlatString} maxLen
	strU	= fs.danger_string
	
	show_danger_snprintf strU maxLenU "%f"# fU
	fs.setLengthU (stringU_length strU)
	
	SChunk fs


string_Char32 :: Char32 -> String
string_Char32 f
 = do	maxLen	= 5
 	maxLenU	= unboxInt32 maxLen
	cU	= unboxChar32 f
	
	fs	= new&{FlatString} maxLen
	strU	= fs.danger_string
	
	show_danger_snprintf strU maxLenU "%c"# cU
	fs.setLengthU (stringU_length strU)
	
	SChunk fs


-- Append ------------------------------------------------------------------------------------------
infixr 7 %
infixr 7 %%

-- | Append one string to another.
--   TODO:	
--	It would be better if (%) avoided allocating an SAppend constructor
--	when either of its arguments was empty. However, this was make (%) have
--	a read effect, which interacts badly with the Show class because
--	the show fn isn't supposed include an effect which reads its return
--	string
--
--	This can be fixed once we can mask effects on fresh data.
--
--	To see the problem, change to the alternative definition and
--	compile library/Class/Show.ds with -O
--	
(%) a b   
    | a.isNul = b
    | b.isNul = a
             \= SAppend a b


-- | Append one string to another separated by a space.
(%%) a b = a % " " % b


-- Boxing ------------------------------------------------------------------------------------------
-- | Box a string
boxString :: String# -> String
boxString strU
	= SChunk (box&{FlatString} strU)

box	= boxString

-- Simple Operations -------------------------------------------------------------------------------

-- | Copy a string, preserving its shape.
string_copy :: String -> String
string_copy str
 = case str of
 	SChunk fs	-> SChunk (copy fs)
	SAppend l r	-> SAppend (copy l) (copy r)


-- | Return how many characters are in this string
length :: String -> Int
length ss
  = case ss of 
	SChunk fs	-> fs.length
	SAppend l r	-> l.length + r.length

-- | Check whether this string is flat, ie is a single SChink and contains
--	contains no SAppend constructors.
isFlat :: String -> Bool
isFlat ss
 = case ss of 
	SChunk _	-> True
	_ 		-> False
	

-- | Check whether a string contains no characters
isNul :: String -> Bool
isNul ss
 = case ss of
 	SChunk fs	-> ss.length == 0
	SAppend s1 s2	-> s1.isNul && s2.isNul


-- | Create a new, flat string which contains no SAppend constructors.
flatten :: String -> String

flatten str@(SChunk fs)
	= str

flatten ss
 = do	len	= ss.length
 	fsDest	= new&{FlatString} len
	string_flatten' fsDest ss
	SChunk fsDest

string_flatten' dest (SChunk fs)
 = do	append&{FlatString} dest fs
	
string_flatten' dest (SAppend str1 str2)
 = do	string_flatten' dest str1
	string_flatten' dest str2


-- | Test if two strings are equal
--	This flattens both and uses strcmp
string_eq :: String -> String -> Bool
string_eq str1 str2
 = do	
	res	= match
			| SChunk fs1	<- (copy str1).flatten
			, SChunk fs2	<- (copy str2).flatten
			= stringU_compare
				fs1.danger_string
				fs2.danger_string
	
	res == 0#


-- | Find the first character in this string
head :: String -> Char32 
head (SChunk fs)	= fs.index 0

head (SAppend s1 s2)
	| isNul s1	=  head s2
			\= head s1


