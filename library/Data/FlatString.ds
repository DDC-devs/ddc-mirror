{-# OPTIONS -no-implicit-prelude #-}

module 	Data.FlatString

export	flatString_copy

import 	Data.Numeric.Int32
 	Data.StringU
 	Data.Char
 	Class.Copy
	DDC.Runtime.Alloc
	Foreign.C.String
 	Base

project FlatString 
 with {	box; unsafeUnbox; new;
	maxLengthU; lengthU; setLengthU; 
 	maxLength;  length;  setLength;
	index; 
	charsLeft;
	append; 
	slice }


-- Instances ------------------------------------------------------------------	
instance Copy FlatString where
 copy	= flatString_copy

-- Boxing --------------------------------------------------------------------
-- | Create a new FlatString and copy the source into it.
box :: String# %r1 -> FlatString %r2
box strU
 = do	-- make a new string for the destination
 	len	= strlen strU
	str	= new&{FlatString} (boxInt32 (len + 1#))

	-- copy the source into it
	dest	= castPtrWord8ToString (plusPtr (peekDataR_payload str) 8#)
	strcpy dest strU

	str.setLengthU len
	str


-- | Return a pointer to the unboxed null-terminated string that is inside
--   the boxed heap object.
--
--   DANGER: The object will probably move on the next GC, invalidating
--           the returned pointer. Don't hold onto the pointer across a
--           a potential allocation.
--
unsafeUnbox :: FlatString %r1 -> String# %r1
unsafeUnbox str@(FlatString)
 	= castPtrWord8ToString (plusPtr (peekDataR_payload str) 8#)

-- | With 
{-
withStringU :: FlatString %r1 -> (String# %r1 -> a) -> a
withStringU fs
 = do	
-}

-- Constructors ---------------------------------------------------------------
-- | Create a new string with the given length, and fill it will null charaters.
new :: Int32 -> FlatString
new length
 = do 
	-- make sure to include space for the nul char on the end.
	len		= unboxInt32 length
 	len_nul		= len + 1#

	-- round length up to 4 byte word boundary for the DataR object.
	spill		= mod len_nul 4#
	len_spilled	= if spill == 0# 
				then len_nul
				else len_nul + (4# - spill)

	len_payload	= 4#		-- for the maxLength field
			+ 4#		-- for the length field
			+ len_spilled	-- for the string chars

	-- alloc the object and grab a pointer to its payload
	str 	:: FlatString %r
	str	= primAlloc_dataR 0# len_payload

	payload	= peekDataR_payload str

	-- clear out the payload
	memset (castPtrWord8ToString payload) 0# len_payload
 
	-- write the maxLength
	poke   (castToPtrInt32 payload) len

	-- write the length
	poke   (castToPtrInt32 (plusPtr payload 4#)) 0#
	
	str


-- Field Accessors ------------------------------------------------------------
-- | Get the maximum number of charaters that can be stored in a FlatString.
maxLengthU :: FlatString -> Int32#
maxLengthU str@(FlatString)
 = do	payload = peekDataR_payload str
	peek (castToPtrInt32 payload)


-- | Get the number of charaters currently stored in a FlatString.
lengthU :: FlatString -> Int32#
lengthU str@(FlatString)
 = do	payload	= peekDataR_payload str
	peek (castToPtrInt32 (plusPtr payload 4#))


-- | Set the current length of the string
--   TODO: don't allow this to be set over the maximum available
--         This really wants a write effect, but we haven't added one because 
--         it's used by "new" and we cant mask effs on the return type of a
--         fn yet.
setLengthU :: FlatString -> Int32# -> ()
setLengthU str@(FlatString) len
 = do	payload	= peekDataR_payload str
	poke (castToPtrInt32 (plusPtr payload 4#)) len
	()


maxLength :: FlatString -> Int32
maxLength fs = boxInt32 fs.maxLengthU

length :: FlatString -> Int32
length fs    = boxInt32 fs.lengthU

setLength :: FlatString -> Int32 -> ()
setLength fs l = setLengthU fs (unboxInt32 l)


-- | Copy this FlatString
flatString_copy :: FlatString %r1 -> FlatString %r2
flatString_copy str@(FlatString)
 = do	len	= str.length
	str'	= new&{FlatString} len
	str'.setLength len
	strcpy (unsafeUnbox str') (unsafeUnbox str)
	str'


-- Utils ----------------------------------------------------------------------
-- | Take a character from this FlatString
index :: FlatString -> Int32 -> Char32
index str ix
 | ix < str.length
 = do	ixU	= unboxInt32 ix
 	payload	= peekDataR_payload str
	w8	= peek (plusPtr payload (8#i32 + ixU))
	
	boxChar32 (promote_word8ToChar32 w8)


-- | Get how many charaters there are still available in a FlatString.
charsLeft :: FlatString -> Int32
charsLeft fs
 = boxInt32 (maxLengthU fs - lengthU fs)


-- | Append some data to the end of a FlatString
append :: FlatString -> FlatString -> ()
append fs1@(FlatString) fs2@(FlatString)
 | fs1.charsLeft >= fs2.length
 = do	strcat (unsafeUnbox fs1) (unsafeUnbox fs2)
	fs1.setLength (fs1.length + fs2.length)


-- | Take a range of characters from a FlatString.
slice 	:: FlatString
	-> Int32	-- ^ Starting index
	-> Int32	-- ^ Length.
	-> FlatString

slice str start len
 = do	len'	= max (length str - start) len
	str'	= new len'
	
	startU	= unboxInt32 start
	lenU	= unboxInt32 len
	dst	= castStringToPtrWord8 (unsafeUnbox str')
	src	= plusPtr (castStringToPtrWord8 (unsafeUnbox str)) startU
	memcpy dst src lenU
	
	str'
