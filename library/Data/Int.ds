{-# OPTIONS -no-implicit-prelude #-}

import Base
import Data.Bool
import Data.Int32U

import Class.Copy
import Class.Eq
import Class.Num
import Class.Ord
import Class.Update

infix  5 <, <=, >=, > 

foreign import "_boxInt32"
 boxInt32 	:: Int32#{read} -> Int
		:$ Int32# -> Obj

foreign import "_unboxInt32"
 unboxInt32	:: Int {read} -> Int32#
		:$ Obj -> Int32#

-- math
foreign import "primInt32_neg"
 primInt32_neg  :: Int{read} -> Int

foreign import "primInt32_add"
 primInt32_add	:: Int{read} -> Int{read} -> Int

foreign import "primInt32_sub"	
 primInt32_sub	:: Int{read} -> Int{read} -> Int

foreign import "primInt32_mul"	
 primInt32_mul	:: Int{read} -> Int{read} -> Int

foreign import "primInt32_div"	
 primInt32_div	:: Int{read} -> Int{read} -> Int

foreign import "primInt32_mod"	
 primInt32_mod	:: Int{read} -> Int{read} -> Int

-- comparisons
foreign import "primInt32_eq"	
 primInt32_eq	:: Int{read} -> Int{read} -> Bool

foreign import "primInt32_neq"	
 primInt32_neq	:: Int{read} -> Int{read} -> Bool

foreign import "primInt32_gt"	
 primInt32_gt	:: Int{read} -> Int{read} -> Bool

foreign import "primInt32_lt"	
 primInt32_lt	:: Int{read} -> Int{read} -> Bool

foreign import "primInt32_ge"	
 primInt32_ge	:: Int{read} -> Int{read} -> Bool

foreign import "primInt32_le"	
 primInt32_le	:: Int{read} -> Int{read} -> Bool

-- update
foreign import "primInt32_update"
 primInt32_update
 	:: Int{write} -> Int{read} -> ()

instance Copy Int where
 	copy x 		= boxInt32 (unboxInt32 x)

instance Updatable Int where
	(:=)		= primInt32_update

instance Eq Int where
	(==)		= primInt32_eq
	(/=)		= primInt32_neq

instance Ord Int where
	(>)		= primInt32_gt
	(<)		= primInt32_lt
	(>=)		= primInt32_ge
	(<=)		= primInt32_le

	compare x y
	 | x == y	=  EQ
	 | x <= y	=  LT
	 		\= GT
	 
instance Num Int where 
 	(+) 		= primInt32_add
	(-) 		= primInt32_sub
	(*) 		= primInt32_mul
	(/) 		= primInt32_div
	mod		= primInt32_mod
	negate		= primInt32_neg

instance Accum Int where
	(+=) a b	= primInt32_update a (primInt32_add a b)


-----
(<>) :: Int -> (Int -> Int) -> ()
(<>) x f
 = do 	x'	= f x
	x	:= x'

inc x	= x + 1


project Int where
	
	min :: Int -> Int -> Int
	min x y
	 = if x < y	then x
			else y

	max :: Int -> Int -> Int
	max x y
	 = if x > y	then x
 			else y

