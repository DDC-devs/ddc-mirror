
import
{	Base;
	Base.Thunk;
	Data.Bool;
	Data.Ref;
	Data.Tuple;
	Data.Maybe;
	Data.Int;
	System.Error;
}

data	List %r1 a
	= Nil
	| Cons { 
		x 	:: a;
		xs	:: List %r1 a; }

	| Append {
		xx	:: List %r1 a; 
		xs	:: List %r1 a; };

-----
-- Construction
--
infixr 6 : ;
(:)  x xs 	= Cons   x xs;


-----
-- Projections
--
head :: [a] -> a;
head =
 \case { x : xs		-> x; };


tail ::	[a] -> [a];
tail =	
 \case { x  :  xs	-> xs; };


last :: 	[a] -> a;
last = 
 \case { []	-> error "last: empty list";
	 x : xs	-> case xs of {
			[]	-> x;
			y : ys	-> last xs; }; };

-----
-- Predicates
--
isNil :: [a] -> Bool;
isNil =
 \case { Nil		-> True;
	_		-> False; };

-----
-- Length
--
length :: [a] -> Int;
length xx
 = do {	count	= 0;
	
	maps_ xx (\x ->	count <> inc);
	count;
 };	 

lengthR :: [a] -> Int;
lengthR xx
 = case xx of {
 	[]	-> 0;
	x : xs	-> 1 + lengthR xs;
 };


-----
-- Indexing
--
(!!) ::	[a] -> Int -> a;
(!!) xx n
 = case xx of {
	[]	-> error "(!!): not found";
 	x : xs	-> if n == 0
		 	then x
			else xs !! (n - 1);
 };


indexL ::	[a] -> Int -> a;
indexL xx n
 = case xx of {
 	[]	 -> errorL "indexL: not found";
	x : xs	 -> if n == 0
		 	then x
			else indexL@ xs (n - 1);
 };


-----
-- Append
--
append :: [a] -> [a] -> [a];
append xs ys
 = case xs of {
 	[]	-> ys;
	_	-> case ys of {
			[]	-> xs;
			_	-> Append xs ys;
		};
 };


(++) :: [a] -> [a] -> [a];
(++) xx b	
 = case xx of {
 	[]		-> b;
	Cons   x  xs	-> x : (xs ++ b);
	Append xs ys	-> Append xs (ys ++ b);
 };


-----
-- Replicate / Iterate
--

replicate :: 	Int -> a -> [a];
replicate i x	
 = if i == 0 
 	then	[]
	else	x : replicate (i - 1) x;


iterateL ::	(a -> a) -> a -> [a];
iterateL f a	
	= a : iterateL@ f (f a);

-----
-- Mapping / Folding
--
map 	:: (a -> b) -> [a] -> [b];
map f xx
 = case xx of { 
 	[]		-> [];
	x  :  xs	-> f x      :  map f xs;
 };


mapL 	:: (a -> b) -> [a] -> [b];
mapL f xx
 = case xx of {
 	[]		-> [];
	x  :  xs	-> (:)  (f x) (mapL@ f xs);
 };


map_ :: (a -> b) -> [a] -> ();
map_ f xx
 = case xx of {
 	[]		-> ();

	x : xs		
	 -> do { f x;
		 map_ f xs; };
 };


maps 	:: [a] -> (a -> b) -> [b];
maps xx f = map f xx;


maps_ :: [a] -> (a -> b) -> ();
maps_ xx f 
 = 	map_ f xx;


foldl :: (s -> a -> s) -> s -> [a] -> s;
foldl    f state xx
 = case xx of {
 	[]	-> state;
	x : xs	
	-> do {	x'	= f state x;
		foldl f x' xs; };
 };


mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y]);
mapAccumL  f acc xx	
 = mapAccumL' f acc xx [];
 
mapAccumL' f acc xx yy
 = case xx of {
 	[]	-> (acc, reverse yy);
	(x:xs)	
	 -> do { 
	 	zz	= f acc x;
	 	acc'	= fst zz;
		y	= snd zz;
		mapAccumL' f acc' xs (y:yy);
	};
 };


-----
-- Sum / Prod
--

sum ::	[Int] -> Int;
sum xx
 = do {	count	= 0; 
	maps_ xx 
	 (\x ->	count := count + x);
	count; 
 };


sumU :: [Int] -> Int;
sumU xx
 = do {	count	= 0;
	maps xx 
	 (\x -> count := count + x);
	count;
 };

sumR :: [Int] -> Int;
sumR xx
 = case xx of {
 	[]	-> 0;
	x : xs	-> x + sumR xs;
 };

prod :: [Int] -> Int;
prod xs		= foldl (*) 1 xs;

pow :: Int -> Int -> Int;
pow x n		= prod $ replicate n x;


-----
-- Zipping
--
zipWith_ :: (a -> b -> ()) -> [a] -> [b] -> ();
zipWith_ f xx yy
 = match {
 	| Nil 	<- xx
	= ();
	
	| Nil	<- yy
	= ();
	
	| Cons x xs	<- xx
	, Cons y ys	<- yy
 	= do {	f x y;
		zipWith_ f xs ys;
	};
 };
		

-----
-- Reverse
--
reverse :: [a] -> [a];
reverse xx 
 = case xx of {
 	[]	-> [];
	x :  xs	-> reverse xs ++ [x];
 };


-----
-- Intersperse
--
intersperse :: a -> [a] -> [a];
intersperse s
 = \case {
 	[]	-> [];
	x : xs	-> x : s : intersperse s xs;
 };


-----
-- Take / Drop
-- 
take :: Int -> [a] -> [a];
take n xx
 = match {
 	| n == 0		= [];
	| [] 		<- xx	= [];
	| (x:xs) 	<- xx	= x : take (n - 1) xs;
 };


drop :: Int -> [a] -> [a];
drop n xx
 = if n == 0 
 	then xx
	else drop (n - 1) (tail xx);


-----
-- Delete
--
deleteF :: (a -> a -> Bool) -> [a] -> a -> [a];
deleteF eqF xx y
 = case xx of {
 	[]	-> [];
	
	x : xs	
	 -> if eqF x y
	 	then xs
		else x : deleteF eqF xs y;
 }; 


-----
-- find
--
find :: (a -> Bool) -> [a] -> Maybe a;
find f xx
 = match {
	| x:xs	<- xx
	, f x
	= Just x;

	| x:xs	<- xx
	= find f xs;
	
	\= Nothing;
 };

-----
-- Filtering
--
filterL	::	(a -> Bool) -> [a] -> [a];
filterL f xx
 = case xx of {
 	[]	-> [];
	x : xs	-> if f x 
		 	then x : filterL@ f xs
			else filterL@ f xs;
 };

-----
rangeInt :: Int -> Int -> [Int];
rangeInt x y
 = if x >= y 
 	then [x]
	else x  : rangeInt (x + 1) y;

rangeIntL :: Int -> Int -> [Int];
rangeIntL x y
 = if x >= y
 	then [x]
	else x : rangeIntL@ (x + 1) y;

rangeInfIntL :: Int -> [Int];
rangeInfIntL x
	= x : rangeInfIntL@ (x + 1);


-----
-- Concat / ConcatMap
--
concat :: [[a]] -> [a];
concat xx
 = case xx of {
	[]	-> [];
 	x : xs 	-> x ++ concat xs;
 };


concatL :: [[a]] -> [a];
concatL xx
 = case xx of {
 	[]		-> [];
	x  : xs		-> (++)@ x (concatL@ xs);
--	xs ++ ys	-> (++)  (concatL@ xs) (concatL@ ys);
 };


concatMap :: (a -> [b]) -> [a] -> [b];
concatMap f xx
 = case xx of {
 	[]		-> [];
	x  : xs		-> f x ++ concatMap f xs;
--	xs ++ ys	-> concatMap f xs `append` concatMap f ys;
 };
 

concatMapL :: (a -> [b]) -> [a] -> [b];
concatMapL f xx
 = case xx of {
 	[] 		-> [];
	x : xs		-> (++)@ (f x) (concatMapL@ f xs);
 };


-- Instances ---------------------------------------------------------------------------------------

instance Copy (List Int) where
 copy xx	
  = case xx of
  	[]	-> []
	(x:xs)	-> copy x : copy xs

