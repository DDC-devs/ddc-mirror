{-# OPTIONS -no-implicit-prelude #-}

module 	Data.List

import	Base
	Base.Thunk
	Class.Functor
	Class.Foldable
	Data.Function
	Data.Bool
	Data.Ref
	Data.Tuple
	Data.Maybe
	Data.Int
	Data.String
	Control.Exception

data	List a
	= Nil
	| Cons { 
		x 	:: a;
		xs	:: List a; }

project List a 
 with {	head; tail; last;
 	isNil;
	length }
		
-- Construction
infixr 6 : 
(:)  x xs 	= Cons   x xs


-- | Mapping
instance Functor (List %r) where
	map f []	= []
	map f (x : xs)	= f x : map f xs

	map_ f []	= ()
	map_ f (x : xs)	= do { f x; map_ f xs }
	

-- | Folding
instance Foldable (List %r) where
	foldl f state []	= state
	foldl f state (x:xs)	= foldl f (f state x) xs

	foldr f state []	= state
	foldr f state (x:xs)	= f x (foldr f state xs)


-- Simple projections ------------------------------------------------------------------------------
head :: [a] -> a
head (x:xs)	= x

tail ::	[a] -> [a]
tail (x:xs)	= xs

last :: [a] -> a;
last (x:[])	= x
last (x:xs)	= last xs


-- Predicates --------------------------------------------------------------------------------------
isNil :: [a] -> Bool
isNil Nil	= True
isNil _		= False


-- | Find the length of a list.
length xs	= go xs 0
  where
    go [] n = n
    go (x:xs) n = go xs (n+1)


-- | Select a numbered element of a list
(!!) ::	[a] -> Int -> a;
(!!) (x:xs) 0	= x
(!!) (x:xs) n	= xs !! (n - 1)


-- | Append two lists. 
--   This uses time and stack space proportional to the length of the first list.
--
(++) :: [a] -> [a] -> [a]
(++) [] b	= b
(++) (x:xs) b	= x : (xs ++ b)


-- | Replicate an an element a number of times.
replicate :: 	Int -> a -> [a]
replicate 0 x	= []
replicate i x	= x : replicate (i - 1) x


-- | Keep applying this function to a value and return an infinite list of the results.
iterateL ::	(a -> a) -> a -> [a]
iterateL f a	
	= a : iterateL@ f (f a)

-- | A spine-lazy map
mapL 	:: (a -> b) -> [a] -> [b]
mapL f []	= []
mapL f (x:xs)	= f x : ((mapL f) @ xs)


-- | A map with the arguments switched around
maps 	:: [a] -> (a -> b) -> [b]
maps xx f = map f xx


-- | map_ with the arugments switched around
maps_ :: [a] -> (a -> b) -> ()
maps_ xx f 
 = 	map_ f xx


-- | Reverse the elements of this list
reverse :: [a] -> [a]
reverse []	= []
reverse (x:xs)	= reverse xs ++ [x]


-- | a combination of map and fold.
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y]);
mapAccumL  f acc xx	
 	= mapAccumL' f acc xx [];
 
mapAccumL' f acc [] yy	
	= (acc, reverse yy)

mapAccumL' f acc (x:xs) yy
 = do	zz	= f acc x
 	acc'	= fst zz
	y	= snd zz
   	mapAccumL' f acc' xs (y:yy)
	

-- | Sum up the elements of this int list
sum ::	[Int] -> Int;
sum xx
 = do 	count	= 0; 
	maps_ xx 
	 (\x ->	count := count + x)
	count


-- | Sum up the elements of this int list, recursively
sumR :: [Int] -> Int;
sumR xx
 = case xx of {
 	[]	-> 0;
	x : xs	-> x + sumR xs;
 };


-- | Multiply all the elements of this int list together
prod :: [Int] -> Int;
prod xs		= foldl (*) 1 xs;


-- | Raise this int to a power.
pow :: Int -> Int -> Int;
pow x n		= prod $ replicate n x;


-- | Zip these lists together with a function
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f [] yy		= []
zipWith f xx []		= []
zipWith f (x:xs) (y:ys)
 	= f x y : zipWith f xs ys
 
 
-- | Zip these lists together with a function, ignoring the return value
zipWith_ :: (a -> b -> ()) -> [a] -> [b] -> ()
zipWith_ f []  yy	= ()
zipWith_ f xx  []	= ()
zipWith_ f (x:xs) (y:ys)	
 = do	f x y
 	zipWith_ f xs ys
	

-- | Intersperse an element between every member of this list
intersperse :: a -> [a] -> [a];
intersperse s []	= []
intersperse s (x:xs)	= x : s : intersperse s xs


-- | Take the first few elements from the front of this this list
take :: Int -> [a] -> [a];
take 0 xx	= []
take _ []	= []
take n (x:xs)	= x : take (n - 1) xs


-- | Take elements from the list while the predicate matches
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ []          =  []
takeWhile p (x:xs) 
            | p x       =  x : takeWhile p xs
            | otherwise =  []


-- | Drop the first few elements from the front of this list
drop :: Int -> [a] -> [a];
drop 0 xx	= xx
drop n (_:xs)	= drop (n - 1) xs


-- | Delete all the elements which match this one, using the provided equality function
deleteF :: (a -> a -> Bool) -> [a] -> a -> [a]
deleteF eqF [] y	= []
deleteF eqF (x:xs) y	
	|  eqF x y	= xs
			\= x : deleteF eqF xs y
		
-- | Check if this element is in the list
elemF :: (a -> a -> Bool) -> a -> [a] -> Bool
elemF eqF z []		= False
elemF eqF z (x:xs)
	| eqF z x	= True
			\= elemF eqF z xs
	
-- | Find the first element in the list that matches this predicate.
find :: (a -> Bool) -> [a] -> Maybe a;
find f (x:xs)	
	| f x	=  Just x
		\= find f xs
		
find f _	= Nothing


-- | Return a list of all the elements that match this predicate
filter :: (a -> Bool) -> [a] -> [a]
filter f []	= []
filter f (x:xs)	
	| f x	=  x : filter f xs
		\= filter f xs
		

-- | Return a list of all the elements that match this predicate (lazy spine)
filterL	:: (a -> Bool) -> [a] -> [a]
filterL f []	= []
filterL f (x:xs)
	| f x	= x : filterL @ f xs
		\= filterL @ f xs
		

-- | Return a list of ints in this range
rangeInt :: Int -> Int -> [Int]
rangeInt x y =
	if x > y
	 then []
	 else rangeIntUp x y
 where
	rangeIntUp x y
		| x >= y	=  [x]
				\= x : rangeIntUp (x + 1) y


-- | Return a list of ints in this range, with step size determined by the
--   difference between the first and second element.
rangeIntStep :: Int -> Int -> Int -> [Int]
rangeIntStep x next y =
	case (compare x next, compare x y) of
		(EQ, _)		-> infListIntL x
		(LT, LT)	-> rangeIntStepUp x y
		(GT, GT)	-> rangeIntStepDown x y
		_		-> []
 where
	step = next - x
	rangeIntStepUp x' y'
		| x' >= y'	= [x']
				\= x' : rangeIntStepUp (x' + step) y'
	rangeIntStepDown x' y'
		| x' <= y'	= [x']
				\= x' : rangeIntStepDown (x' + step) y'


-- | Return a list of ints in this range (lazy spine)
rangeIntL :: Int -> Int -> [Int]
rangeIntL x y =
	if x > y
	 then rangeIntDownL x y
	 else rangeIntUpL x y
 where
	rangeIntUpL x y
		| x >= y	=  [x]
				\= x : rangeIntUpL @ (x + 1) y
	rangeIntDownL x y
		| x <= y	=  [x]
				\= x : rangeIntDownL @ (x - 1) y


-- | Return a list of ints in this range, with step size determined by the
--   difference between the first and second element.
rangeIntStepL :: Int -> Int -> Int -> [Int]
rangeIntStepL x next y =
	case (compare x next, compare x y) of
		(EQ, _)		-> infListIntL x
		(LT, LT)	-> rangeIntStepUpL x y
		(GT,  GT)	-> rangeIntStepDownL x y
		_		-> []
 where
	step = next - x
	rangeIntStepUpL x' y'
		| x' >= y'	= [x']
				\= x' : rangeIntStepUpL @ (x' + step) y'
	rangeIntStepDownL x' y'
		| x' <= y'	= [x']
				\= x' : rangeIntStepDownL @ (x' + step) y'


-- | Return the infinite list of ints starting from this value (lazy spine)
rangeInfIntL :: Int -> [Int]
rangeInfIntL x
	= x : rangeInfIntL @ (x + 1)

rangeInfIntStepL :: Int -> Int -> [Int]
rangeInfIntStepL x next =
	if x == next
         then infListIntL x
         else rangeInfIntStepInnerL x
 where
	step = next - x
	rangeInfIntStepInnerL x' = x' : rangeInfIntStepInnerL @ (x' + step)


infListIntL :: Int -> [Int]
infListIntL x =
        x : infListIntL @ x


-- | Concatenate all these lists together
concat :: [[a]] -> [a]
concat []	= []
concat (x:xs)	= x ++ concat xs


-- | Concat all these lists together (lazy spine)
concatL :: [[a]] -> [a]
concatL []		= []
concatL (x:xs)		= (++)@ x (concatL @ xs)

-- | Map a function across this list and concatenate the elements together
concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f []		= []
concatMap f (x:xs)	= f x ++ concatMap f xs


-- | Map a function across this list and concatenate the elements together (lazy spine)
concatMapL :: (a -> [b]) -> [a] -> [b]
concatMapL f []		= []
concatMapL f (x:xs)	= (++)@ (f x) (concatMapL @ f xs)


-- Instances ---------------------------------------------------------------------------------------
instance Copy (List Int) where
 copy xx	
  = case xx of
  	[]	-> []
	(x:xs)	-> copy x : copy xs



-- Maybe stuff ------------------------------------------------------------------------------------
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
mapMaybe _ [] 		= []
mapMaybe f (x:xs)
 = do	rs = mapMaybe f xs
	case f x of
		Nothing -> rs
		Just r  -> r : rs

maybeToList :: Maybe a -> [a]
maybeToList Nothing	= []
maybeToList (Just x)	= [x]


-- Ord stuff -------------------------------------------------------------------------------------

-- | Extract the largest value from a list, using the provided ordering relation.
maximumBy :: (a -> a -> Ordering) -> [a] -> a
maximumBy _ []
	= error "List.maximumBy: empty list"

maximumBy cmp (a:as)
	= foldl (\x y -> case cmp x y of { GT -> x; _  -> y}) a as


-- | Extract the smallest value from a list, using the provided ordering relation.
minimumBy :: (a -> a -> Ordering) -> [a] -> a
minimumBy _ []		
	= error "List.minimumBy: empty list"

minimumBy cmp (a:as)
	= foldl (\x y -> case cmp x y of { GT -> y; _  -> x}) a as



-- String stuff ------------------------------------------------------------------------------------
-- This should be in Data.String but we don't have a way of adding projections
--	functions outside the module.

charListOfString :: String -> [Char]

charListOfString (SAppend s1 s2)
	= charListOfString s1 ++ charListOfString s2

charListOfString (SChunk fs)
	= charListOfFlatString' fs 0 (fs.length) []
	

charListOfFlatString :: FlatString -> [Char]
charListOfFlatString fs
 	= charListOfFlatString' fs 0 (fs.length) []
 
charListOfFlatString' :: FlatString -> Int -> Int -> [Char] -> [Char]
charListOfFlatString' fs ix max xs
    | ix < max = charListOfFlatString' fs ix (max - 1) (fs.index (max - 1) : xs)
    \= xs

concatStrings :: [String] -> String
concatStrings []	= ""
concatStrings (str : rest)
	= str % concatStrings rest
