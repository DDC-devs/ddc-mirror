{-# OPTIONS -no-implicit-prelude #-}

-- Primitive functions for unboxed Int64 operations.
--	There are no actual C functions associated with these.
--	We define them so the type inferencer has a schemes for them.
--
module	Data.Numeric.Int64U

import	Class.Eq
	Class.Ord
	Class.Num
	Class.Integral


-- Arithmetic -----------------------------------------------------------------
foreign import "primInt64U_neg"
 primInt64U_neg :: Int64# -> Int64#

foreign import "primInt64U_add"
 primInt64U_add :: Int64# -> Int64# -> Int64#

foreign import "primInt64U_sub"
 primInt64U_sub :: Int64# -> Int64# -> Int64#

foreign import "primInt64U_mul"
 primInt64U_mul :: Int64# -> Int64# -> Int64#

foreign import "primInt64U_div"
 primInt64U_div :: Int64# -> Int64# -> Int64#

foreign import "primInt64U_mod"
 primInt64U_mod :: Int64# -> Int64# -> Int64#


-- Comparisons ----------------------------------------------------------------
foreign import "primInt64U_eq"	
 primInt64U_eq	:: Int64# -> Int64# -> Bool#

foreign import "primInt64U_neq"	
 primInt64U_neq :: Int64# -> Int64# -> Bool#

foreign import "primInt64U_gt"	
 primInt64U_gt	:: Int64# -> Int64# -> Bool#

foreign import "primInt64U_ge"	
 primInt64U_ge	:: Int64# -> Int64# -> Bool#

foreign import "primInt64U_lt"	
 primInt64U_lt	:: Int64# -> Int64# -> Bool#

foreign import "primInt64U_le"	
 primInt64U_le	:: Int64# -> Int64# -> Bool#


-- Instances ------------------------------------------------------------------
instance Eq Int64# where
	(==)  x y	= boxBool (primInt64U_eq x y) 
	(/=)  x y	= boxBool (primInt64U_neq x y)


instance Ord Int64# where
	(>)   x y	= boxBool (primInt64U_gt x y)
	(<)   x y	= boxBool (primInt64U_lt x y)
	(>=)  x y	= boxBool (primInt64U_ge x y)
	(<=)  x y	= boxBool (primInt64U_le x y)

	compare x y
	 | x == y	=  EQ
	 | x <  y	=  LT
			\= GT


instance Num Int64# where 
 	(+) 		= primInt64U_add
	(-) 		= primInt64U_sub
	(*) 		= primInt64U_mul
	negate		= primInt64U_neg


instance Integral Int64# where
	div		= primInt64U_div
	mod		= primInt64U_mod
	
