{-# OPTIONS -no-implicit-prelude #-}

module	Data.Numeric.Int32

import	Data.Numeric.Int32U
	DDC.Runtime.Store
	DDC.Runtime.Alloc
	Class.Eq
	Class.Ord
	Class.Copy
	Class.Update
	Class.Num
	Class.Integral
	Base.Thunk
	
	
infixl 7  `quot`, `div`, `mod`


-- Boxing ---------------------------------------------------------------------
foreign import "_boxInt32"
 boxInt32 	:: Int32# -> Int32
		:$ Int32# -> Obj

foreign import "_unboxInt32"
 unboxInt32	:: Int32{read} -> Int32#
		:$ Obj -> Int32#


-- Instances ------------------------------------------------------------------
instance Eq Int32 where
	(==) x y	= boxBool   (primInt32U_eq  (unboxInt32 x) (unboxInt32 y))
	(/=) x y	= boxBool   (primInt32U_neq (unboxInt32 x) (unboxInt32 y))
		

instance Ord Int32 where
	(>) x y		= boxBool   (primInt32U_gt  (unboxInt32 x) (unboxInt32 y))
	(<) x y		= boxBool   (primInt32U_lt  (unboxInt32 x) (unboxInt32 y))
	(>=) x y	= boxBool   (primInt32U_ge  (unboxInt32 x) (unboxInt32 y))
	(<=) x y	= boxBool   (primInt32U_le  (unboxInt32 x) (unboxInt32 y))

	compare x y
	 | x == y	=  EQ
	 | x <  y	=  LT
	 		\= GT

	min x y		= if x <= y then x else y
	max x y		= if x >= y then x else y


instance Copy Int32 where
 	copy x 		= boxInt32 (unboxInt32 x)


instance Updatable Int32 where
	(:=) w1 w2
	 = do	w1'	= force w1
		poke (castToPtrInt32 (peekDataRS_payload w1)) (unboxInt32 w2)
		()


instance Num Int32 where
	negate x 	= boxInt32 (primInt32U_neg (unboxInt32 x))
	(+) x y		= boxInt32 (primInt32U_add (unboxInt32 x) (unboxInt32 y))
	(-) x y		= boxInt32 (primInt32U_sub (unboxInt32 x) (unboxInt32 y))
	(*) x y		= boxInt32 (primInt32U_mul (unboxInt32 x) (unboxInt32 y))

	pow x n = pow' n 1i32
	 where	pow' :: Int32 -> Int32 -> Int32
		pow' 0i32 acc = acc
		pow' n    acc = pow' (n - 1i32) (acc * x)


instance Integral Int32 where
	div x y		= boxInt32 (primInt32U_div (unboxInt32 x) (unboxInt32 y))
	mod x y		= boxInt32 (primInt32U_mod (unboxInt32 x) (unboxInt32 y))


instance Accum Int32 where
	(+=) a b	= a := (a + b)


