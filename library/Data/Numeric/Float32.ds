{-# OPTIONS -no-implicit-prelude #-}

module	Data.Numeric.Float32

import 	Base
 	Data.Bool
	Data.Numeric.Int32
 	Data.Numeric.Int32U
 	Data.Numeric.Float32U
	Class.Eq
	Class.Num
	Class.Ord
	Class.Fractional

pragma	cc_includes ["math.h"]

-- Boxing ---------------------------------------------------------------------
foreign import "_boxFloat32"
 boxFloat32 	:: forall %r1
  		.  Float32# -> Float %r1
		:$ Float32# -> Obj

foreign import "_unboxFloat32"
 unboxFloat32	:: forall %r1
 		.  Float %r1 -(!Read %r1)> Float32#
		:$ Obj -> Float32#


-- Conversion -----------------------------------------------------------------
foreign import "primFloat32_toFloat"
 toFloat	:: Int32{read}   -> Float32

foreign import "primFloat32_truncate"
 truncate	:: Float32{read} -> Int32


-- Trig -----------------------------------------------------------------------
sin x		= boxFloat32 (primFloat32U_sin   (unboxFloat32 x))
asin x		= boxFloat32 (primFloat32U_asin  (unboxFloat32 x))
cos x		= boxFloat32 (primFloat32U_cos   (unboxFloat32 x))
acos x		= boxFloat32 (primFloat32U_acos  (unboxFloat32 x))
tan x		= boxFloat32 (primFloat32U_tan   (unboxFloat32 x))
atan x		= boxFloat32 (primFloat32U_atan  (unboxFloat32 x))


-- Utils ----------------------------------------------------------------------
ftrunc x	= boxFloat32 (primFloat32U_ftrunc  (unboxFloat32 x))
fround x 	= boxFloat32 (primFloat32U_fround  (unboxFloat32 x))
ffloor x	= boxFloat32 (primFloat32U_ffloor  (unboxFloat32 x))

fmod x y	= boxFloat32 (primFloat32U_fmod    (unboxFloat32 x) (unboxFloat32 y))
fpow x y  	= boxFloat32 (primFloat32U_fpow    (unboxFloat32 x) (unboxFloat32 y))

sqrt x		= boxFloat32 (primFloat32U_sqrt    (unboxFloat32 x))
abs  x	  	= boxFloat32 (primFloat32U_abs     (unboxFloat32 x))
log  x		= boxFloat32 (primFloat32U_log     (unboxFloat32 x))


-- Instances ------------------------------------------------------------------
instance Eq Float32 where
	(==) x y	= boxBool   (primFloat32U_eq  (unboxFloat32 x) (unboxFloat32 y))
	(/=) x y	= boxBool   (primFloat32U_neq (unboxFloat32 x) (unboxFloat32 y))
		

instance Ord Float32 where
	(>) x y		= boxBool   (primFloat32U_gt  (unboxFloat32 x) (unboxFloat32 y))
	(<) x y		= boxBool   (primFloat32U_lt  (unboxFloat32 x) (unboxFloat32 y))
	(>=) x y	= boxBool   (primFloat32U_ge  (unboxFloat32 x) (unboxFloat32 y))
	(<=) x y	= boxBool   (primFloat32U_le  (unboxFloat32 x) (unboxFloat32 y))

	compare x y
	 | x == y	=  EQ
	 | x <  y	=  LT
	 		\= GT

	min x y		= if x <= y then x else y
	max x y		= if x >= y then x else y


instance Copy Float32 where
 	copy x 		= boxFloat32 (unboxFloat32 x)


instance Updatable Float32 where
	(:=) w1 w2
	 = do	w1'	= force w1
		poke (castToPtrFloat32 (peekDataRS_payload w1)) (unboxFloat32 w2)
		()


instance Num Float32 where
	negate x 	= boxFloat32 (primFloat32U_neg (unboxFloat32 x))
	(+) x y		= boxFloat32 (primFloat32U_add (unboxFloat32 x) (unboxFloat32 y))
	(-) x y		= boxFloat32 (primFloat32U_sub (unboxFloat32 x) (unboxFloat32 y))
	(*) x y		= boxFloat32 (primFloat32U_mul (unboxFloat32 x) (unboxFloat32 y))


instance Fractional Float where
	(/) x y		= boxFloat32 (primFloat32U_div  (unboxFloat32 x) (unboxFloat32 y))


instance Accum Float32 where
	(+=) a b	= a := (a + b)


-- Other ----------------------------------------------------------------------
-- The Haskell versions of round and floor are also conversions.
round x		= truncate (fround x)
floor x 	= truncate (ffloor x)

project Float where
 clamp :: Float -> Float -> Float -> Float 
 clamp x a b
	| x < a		= a
	| x > b		= b
	| otherwise	= x


