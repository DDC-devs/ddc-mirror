{-# OPTIONS -no-implicit-prelude #-}

module	Data.Numeric.Float64

import	Base
	Data.Bool
	Data.Numeric.Int32
	Data.Numeric.Int64
	Class.Eq
	Class.Num
	Class.Ord
	Class.Show
	Class.Fractional

pragma	cc_includes ["math.h"]

-- boxing
foreign import "_boxFloat64"
 boxFloat64	:: forall %r1
		.  Float64# -> Float64 %r1
		:$ Float64# -> Obj

foreign import "_unboxFloat64"
 unboxFloat64	:: forall %r1
		.  Float64 %r1 -(!Read %r1)> Float64#
		:$ Obj -> Float64#

foreign import "primFloat64_toFloat64"
 toFloat64	:: Int64{read} -> Float64

-- math
foreign import "primFloat64_neg"
 primFloat64_neg	:: Float64{read} -> Float64

foreign import "primFloat64_add"
 primFloat64_add	:: Float64{read} -> Float64{read} -> Float64

foreign import "primFloat64_sub"
 primFloat64_sub	:: Float64{read} -> Float64{read} -> Float64

foreign import "primFloat64_mul"
 primFloat64_mul	:: Float64{read} -> Float64{read} -> Float64

foreign import "primFloat64_div"
 primFloat64_div	:: Float64{read} -> Float64{read} -> Float64

foreign import "fmod"
 fmod64U :: Float64# -> Float64# -> Float64#

fmod64 x y		= boxFloat64 (fmod64U (unboxFloat64 x) (unboxFloat64 y))


-- comparisons
foreign import "primFloat64_eq"
 primFloat64_eq		:: Float64{read} -> Float64{read} -> Bool

foreign import "primFloat64_neq"
 primFloat64_neq	:: Float64{read} -> Float64{read} -> Bool

foreign import "primFloat64_gt"
 primFloat64_gt		:: Float64{read} -> Float64{read} -> Bool

foreign import "primFloat64_ge"
 primFloat64_ge		:: Float64{read} -> Float64{read} -> Bool

foreign import "primFloat64_lt"
 primFloat64_lt		:: Float64{read} -> Float64{read} -> Bool

foreign import "primFloat64_le"
 primFloat64_le		:: Float64{read} -> Float64{read} -> Bool

-- update
foreign import "primFloat64_update"
 primFloat64_update	:: Float64{write} -> Float64{read} -> ()

instance Show Float64 where
	show x = string_Float64 x


instance Copy Float64 where
	copy x		= boxFloat64 (unboxFloat64 x)

instance Eq Float64 where
	(==)		= primFloat64_eq
	(/=)		= primFloat64_neq


instance Ord Float64 where
	(>)		= primFloat64_gt
	(>=)		= primFloat64_ge

	(<)		= primFloat64_lt
	(<=)		= primFloat64_le

	compare x y
	 | x < y	= LT
	 | x > y	= GT
	 | otherwise	= EQ

instance Num Float64 where
	(+)		= primFloat64_add
	(-)		= primFloat64_sub
	(*)		= primFloat64_mul
	negate		= primFloat64_neg


instance Fractional Float64 where
	(/)		= primFloat64_div


instance Updatable Float64 where
	(:=)		= primFloat64_update


instance Accum Float64 where
	(+=) a b	= primFloat64_update a (primFloat64_add a b)

-- trig
foreign import "sin"
 sin64U	:: Float64# -> Float64#

foreign import "asin"
 asin64U	:: Float64# -> Float64#

foreign import "cos"
 cos64U	:: Float64# -> Float64#

foreign import "acos"
 acos64U	:: Float64# -> Float64#

foreign import "tan"
 tan64U	:: Float64# -> Float64#

foreign import "atan"
 atan64U	:: Float64# -> Float64#

foreign import "sqrt"
 sqrt64U	:: Float64# -> Float64#

foreign import "trunc"
 trunc64U	:: Float64# -> Float64#

foreign import "pow"
 fpow64U	:: Float64# -> Float64# -> Float64#

sin64 x	= boxFloat64 (sin64U   (unboxFloat64 x))
asin64 x	= boxFloat64 (asin64U  (unboxFloat64 x))
cos64 x	= boxFloat64 (cos64U   (unboxFloat64 x))
acos64 x	= boxFloat64 (acos64U  (unboxFloat64 x))
tan64 x	= boxFloat64 (tan64U   (unboxFloat64 x))
atan64 x	= boxFloat64 (atan64U  (unboxFloat64 x))
sqrt64 x	= boxFloat64 (sqrt64U  (unboxFloat64 x))
trunc64 x = boxFloat64 (trunc64U (unboxFloat64 x))

--
foreign import "log"
 log64U   :: Float64# -> Float64#

foreign import "floor"
 floor64U :: Float64# -> Float64#

foreign import "fabs"
 fabs64U  :: Float64# -> Float64#

log64   x	  = boxFloat64 (log64U   (unboxFloat64 x))
floor64 x	  = boxFloat64 (floor64U (unboxFloat64 x))
fabs64 x	  = boxFloat64 (fabs64U  (unboxFloat64 x))
fpow64 x y  = boxFloat64 (fpow64U  (unboxFloat64 x) (unboxFloat64 y))

-- conversion
foreign import "primFloat64_truncate"
 truncate64 :: Float64{read} -> Int64


project Float64 where

	min :: Float64 -> Float64 -> Float64
	min x y
	 = if x < y	then x
			else y

	max :: Float64 -> Float64 -> Float64
	max x y
	 = if x > y	then x
			else y

	clamp :: Float64 -> Float64 -> Float64 -> Float64
	clamp x a b
		| x < a		= a
		| x > b		= b
		| otherwise	= x


string_Float64 :: Float64 -> String
string_Float64 f
 = do	maxLen	= 40
	maxLenU	= unboxInt32 maxLen
	fU	= unboxFloat64 f

	fs	= new&{FlatString} maxLen
	strU	= fs.danger_string

	-- %f probably isn't the best way of printing floats.
	show_danger_snprintf strU maxLenU "%f"# fU
	fs.setLengthU (stringU_length strU)

	SChunk fs

