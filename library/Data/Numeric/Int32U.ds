{-# OPTIONS -no-implicit-prelude #-}

-- Primitive functions for unboxed Int32 operations.
--	There are no actual C functions associated with these.
--	We define them so the type inferencer has a schemes for them.
--
module	Data.Numeric.Int32U

import	Class.Eq
	Class.Num
	Class.Ord

-- Arithmetic -----------------------------------------------------------------
foreign import "primInt32U_neg"
 primInt32U_neg :: Int32# -> Int32#

foreign import "primInt32U_add"
 primInt32U_add	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_sub"
 primInt32U_sub	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_mul"
 primInt32U_mul	:: Int32# -> Int32# -> Int32#

foreign import "primInt32U_div"
 primInt32U_div	:: Int32# -> Int32# -> Int32#
 
foreign import "primInt32U_mod"
 primInt32U_mod	:: Int32# -> Int32# -> Int32#


-- Comparisons ----------------------------------------------------------------
foreign import "primInt32U_eq"	
 primInt32U_eq	:: Int32# -> Int32# -> Bool#

foreign import "primInt32U_neq"	
 primInt32U_neq	:: Int32# -> Int32# -> Bool#

foreign import "primInt32U_gt"	
 primInt32U_gt	:: Int32# -> Int32# -> Bool#

foreign import "primInt32U_ge"	
 primInt32U_ge	:: Int32# -> Int32# -> Bool#

foreign import "primInt32U_lt"	
 primInt32U_lt	:: Int32# -> Int32# -> Bool#

foreign import "primInt32U_le"	
 primInt32U_le	:: Int32# -> Int32# -> Bool#


-- Instances ------------------------------------------------------------------
instance Eq Int32# where
	(==) x y	= boxBool (primInt32U_eq  x y)
	(/=) x y	= boxBool (primInt32U_neq x y)

instance Ord Int32# where
	(>)		= primInt32U_gt
	(<)		= primInt32U_lt
	(>=)		= primInt32U_ge
	(<=)		= primInt32U_le

instance Num Int32# where 
 	(+) 		= primInt32U_add
	(-) 		= primInt32U_sub
	(*) 		= primInt32U_mul
	(/) 		= primInt32U_div
	mod		= primInt32U_mod
	negate		= primInt32U_neg
