{-# OPTIONS -no-implicit-prelude #-}

import Base
import Data.Bool
import Data.Int
import Data.Int32U
import Data.Float32U

import Class.Eq
import Class.Num
import Class.Ord

pragma	cc_includes ["math.h"]

-- boxing
foreign import "_boxFloat32"
 boxFloat32 	:: forall %r1
  		.  Float32# -> Float %r1
		:$ Float32# -> Obj

foreign import "_unboxFloat32"
 unboxFloat32	:: forall %r1
 		.  Float %r1 -(!Read %r1)> Float32#
		:$ Obj -> Float32#

foreign import "primFloat32_toFloat"
 toFloat	:: Int{read} -> Float

-- math
foreign import "primFloat32_neg"
 primFloat32_neg	:: Float{read} -> Float

foreign import "primFloat32_add"
 primFloat32_add	:: Float{read} -> Float{read} -> Float

foreign import "primFloat32_sub"
 primFloat32_sub	:: Float{read} -> Float{read} -> Float

foreign import "primFloat32_mul"
 primFloat32_mul	:: Float{read} -> Float{read} -> Float

foreign import "primFloat32_div"
 primFloat32_div	:: Float{read} -> Float{read} -> Float

foreign import "fmodf"
 fmodU :: Float32# -> Float32# -> Float32#

fmod x y		= boxFloat32 (fmodU (unboxFloat32 x) (unboxFloat32 y))


-- comparisons
foreign import "primFloat32_eq"
 primFloat32_eq		:: Float{read} -> Float{read} -> Bool

foreign import "primFloat32_neq"
 primFloat32_neq	:: Float{read} -> Float{read} -> Bool

foreign import "primFloat32_gt"
 primFloat32_gt		:: Float{read} -> Float{read} -> Bool

foreign import "primFloat32_ge"
 primFloat32_ge		:: Float{read} -> Float{read} -> Bool

foreign import "primFloat32_lt"
 primFloat32_lt		:: Float{read} -> Float{read} -> Bool

foreign import "primFloat32_le"
 primFloat32_le		:: Float{read} -> Float{read} -> Bool

-- update
foreign import "primFloat32_update"
 primFloat32_update	:: Float{write} -> Float{read} -> ()

instance Copy Float where
	copy x		= boxFloat32 (unboxFloat32 x)


instance Eq Float where
	(==)		= primFloat32_eq
	(/=)		= primFloat32_neq


instance Ord Float where
	(>)		= primFloat32_gt
	(>=)		= primFloat32_ge

	(<)		= primFloat32_lt
	(<=)		= primFloat32_le
	
	compare x y
	 | x < y	= LT
	 | x > y	= GT
	 | otherwise	= EQ

instance Num Float where
	(+)		= primFloat32_add
	(-)		= primFloat32_sub
	(*)		= primFloat32_mul
	(/)		= primFloat32_div
	negate		= primFloat32_neg


instance Updatable Float where
	(:=)		= primFloat32_update


instance Accum Float where
	(+=) a b 	= primFloat32_update a (primFloat32_add a b)

-- trig
foreign import "sinf"
 sinU	:: Float32# -> Float32#

foreign import "asinf"
 asinU	:: Float32# -> Float32#

foreign import "cosf"
 cosU	:: Float32# -> Float32#
 
foreign import "acosf"
 acosU	:: Float32# -> Float32#

foreign import "tanf"
 tanU	:: Float32# -> Float32#
 
foreign import "atanf"
 atanU	:: Float32# -> Float32#

foreign import "sqrtf"
 sqrtU	:: Float32# -> Float32#

foreign import "truncf"
 truncU	:: Float32# -> Float32#

sin x	= boxFloat32 (sinU   (unboxFloat32 x))
asin x	= boxFloat32 (asinU  (unboxFloat32 x))
cos x	= boxFloat32 (cosU   (unboxFloat32 x))
acos x	= boxFloat32 (acosU  (unboxFloat32 x))
tan x	= boxFloat32 (tanU   (unboxFloat32 x))
atan x	= boxFloat32 (atanU  (unboxFloat32 x))
sqrt x	= boxFloat32 (sqrtU  (unboxFloat32 x))
trunc x = boxFloat32 (truncU (unboxFloat32 x))

-- 
foreign import "logf"
 logU   :: Float32# -> Float32#

foreign import "floorf"
 floorU :: Float32# -> Float32#

foreign import "fabsf"
 fabsU  :: Float32# -> Float32#

log   x	= boxFloat32 (logU   (unboxFloat32 x))
floor x	= boxFloat32 (floorU (unboxFloat32 x))
fabs x	= boxFloat32 (fabsU  (unboxFloat32 x))

-- conversion
foreign import "primFloat32_truncate"
 truncate :: Float{read} -> Int


project Float where
	
	min :: Float -> Float -> Float
	min x y
	 = if x < y	then x
			else y

	max :: Float -> Float -> Float		
	max x y
	 = if x > y	then x
 			else y

	clamp :: Float -> Float -> Float -> Float 
	clamp x a b
		| x < a		= a
		| x > b		= b
		| otherwise	= x
	
