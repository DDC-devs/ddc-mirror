{-# OPTIONS -no-implicit-prelude #-}

-- | Arrays of boxed values.
module 	Data.Array 

export	index
	indexR
	
import	Base
	Data.Int
	Data.Ref
	Data.List

project Array a 
 with {	new; size; index; index;
	fromList; toList; 
	mapWithIndex_;
	mapToList;
	updateWith }

-- An array of boxed values.
data Array %r1 a;

-- Primitives -------------------------------------------------------------------------------------
-- These are implemented by the runtime system.

-- | Create a new array and point all the cells to this initial object.
foreign import "primArray_new"
 new  	:: Int{read} -> a -> Array a

-- | Return the number of elements in an array
foreign import "primArray_size"
 size	:: Array a {read} -> Int

-- | Return the element at this index.
--	The array.(i) syntax is desugared into this.
foreign import "primArray_index"
 index	:: Array a {read} -> Int{read} -> a
 	
-- | Return a reference to this index. 
--     The reference refers to the location in the array, 
--     so updating the reference also updates the array.
---    The array#(i) syntax is desugared into this.
foreign import "primArray_indexR"
 indexR	:: Array %r1 a {read} -> Int %r2 {read} -> Ref %r1 a


-- Instances ------------------------------------------------------------------
instance Functor Array where
 map_ f array
  = go f array 0 array.size
  where 
	go f array ix max
	 | ix >= max	= ()
	 \= do	f array.(ix)
		go f array (ix + 1) max


instance Foldable Array where
 foldl f acc array 
  = go f acc array 0 array.size
  where	
	go f acc array ix max
	 | ix >= max	= acc
	 \= go f (f acc array.(ix)) array (ix + 1) max


-- Conversion -----------------------------------------------------------------
-- | Create an array from a list.
fromList :: [a] -> Array a
fromList xx 
 = go 0 xx
 where	len	= length xx
	arr 	= new len 0

	go ix []
	 | ix == len
	 = arr
	
	go ix (x:xs)  
	 = do	arr#(ix)  #= x
		go (ix + 1) xs


-- | Convert an array to a list.
-- TODO: this uses O(n) stack space.
toList :: Array a -> [a]
toList arr = go 0
 where	go ix 
 	 | ix == arr.size	= []
 	 | otherwise		= arr.(ix) : go (ix + 1)


-- Mapping ----------------------------------------------------------------------------------------		
-- Map a  function across all the elements of an array
--	with the array index, ignoring the result
mapWithIndex_ :: Array a -> (Int -> a -> b) -> ()
mapWithIndex_ array f
 = go 0
 where	len	= array.size
	
	go ix 
	 | ix >= len	= ()
	 \= do	f ix array.(ix)
		go (ix + 1)


-- Map a function across all the elements of an array, 
--	returning a list
mapToList :: Array a -> (a -> b) -> [b]
mapToList  array f
 = mapToList' f array 0 (array .size)

mapToList' f array i max
	| i >= max	
	=  []
	
	\= f (array .(i)) : mapToList' f array (i + 1) max
	

-- Updating ---------------------------------------------------------------------------------------
-- update all the elements of an array with this function
--	the array cells are pointed to the new objects
updateWith :: (a -> a) -> Array a -> ()
updateWith fun array
 = do	max	= size array
 	updateWith' fun array 0 max
	
updateWith' fun array ix max
	| ix >= max	= ()
	\= do	x'	= fun array.(ix)
		array #(ix) #= x'

		updateWith' fun array (ix + 1) max

